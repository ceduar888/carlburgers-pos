<?xml version="1.0"?>
<doc>
    <assembly>
        <name>BouncyCastle.OpenPgp</name>
    </assembly>
    <members>
        <member name="T:Org.BouncyCastle.Asn1.Anssi.AnssiNamedCurves">
            <summary>Elliptic curve registry for ANSSI.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Anssi.AnssiNamedCurves.GetByName(System.String)">
            <summary>Look up the <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Anssi.AnssiNamedCurves.GetByNameLazy(System.String)">
            <summary>Look up an <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given name.</summary>
            <remarks>
            Allows accessing the <see cref="T:Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of the
            full <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Anssi.AnssiNamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given
            <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Anssi.AnssiNamedCurves.GetByOidLazy(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up an <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given
            <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <remarks>
            Allows accessing the <see cref="T:Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of the
            full <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="oid">The <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Anssi.AnssiNamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the name of the curve with the given <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Anssi.AnssiNamedCurves.GetOid(System.String)">
            <summary>Look up the <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> of the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Anssi.AnssiNamedCurves.Names">
            <summary>Enumerate the available curve names in this registry.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1BitStringParser.GetBitStream">
            <summary>Return a <see cref="T:System.IO.Stream"/> representing the contents of the BIT STRING. The final byte, if any,
            may include pad bits. See <see cref="P:Org.BouncyCastle.Asn1.Asn1BitStringParser.PadBits"/>.</summary>
            <returns>A <see cref="T:System.IO.Stream"/> with its source as the BIT STRING content.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1BitStringParser.GetOctetStream">
            <summary>Return a <see cref="T:System.IO.Stream"/> representing the contents of the BIT STRING, where the content is
            expected to be octet-aligned (this will be automatically checked during parsing).</summary>
            <returns>A <see cref="T:System.IO.Stream"/> with its source as the BIT STRING content.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Asn1BitStringParser.PadBits">
            <summary>Return the number of pad bits, if any, in the final byte, if any, read from
            <see cref="M:Org.BouncyCastle.Asn1.Asn1BitStringParser.GetBitStream"/>.</summary>
            <remarks>
            This number is in the range zero to seven. That number of the least significant bits of the final byte, if
            any, are not part of the contents and should be ignored. NOTE: Must be called AFTER the stream has been
            fully processed. (Does not need to be called if <see cref="M:Org.BouncyCastle.Asn1.Asn1BitStringParser.GetOctetStream"/> was used instead of
            <see cref="M:Org.BouncyCastle.Asn1.Asn1BitStringParser.GetBitStream"/>.
            </remarks>
            <returns>The number of pad bits. In the range zero to seven.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Encodable.GetDerEncoded">
             Return the DER encoding of the object, null if the DER encoding can not be made.
            
             @return a DER byte array, null otherwise.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Asn1EncodableVector">
            Mutable class for building ASN.1 constructed objects such as SETs or SEQUENCEs.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Asn1GeneralizedTime">
            <summary>GeneralizedTime ASN.1 type</summary>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Asn1InputStream">
            a general purpose ASN.1 decoder - note: this class differs from the
            others in that it returns null after it has read the last object in
            the stream. If an ASN.1 Null is encountered a Der/BER Null object is
            returned.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1InputStream.#ctor(System.Byte[])">
             Create an ASN1InputStream based on the input byte array. The length of DER objects in
             the stream is automatically limited to the length of the input array.
            
             @param input array containing ASN.1 encoded data.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1InputStream.#ctor(System.IO.Stream,System.Int32)">
             Create an ASN1InputStream where no DER object will be longer than limit.
            
             @param input stream containing ASN.1 encoded data.
             @param limit maximum size of a DER encoded object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1InputStream.BuildObject(System.Int32,System.Int32,System.Int32)">
            build an object given its tag and the number of bytes to construct it from.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Asn1Null">
            A Null object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Object.FromByteArray(System.Byte[])">
            <summary>Create a base ASN.1 object from a byte array.</summary>
            <param name="data">The byte array to parse.</param>
            <returns>The base ASN.1 object represented by the byte array.</returns>
            <exception cref="T:System.IO.IOException">
            If there is a problem parsing the data, or parsing an object did not exhaust the available data.
            </exception>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Object.FromStream(System.IO.Stream)">
            <summary>Read a base ASN.1 object from a stream.</summary>
            <param name="inStr">The stream to parse.</param>
            <returns>The base ASN.1 object represented by the byte array.</returns>
            <exception cref="T:System.IO.IOException">If there is a problem parsing the data.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1ObjectDescriptor.GetInstance(System.Object)">
             Return an ObjectDescriptor from the passed in object.
            
             @param obj an ASN1ObjectDescriptor or an object that can be converted into one.
             @exception IllegalArgumentException if the object cannot be converted.
             @return an ASN1ObjectDescriptor instance, or null.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1ObjectDescriptor.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             Return an ObjectDescriptor from a tagged object.
            
             @param taggedObject the tagged object holding the object we want.
             @param declaredExplicit true if the object is meant to be explicitly tagged, false otherwise.
             @exception IllegalArgumentException if the tagged object cannot be converted.
             @return an ASN1ObjectDescriptor instance, or null.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1OctetString.GetInstance(System.Object)">
             return an Octet string from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1OctetString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an octet string from a tagged object.
            
             @param taggedObject the tagged object holding the object we want.
             @param declaredExplicit true if the object is meant to be explicitly tagged false otherwise.
             @exception ArgumentException if the tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1OctetString.#ctor(System.Byte[])">
            @param string the octets making up the octet string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1OctetStringParser.GetOctetStream">
            <summary>Return the content of the OCTET STRING as a <see cref="T:System.IO.Stream"/>.</summary>
            <returns>A <see cref="T:System.IO.Stream"/> represnting the OCTET STRING's content.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Sequence.GetInstance(System.Object)">
             return an Asn1Sequence from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Sequence.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             Return an ASN1 sequence from a tagged object. There is a special
             case here, if an object appears to have been explicitly tagged on
             reading but we were expecting it to be implicitly tagged in the
             normal course of events it indicates that we lost the surrounding
             sequence - so we need to add it back (this will happen if the tagged
             object is a sequence that contains other sequences). If you are
             dealing with implicitly tagged sequences you really <b>should</b>
             be using this method.
            
             @param taggedObject the tagged object.
             @param declaredExplicit true if the object is meant to be explicitly tagged, false otherwise.
             @exception ArgumentException if the tagged object cannot be converted.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Asn1Sequence.Item(System.Int32)">
             return the object at the sequence position indicated by index.
            
             @param index the sequence number (starting at zero) of the object
             @return the object at the sequence position indicated by index.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Set.GetInstance(System.Object)">
             return an ASN1Set from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Set.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             Return an ASN1 set from a tagged object. There is a special
             case here, if an object appears to have been explicitly tagged on
             reading but we were expecting it to be implicitly tagged in the
             normal course of events it indicates that we lost the surrounding
             set - so we need to add it back (this will happen if the tagged
             object is a sequence that contains other sequences). If you are
             dealing with implicitly tagged sets you really <b>should</b>
             be using this method.
            
             @param taggedObject the tagged object.
             @param declaredExplicit true if the object is meant to be explicitly tagged false otherwise.
             @exception ArgumentException if the tagged object cannot be converted.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Asn1Set.Item(System.Int32)">
             return the object at the set position indicated by index.
            
             @param index the set number (starting at zero) of the object
             @return the object at the set position indicated by index.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Asn1TaggedObject">
            ASN.1 TaggedObject - in ASN.1 notation this is any object preceded by
            a [n] where n is some number - these are assumed to follow the construction
            rules (as with sequences).
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObject.#ctor(System.Boolean,System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param explicitly true if the object is explicitly tagged.
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObject.IsExplicit">
            return whether or not the object may be explicitly tagged.
            <p>
            Note: if the object has been read from an input stream, the only
            time you can be sure if isExplicit is returning the true state of
            affairs is if it returns false. An implicitly tagged object may appear
            to be explicitly tagged, so you need to understand the context under
            which the reading was done as well, see GetObject below.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObject.GetObject">
            return whatever was following the tag.
            <p>
            Note: tagged objects are generally context dependent if you're
            trying to extract a tagged object you should be going via the
            appropriate GetInstance method.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObject.GetBaseObject">
            Needed for open types, until we have better type-guided parsing support. Use sparingly for other
            purposes, and prefer {@link #getExplicitBaseTagged()}, {@link #getImplicitBaseTagged(int, int)} or
            {@link #getBaseUniversal(boolean, int)} where possible. Before using, check for matching tag
            {@link #getTagClass() class} and {@link #getTagNo() number}.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObject.GetExplicitBaseObject">
            Needed for open types, until we have better type-guided parsing support. Use
            sparingly for other purposes, and prefer {@link #getExplicitBaseTagged()} or
            {@link #getBaseUniversal(boolean, int)} where possible. Before using, check
            for matching tag {@link #getTagClass() class} and {@link #getTagNo() number}.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObjectParser.ParseBaseUniversal(System.Boolean,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObjectParser.ParseExplicitBaseObject">
            <summary>Needed for open types, until we have better type-guided parsing support.</summary>
            <remarks>
            Use sparingly for other purposes, and prefer <see cref="M:Org.BouncyCastle.Asn1.Asn1TaggedObjectParser.ParseExplicitBaseTagged"/> or
            <see cref="M:Org.BouncyCastle.Asn1.Asn1TaggedObjectParser.ParseBaseUniversal(System.Boolean,System.Int32)"/> where possible. Before using, check for matching tag
            <see cref="P:Org.BouncyCastle.Asn1.Asn1TaggedObjectParser.TagClass">class</see> and <see cref="P:Org.BouncyCastle.Asn1.Asn1TaggedObjectParser.TagNo">number</see>.
            </remarks>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObjectParser.ParseExplicitBaseTagged">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObjectParser.ParseImplicitBaseTagged(System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1UniversalType.FromByteArray(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Asn1UtcTime">
            <summary>UTCTime ASN.1 type</summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1UtcTime.GetInstance(System.Object)">
             return a UTC Time from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1UtcTime.ToAdjustedDateTime">
            <summary>Return an adjusted date in the range of 1950 - 2049.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Utilities.ParseExplicitBaseTagged(Org.BouncyCastle.Asn1.Asn1TaggedObjectParser,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Utilities.ParseExplicitContextBaseTagged(Org.BouncyCastle.Asn1.Asn1TaggedObjectParser,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Utilities.TryParseExplicitBaseTagged(Org.BouncyCastle.Asn1.Asn1TaggedObjectParser,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Utilities.TryParseExplicitContextBaseTagged(Org.BouncyCastle.Asn1.Asn1TaggedObjectParser,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Utilities.ParseImplicitBaseTagged(Org.BouncyCastle.Asn1.Asn1TaggedObjectParser,System.Int32,System.Int32,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Utilities.ParseImplicitContextBaseTagged(Org.BouncyCastle.Asn1.Asn1TaggedObjectParser,System.Int32,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Utilities.TryParseImplicitBaseTagged(Org.BouncyCastle.Asn1.Asn1TaggedObjectParser,System.Int32,System.Int32,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Utilities.TryParseImplicitContextBaseTagged(Org.BouncyCastle.Asn1.Asn1TaggedObjectParser,System.Int32,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Utilities.ParseBaseUniversal(Org.BouncyCastle.Asn1.Asn1TaggedObjectParser,System.Int32,System.Int32,System.Boolean,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Utilities.ParseContextBaseUniversal(Org.BouncyCastle.Asn1.Asn1TaggedObjectParser,System.Int32,System.Boolean,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Utilities.TryParseBaseUniversal(Org.BouncyCastle.Asn1.Asn1TaggedObjectParser,System.Int32,System.Int32,System.Boolean,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Utilities.TryParseContextBaseUniversal(Org.BouncyCastle.Asn1.Asn1TaggedObjectParser,System.Int32,System.Boolean,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Utilities.ParseExplicitBaseObject(Org.BouncyCastle.Asn1.Asn1TaggedObjectParser,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Utilities.ParseExplicitContextBaseObject(Org.BouncyCastle.Asn1.Asn1TaggedObjectParser,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Utilities.TryParseExplicitBaseObject(Org.BouncyCastle.Asn1.Asn1TaggedObjectParser,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Utilities.TryParseExplicitContextBaseObject(Org.BouncyCastle.Asn1.Asn1TaggedObjectParser,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc">
            iso.org.dod.internet.private.enterprise.legion-of-the-bouncy-castle
            <p>1.3.6.1.4.1.22554</p>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe">
            pbe(1) algorithms
            <p>1.3.6.1.4.1.22554.1</p>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha1">
            SHA-1(1)
            <p>1.3.6.1.4.1.22554.1.1</p>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha256">
            SHA-2.SHA-256; 1.3.6.1.4.1.22554.1.2.1 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha384">
            SHA-2.SHA-384; 1.3.6.1.4.1.22554.1.2.2 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha512">
            SHA-2.SHA-512; 1.3.6.1.4.1.22554.1.2.3 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha224">
            SHA-2.SHA-224; 1.3.6.1.4.1.22554.1.2.4 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha1_pkcs5">
            PKCS-5(1)|PKCS-12(2)
            SHA-1.PKCS5;  1.3.6.1.4.1.22554.1.1.1 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha1_pkcs12">
            SHA-1.PKCS12; 1.3.6.1.4.1.22554.1.1.2 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha256_pkcs5">
            SHA-256.PKCS12; 1.3.6.1.4.1.22554.1.2.1.1 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha256_pkcs12">
            SHA-256.PKCS12; 1.3.6.1.4.1.22554.1.2.1.2 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha1_pkcs12_aes128_cbc">
            AES(1) . (CBC-128(2)|CBC-192(22)|CBC-256(42))
            1.3.6.1.4.1.22554.1.1.2.1.2 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha1_pkcs12_aes192_cbc">
            1.3.6.1.4.1.22554.1.1.2.1.22 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha1_pkcs12_aes256_cbc">
            1.3.6.1.4.1.22554.1.1.2.1.42 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha256_pkcs12_aes128_cbc">
            1.3.6.1.4.1.22554.1.1.2.2.2 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha256_pkcs12_aes192_cbc">
            1.3.6.1.4.1.22554.1.1.2.2.22 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha256_pkcs12_aes256_cbc">
            1.3.6.1.4.1.22554.1.1.2.2.42 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_sig">
            signature(2) algorithms
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.sphincs256">
            Sphincs-256
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.xmss">
            XMSS
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.xmss_mt">
            XMSS^MT
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.sphincsPlus">
            SPHINCS+
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.picnic">
            Picnic
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_exch">
            key_exchange(3) algorithms
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.newHope">
            NewHope
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_ext">
            X.509 extension(4) values
            <p/>
            1.3.6.1.4.1.22554.4
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_kem">
            KEM(4) algorithms
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.pqc_kem_mceliece">
            Classic McEliece
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.pqc_kem_saber">
            SABER
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.pqc_kem_sike">
            SIKE
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.pqc_kem_kyber">
            Kyber
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.pqc_kem_bike">
            BIKE
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.pqc_kem_hqc">
            HQC
        </member>
        <member name="T:Org.BouncyCastle.Asn1.BerBitStringParser">
            <summary>A parser for indefinite-length BIT STRINGs.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerSequence.#ctor">
            create an empty sequence
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerSequence.#ctor(Org.BouncyCastle.Asn1.Asn1Encodable)">
            create a sequence containing one object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerSequence.#ctor(Org.BouncyCastle.Asn1.Asn1Encodable,Org.BouncyCastle.Asn1.Asn1Encodable)">
            create a sequence containing two objects
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerSequence.#ctor(Org.BouncyCastle.Asn1.Asn1EncodableVector)">
            create a sequence containing a vector of objects.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerSet.#ctor">
            create an empty set
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerSet.#ctor(Org.BouncyCastle.Asn1.Asn1Encodable)">
            create a set containing one object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerSet.#ctor(Org.BouncyCastle.Asn1.Asn1EncodableVector)">
            create a set containing a vector of objects.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.BerTaggedObject">
            BER TaggedObject - in ASN.1 notation this is any object preceded by
            a [n] where n is some number - these are assumed to follow the construction
            rules (as with sequences).
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerTaggedObject.#ctor(System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerTaggedObject.#ctor(System.Boolean,System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param isExplicit true if an explicitly tagged object.
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Bsi.BsiObjectIdentifiers">
            <remarks>See https://www.bsi.bund.de/cae/servlet/contentblob/471398/publicationFile/30615/BSI-TR-03111_pdf.pdf</remarks>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Bsi.BsiObjectIdentifiers.algorithm">
            0.4.0.127.0.7.1 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Bsi.BsiObjectIdentifiers.ecka_eg_X963kdf">
            ElGamal Elliptic Curve Key Agreement and Key Derivation according to X963 OID: 0.4.0.127.0.7.1.1.5.1.1 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Bsi.BsiObjectIdentifiers.ecka_eg_X963kdf_SHA1">
            ElGamal Elliptic Curve Key Agreement and Key Derivation according to X963
            with hash function SHA-1
            OID: 0.4.0.127.0.7.1.1.5.1.1.1 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Bsi.BsiObjectIdentifiers.ecka_eg_X963kdf_SHA224">
            ElGamal Elliptic Curve Key Agreement and Key Derivation according to X963
            with hash function SHA224
            OID: 0.4.0.127.0.7.1.1.5.1.1.2 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Bsi.BsiObjectIdentifiers.ecka_eg_X963kdf_SHA256">
            ElGamal Elliptic Curve Key Agreement and Key Derivation according to X963
            with hash function SHA256
            OID: 0.4.0.127.0.7.1.1.5.1.1.3 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Bsi.BsiObjectIdentifiers.ecka_eg_X963kdf_SHA384">
            ElGamal Elliptic Curve Key Agreement and Key Derivation according to X963
            with hash function SHA384
            OID: 0.4.0.127.0.7.1.1.5.1.1.4 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Bsi.BsiObjectIdentifiers.ecka_eg_X963kdf_SHA512">
            ElGamal Elliptic Curve Key Agreement and Key Derivation according to X963
            with hash function SHA512
            OID: 0.4.0.127.0.7.1.1.5.1.1.5 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Bsi.BsiObjectIdentifiers.ecka_eg_X963kdf_RIPEMD160">
            ElGamal Elliptic Curve Key Agreement and Key Derivation according to X963
            with hash function RIPEMD160
            OID: 0.4.0.127.0.7.1.1.5.1.1.6 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Bsi.BsiObjectIdentifiers.ecka_eg_SessionKDF">
            Key Derivation Function for Session Keys
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.Attribute.GetInstance(System.Object)">
             return an Attribute object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.Attribute.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Attribute ::= SEQUENCE {
                attrType OBJECT IDENTIFIER,
                attrValues SET OF AttributeValue
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.Attributes.ToAsn1Object">
            <pre>
            Attributes ::=
              SET SIZE(1..MAX) OF Attribute -- according to RFC 5652
            </pre>
            @return
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Cms.AttributeTable.Item(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Return the first attribute matching the given OBJECT IDENTIFIER</summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.AttributeTable.GetAll(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             Return all the attributes matching the OBJECT IDENTIFIER oid. The vector will be
             empty if there are no attributes of the required type present.
            
             @param oid type of attribute required.
             @return a vector of all the attributes found of type oid.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.AttributeTable.Add(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.Asn1Encodable)">
             Return a new table with the passed in attribute added.
            
             @param attrType
             @param attrValue
             @return
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Cms.CmsObjectIdentifiers.id_ri">
            The other Revocation Info arc
            id-ri OBJECT IDENTIFIER ::= { iso(1) identified-organization(3)
                                              dod(6) internet(1) security(5) mechanisms(5) pkix(7) ri(16) }
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.ContentInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            ContentInfo ::= Sequence {
                     contentType ContentType,
                     content
                     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.Ecc.MQVuserKeyingMaterial.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an AuthEnvelopedData object from a tagged object.
            
             @param obj      the tagged object holding the object we want.
             @param isExplicit true if the object is meant to be explicitly
                             tagged false otherwise.
             @throws ArgumentException if the object held by the
                                              tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.Ecc.MQVuserKeyingMaterial.GetInstance(System.Object)">
             return an AuthEnvelopedData object from the given object.
            
             @param obj the object we want converted.
             @throws ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.Ecc.MQVuserKeyingMaterial.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            MQVuserKeyingMaterial ::= SEQUENCE {
              ephemeralPublicKey OriginatorPublicKey,
              addedukm [0] EXPLICIT UserKeyingMaterial OPTIONAL  }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KekIdentifier.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a KekIdentifier object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KekIdentifier.GetInstance(System.Object)">
             return a KekIdentifier object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KekIdentifier.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            KekIdentifier ::= Sequence {
                keyIdentifier OCTET STRING,
                date GeneralizedTime OPTIONAL,
                other OtherKeyAttribute OPTIONAL
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KekRecipientInfo.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a KekRecipientInfo object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KekRecipientInfo.GetInstance(System.Object)">
             return a KekRecipientInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KekRecipientInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            KekRecipientInfo ::= Sequence {
                version CMSVersion,  -- always set to 4
                kekID KekIdentifier,
                keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
                encryptedKey EncryptedKey
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientIdentifier.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an KeyAgreeRecipientIdentifier object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param isExplicit true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientIdentifier.GetInstance(System.Object)">
             return an KeyAgreeRecipientIdentifier object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientIdentifier.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            KeyAgreeRecipientIdentifier ::= CHOICE {
                issuerAndSerialNumber IssuerAndSerialNumber,
                rKeyId [0] IMPLICIT RecipientKeyIdentifier
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientInfo.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a KeyAgreeRecipientInfo object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientInfo.GetInstance(System.Object)">
             return a KeyAgreeRecipientInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientInfo.ToAsn1Object">
                     * Produce an object suitable for an Asn1OutputStream.
                     * <pre>
                     * KeyAgreeRecipientInfo ::= Sequence {
                     *     version CMSVersion,  -- always set to 3
                     *     originator [0] EXPLICIT OriginatorIdentifierOrKey,
                     *     ukm [1] EXPLICIT UserKeyingMaterial OPTIONAL,
                     *     keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
                     *     recipientEncryptedKeys RecipientEncryptedKeys
                     * }
            		 *
            		 * UserKeyingMaterial ::= OCTET STRING
                     * </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KeyTransRecipientInfo.GetInstance(System.Object)">
             return a KeyTransRecipientInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KeyTransRecipientInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            KeyTransRecipientInfo ::= Sequence {
                version CMSVersion,  -- always set to 0 or 2
                rid RecipientIdentifier,
                keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
                encryptedKey EncryptedKey
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorIdentifierOrKey.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an OriginatorIdentifierOrKey object from a tagged object.
            
             @param o the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorIdentifierOrKey.GetInstance(System.Object)">
             return an OriginatorIdentifierOrKey object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorIdentifierOrKey.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             OriginatorIdentifierOrKey ::= CHOICE {
                 issuerAndSerialNumber IssuerAndSerialNumber,
                 subjectKeyIdentifier [0] SubjectKeyIdentifier,
                 originatorKey [1] OriginatorPublicKey
             }
            
             SubjectKeyIdentifier ::= OCTET STRING
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorPublicKey.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an OriginatorPublicKey object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorPublicKey.GetInstance(System.Object)">
             return an OriginatorPublicKey object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorPublicKey.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            OriginatorPublicKey ::= Sequence {
                algorithm AlgorithmIdentifier,
                publicKey BIT STRING
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OtherKeyAttribute.GetInstance(System.Object)">
             return an OtherKeyAttribute object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OtherKeyAttribute.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            OtherKeyAttribute ::= Sequence {
                keyAttrId OBJECT IDENTIFIER,
                keyAttr ANY DEFINED BY keyAttrId OPTIONAL
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OtherRecipientInfo.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a OtherRecipientInfo object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OtherRecipientInfo.GetInstance(System.Object)">
             return a OtherRecipientInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OtherRecipientInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            OtherRecipientInfo ::= Sequence {
               oriType OBJECT IDENTIFIER,
               oriValue ANY DEFINED BY oriType }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OtherRevocationInfoFormat.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a OtherRevocationInfoFormat object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicit true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception IllegalArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OtherRevocationInfoFormat.GetInstance(System.Object)">
             return a OtherRevocationInfoFormat object from the given object.
            
             @param obj the object we want converted.
             @exception IllegalArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OtherRevocationInfoFormat.ToAsn1Object">
            Produce an object suitable for an ASN1OutputStream.
            <pre>
            OtherRevocationInfoFormat ::= SEQUENCE {
                 otherRevInfoFormat OBJECT IDENTIFIER,
                 otherRevInfo ANY DEFINED BY otherRevInfoFormat }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.PasswordRecipientInfo.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a PasswordRecipientInfo object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.PasswordRecipientInfo.GetInstance(System.Object)">
             return a PasswordRecipientInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.PasswordRecipientInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            PasswordRecipientInfo ::= Sequence {
              version CMSVersion,   -- Always set to 0
              keyDerivationAlgorithm [0] KeyDerivationAlgorithmIdentifier
                                        OPTIONAL,
             keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
             encryptedKey EncryptedKey }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientEncryptedKey.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an RecipientEncryptedKey object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param isExplicit true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientEncryptedKey.GetInstance(System.Object)">
             return a RecipientEncryptedKey object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientEncryptedKey.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            RecipientEncryptedKey ::= SEQUENCE {
                rid KeyAgreeRecipientIdentifier,
                encryptedKey EncryptedKey
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientIdentifier.GetInstance(System.Object)">
             return a RecipientIdentifier object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientIdentifier.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             RecipientIdentifier ::= CHOICE {
                 issuerAndSerialNumber IssuerAndSerialNumber,
                 subjectKeyIdentifier [0] SubjectKeyIdentifier
             }
            
             SubjectKeyIdentifier ::= OCTET STRING
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            RecipientInfo ::= CHOICE {
                ktri KeyTransRecipientInfo,
                kari [1] KeyAgreeRecipientInfo,
                kekri [2] KekRecipientInfo,
                pwri [3] PasswordRecipientInfo,
                ori [4] OtherRecipientInfo }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientKeyIdentifier.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a RecipientKeyIdentifier object from a tagged object.
            
             @param _ato the tagged object holding the object we want.
             @param _explicit true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientKeyIdentifier.GetInstance(System.Object)">
             return a RecipientKeyIdentifier object from the given object.
            
             @param _obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientKeyIdentifier.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             RecipientKeyIdentifier ::= Sequence {
                 subjectKeyIdentifier SubjectKeyIdentifier,
                 date GeneralizedTime OPTIONAL,
                 other OtherKeyAttribute OPTIONAL
             }
            
             SubjectKeyIdentifier ::= OCTET STRING
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.SignerIdentifier.GetInstance(System.Object)">
             return a SignerIdentifier object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.SignerIdentifier.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             SignerIdentifier ::= CHOICE {
                 issuerAndSerialNumber IssuerAndSerialNumber,
                 subjectKeyIdentifier [0] SubjectKeyIdentifier
             }
            
             SubjectKeyIdentifier ::= OCTET STRING
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.SignerInfo.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
              SignerInfo ::= Sequence {
                  version Version,
                  SignerIdentifier sid,
                  digestAlgorithm DigestAlgorithmIdentifier,
                  authenticatedAttributes [0] IMPLICIT Attributes OPTIONAL,
                  digestEncryptionAlgorithm DigestEncryptionAlgorithmIdentifier,
                  encryptedDigest EncryptedDigest,
                  unauthenticatedAttributes [1] IMPLICIT Attributes OPTIONAL
              }
            
              EncryptedDigest ::= OCTET STRING
            
              DigestAlgorithmIdentifier ::= AlgorithmIdentifier
            
              DigestEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.Time.#ctor(System.DateTime)">
            creates a time object from a given date - if the date is between 1950
            and 2049 a UTCTime object is Generated, otherwise a GeneralizedTime
            is used.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.Time.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Time ::= CHOICE {
                        utcTime        UTCTime,
                        generalTime    GeneralizedTime }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves">
            <summary>Elliptic curve registry for GOST 3410-2001 / 2012.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves.GetByName(System.String)">
            <summary>Look up the <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves.GetByNameLazy(System.String)">
            <summary>Look up an <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given name.</summary>
            <remarks>
            Allows accessing the <see cref="T:Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of the
            full <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given
            <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves.GetByOidLazy(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up an <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given
            <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <remarks>
            Allows accessing the <see cref="T:Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of the
            full <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="oid">The <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the name of the curve with the given <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves.GetOid(System.String)">
            <summary>Look up the <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> of the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves.Names">
            <summary>Enumerate the available curve names in this registry.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.CryptoPro.Gost3410NamedParameters">
            <summary>Registry of available named parameters for GOST 3410-94.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.CryptoPro.Gost3410NamedParameters.GetByName(System.String)">
            <summary>Look up the <see cref="T:Org.BouncyCastle.Asn1.CryptoPro.Gost3410ParamSetParameters"/> for the parameter set with the given name.
            </summary>
            <param name="name">The name of the parameter set.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.CryptoPro.Gost3410NamedParameters.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the <see cref="T:Org.BouncyCastle.Asn1.CryptoPro.Gost3410ParamSetParameters"/> for the parameter set with the given
            <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the parameter set.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.CryptoPro.Gost3410NamedParameters.GetOid(System.String)">
            <summary>Look up the <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> of the parameter set with the given name.
            </summary>
            <param name="name">The name of the parameter set.</param>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.CryptoPro.Gost3410NamedParameters.Names">
            <summary>Enumerate the available parameter set names in this registry.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBitString.GetInstance(System.Object)">
             return a Bit string from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBitString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Bit string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBitString.#ctor(System.Byte[],System.Int32)">
            @param data the octets making up the bit string.
            @param padBits the number of extra bits at the end of the string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBitString.GetOctets">
             Return the octets contained in this BIT STRING, checking that this BIT STRING really
             does represent an octet aligned string. Only use this method when the standard you are
             following dictates that the BIT STRING will be octet aligned.
            
             @return a copy of the octet aligned data.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerBitString.IntValue">
            @return the value of the bit string as an int (truncating if necessary)
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerBmpString">
            Der BMPString object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBmpString.GetInstance(System.Object)">
             return a BMP string from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBmpString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a BMP string from a tagged object.
            
             @param taggedObject the tagged object holding the object we want
             @param declaredExplicit true if the object is meant to be explicitly tagged false otherwise.
             @exception ArgumentException if the tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBmpString.#ctor(System.String)">
            basic constructor
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBoolean.GetInstance(System.Object)">
             return a bool from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBoolean.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Boolean from a tagged object.
            
             @param taggedObject the tagged object holding the object we want
             @param declaredExplicit true if the object is meant to be explicitly tagged false otherwise.
             @exception ArgumentException if the tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerEnumerated.GetInstance(System.Object)">
             return an integer from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerEnumerated.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an Enumerated from a tagged object.
            
             @param taggedObject the tagged object holding the object we want
             @param declaredExplicit true if the object is meant to be explicitly tagged false otherwise.
             @exception ArgumentException if the tagged object cannot be converted.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerExternal">
            Class representing the DER-type External
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerExternal.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.DerInteger,Org.BouncyCastle.Asn1.Asn1ObjectDescriptor,Org.BouncyCastle.Asn1.DerTaggedObject)">
            Creates a new instance of DerExternal
            See X.690 for more informations about the meaning of these parameters
            @param directReference The direct reference or <code>null</code> if not set.
            @param indirectReference The indirect reference or <code>null</code> if not set.
            @param dataValueDescriptor The data value descriptor or <code>null</code> if not set.
            @param externalData The external data in its encoded form.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerExternal.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.DerInteger,Org.BouncyCastle.Asn1.Asn1ObjectDescriptor,System.Int32,Org.BouncyCastle.Asn1.Asn1Object)">
            Creates a new instance of DerExternal.
            See X.690 for more informations about the meaning of these parameters
            @param directReference The direct reference or <code>null</code> if not set.
            @param indirectReference The indirect reference or <code>null</code> if not set.
            @param dataValueDescriptor The data value descriptor or <code>null</code> if not set.
            @param encoding The encoding to be used for the external data
            @param externalData The external data
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerExternal.Encoding">
            The encoding of the content. Valid values are
            <ul>
            <li><code>0</code> single-ASN1-type</li>
            <li><code>1</code> OCTET STRING</li>
            <li><code>2</code> BIT STRING</li>
            </ul>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGraphicString.GetInstance(System.Object)">
             return a Graphic String from the passed in object
            
             @param obj a DerGraphicString or an object that can be converted into one.
             @exception IllegalArgumentException if the object cannot be converted.
             @return a DerGraphicString instance, or null.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGraphicString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Graphic String from a tagged object.
            
             @param taggedObject the tagged object holding the object we want
             @param declaredExplicit true if the object is meant to be explicitly tagged false otherwise.
             @exception IllegalArgumentException if the tagged object cannot be converted.
             @return a DerGraphicString instance, or null.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerIA5String">
            IA5String object - this is an Ascii string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.GetInstance(System.Object)">
             return an IA5 string from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an IA5 string from a tagged object.
            
             @param taggedObject the tagged object holding the object we want
             @param declaredExplicit true if the object is meant to be explicitly tagged false otherwise.
             @exception ArgumentException if the tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.#ctor(System.String,System.Boolean)">
             Constructor with optional validation.
            
             @param string the base string to wrap.
             @param validate whether or not to check the string.
             @throws ArgumentException if validate is true and the string
             contains characters that should not be in an IA5String.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.IsIA5String(System.String)">
             return true if the passed in String can be represented without
             loss as an IA5String, false otherwise.
            
             @return true if in printable set, false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerInteger.GetInstance(System.Object)">
             return an integer from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerInteger.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an Integer from a tagged object.
            
             @param taggedObject the tagged object holding the object we want
             @param declaredExplicit true if the object is meant to be explicitly tagged false otherwise.
             @exception ArgumentException if the tagged object cannot  be converted.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerInteger.PositiveValue">
            in some cases positive values Get crammed into a space,
            that's not quite big enough...
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerInteger.IsMalformed(System.Byte[])">
             Apply the correct validation for an INTEGER primitive following the BER rules.
            
             @param bytes The raw encoding of the integer.
             @return true if the (in)put fails this validation.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerNull">
            A Null object.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerNumericString">
            Der NumericString object - this is an ascii string of characters {0,1,2,3,4,5,6,7,8,9, }.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.GetInstance(System.Object)">
             return a numeric string from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a numeric string from a tagged object.
            
             @param taggedObject the tagged object holding the object we want
             @param declaredExplicit true if the object is meant to be explicitly tagged false otherwise.
             @exception ArgumentException if the tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.#ctor(System.String,System.Boolean)">
             Constructor with optional validation.
            
             @param string the base string to wrap.
             @param validate whether or not to check the string.
             @throws ArgumentException if validate is true and the string
             contains characters that should not be in a NumericString.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.IsNumericString(System.String)">
             Return true if the string can be represented as a NumericString ('0'..'9', ' ')
            
             @param str string to validate.
             @return true if numeric, fale otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerObjectIdentifier.GetInstance(System.Object)">
             return an OID from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerObjectIdentifier.On(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            Return  true if this oid is an extension of the passed in branch, stem.
            @param stem the arc or branch that is a possible parent.
            @return  true if the branch is on the passed in stem, false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerOctetString.#ctor(System.Byte[])">
            <param name="contents">The octets making up the octet string.</param>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerPrintableString">
            Der PrintableString object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.GetInstance(System.Object)">
             return a printable string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a printable string from a tagged object.
            
             @param taggedObject the tagged object holding the object we want
             @param declaredExplicit true if the object is meant to be explicitly tagged false otherwise.
             @exception ArgumentException if the tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.#ctor(System.String,System.Boolean)">
             Constructor with optional validation.
            
             @param string the base string to wrap.
             @param validate whether or not to check the string.
             @throws ArgumentException if validate is true and the string
             contains characters that should not be in a PrintableString.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.IsPrintableString(System.String)">
             return true if the passed in String can be represented without
             loss as a PrintableString, false otherwise.
            
             @return true if in printable set, false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSequence.#ctor">
            create an empty sequence
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSequence.#ctor(Org.BouncyCastle.Asn1.Asn1Encodable)">
            create a sequence containing one object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSequence.#ctor(Org.BouncyCastle.Asn1.Asn1Encodable,Org.BouncyCastle.Asn1.Asn1Encodable)">
            create a sequence containing two objects
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSequence.#ctor(Org.BouncyCastle.Asn1.Asn1EncodableVector)">
            create a sequence containing a vector of objects.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerSet">
            A Der encoded set object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSet.#ctor">
            create an empty set
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSet.#ctor(Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param obj - a single object that makes up the set.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSet.#ctor(Org.BouncyCastle.Asn1.Asn1EncodableVector)">
            @param v - a vector of objects making up the set.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerT61String">
            Der T61String (also the teletex string) - 8-bit characters
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerT61String.GetInstance(System.Object)">
             return a T61 string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerT61String.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a T61 string from a tagged object.
            
             @param taggedObject the tagged object holding the object we want
             @param declaredExplicit true if the object is meant to be explicitly tagged false otherwise.
             @exception ArgumentException if the tagged object cannot be converted.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerTaggedObject">
            DER TaggedObject - in ASN.1 notation this is any object preceded by
            a [n] where n is some number - these are assumed to follow the construction
            rules (as with sequences).
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerTaggedObject.#ctor(System.Boolean,System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param isExplicit true if an explicitly tagged object.
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerUniversalString">
            UniversalString object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUniversalString.GetInstance(System.Object)">
             return a universal string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUniversalString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a universal string from a tagged object.
            
             @param taggedObject the tagged object holding the object we want
             @param declaredExplicit true if the object is meant to be explicitly tagged false otherwise.
             @exception ArgumentException if the tagged object cannot be converted.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerUtf8String">
            Der UTF8String object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtf8String.GetInstance(System.Object)">
             return an UTF8 string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtf8String.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a UTF8 string from a tagged object.
            
             @param taggedObject the tagged object holding the object we want
             @param declaredExplicit true if the object is meant to be explicitly tagged false otherwise.
             @exception ArgumentException if the tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerVideotexString.GetInstance(System.Object)">
             return a videotex string from the passed in object
            
             @param obj a DERVideotexString or an object that can be converted into one.
             @exception IllegalArgumentException if the object cannot be converted.
             @return a DERVideotexString instance, or null.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerVideotexString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a videotex string from a tagged object.
            
             @param taggedObject the tagged object holding the object we want
             @param declaredExplicit true if the object is meant to be explicitly tagged false otherwise.
             @exception IllegalArgumentException if the tagged object cannot be converted.
             @return a DERVideotexString instance, or null.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerVisibleString">
            VisibleString object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerVisibleString.GetInstance(System.Object)">
             return a visible string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerVisibleString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a visible string from a tagged object.
            
             @param taggedObject the tagged object holding the object we want
             @param declaredExplicit true if the object is meant to be explicitly tagged false otherwise.
             @exception ArgumentException if the tagged object cannot be converted.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DLBitString">
            <summary>A Definite length BIT STRING</summary>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DLBitStringParser">
            <summary>Parser for a DL encoded BIT STRING.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DLSequence.#ctor">
            create an empty sequence
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DLSequence.#ctor(Org.BouncyCastle.Asn1.Asn1Encodable)">
            create a sequence containing one object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DLSequence.#ctor(Org.BouncyCastle.Asn1.Asn1Encodable,Org.BouncyCastle.Asn1.Asn1Encodable)">
            create a sequence containing two objects
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DLSequence.#ctor(Org.BouncyCastle.Asn1.Asn1EncodableVector)">
            create a sequence containing a vector of objects.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DLSet.#ctor">
            create an empty set
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DLSet.#ctor(Org.BouncyCastle.Asn1.Asn1Encodable)">
            create a set containing one object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DLSet.#ctor(Org.BouncyCastle.Asn1.Asn1EncodableVector)">
            create a set containing a vector of objects.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DLTaggedObjectParser">
            Parser for definite-length tagged objects.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.EdEC.EdECObjectIdentifiers">
            Edwards Elliptic Curve Object Identifiers (RFC 8410)
        </member>
        <member name="T:Org.BouncyCastle.Asn1.GM.GMNamedCurves">
            <summary>Elliptic curve registry for GM.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.GM.GMNamedCurves.GetByName(System.String)">
            <summary>Look up the <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.GM.GMNamedCurves.GetByNameLazy(System.String)">
            <summary>Look up an <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given name.</summary>
            <remarks>
            Allows accessing the <see cref="T:Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of the
            full <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.GM.GMNamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given
            <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.GM.GMNamedCurves.GetByOidLazy(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up an <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given
            <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <remarks>
            Allows accessing the <see cref="T:Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of the
            full <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="oid">The <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.GM.GMNamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the name of the curve with the given <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.GM.GMNamedCurves.GetOid(System.String)">
            <summary>Look up the <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> of the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.GM.GMNamedCurves.Names">
            <summary>Enumerate the available curve names in this registry.</summary>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Gnu.GnuObjectIdentifiers.EllipticCurve">
            1.3.6.1.4.1.11591.15 - ellipticCurve 
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IAsn1Choice">
            Marker interface for CHOICE objects - if you implement this in a roll-your-own
            object, any attempt to tag the object implicitly will convert the tag to an
            explicit one as the encoding rules require.
            <p>
            If you use this interface your class should also implement the getInstance
            pattern which takes a tag object and the tagging mode used. 
            </p>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IAsn1String">
            basic interface for Der string objects.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Misc.Cast5CbcParameters.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            cast5CBCParameters ::= Sequence {
                                      iv         OCTET STRING DEFAULT 0,
                                             -- Initialization vector
                                      keyLength  Integer
                                             -- Key length, in bits
                                 }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Misc.IdeaCbcPar.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            IDEA-CBCPar ::= Sequence {
                                 iv    OCTET STRING OPTIONAL -- exactly 8 octets
                             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Misc.NetscapeCertType">
            The NetscapeCertType object.
            <pre>
               NetscapeCertType ::= BIT STRING {
                    SSLClient               (0),
                    SSLServer               (1),
                    S/MIME                  (2),
                    Object Signing          (3),
                    Reserved                (4),
                    SSL CA                  (5),
                    S/MIME CA               (6),
                    Object Signing CA       (7) }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Misc.NetscapeCertType.#ctor(System.Int32)">
             Basic constructor.
            
             @param usage - the bitwise OR of the Key Usage flags giving the
             allowed uses for the key.
             e.g. (X509NetscapeCertType.sslCA | X509NetscapeCertType.smimeCA)
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Nist.NistNamedCurves">
            <summary>Elliptic curve registry for NIST curves.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Nist.NistNamedCurves.GetByName(System.String)">
            <summary>Look up the <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Nist.NistNamedCurves.GetByNameLazy(System.String)">
            <summary>Look up an <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given name.</summary>
            <remarks>
            Allows accessing the <see cref="T:Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of
            the full <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Nist.NistNamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given
            <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Nist.NistNamedCurves.GetByOidLazy(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up an <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given
            <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <remarks>
            Allows accessing the <see cref="T:Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of
            the full <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="oid">The <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Nist.NistNamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the name of the curve with the given <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Nist.NistNamedCurves.GetOid(System.String)">
            <summary>Look up the <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> of the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Nist.NistNamedCurves.Names">
            <summary>Enumerate the available curve names in this registry.</summary>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Nist.NistObjectIdentifiers.IdDsaWithSha3_224">
            2.16.840.1.101.3.4.3.5 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Nist.NistObjectIdentifiers.IdDsaWithSha3_256">
            2.16.840.1.101.3.4.3.6 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Nist.NistObjectIdentifiers.IdDsaWithSha3_384">
            2.16.840.1.101.3.4.3.7 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Nist.NistObjectIdentifiers.IdDsaWithSha3_512">
            2.16.840.1.101.3.4.3.8 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Nist.NistObjectIdentifiers.IdEcdsaWithSha3_224">
            2.16.840.1.101.3.4.3.9 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Nist.NistObjectIdentifiers.IdEcdsaWithSha3_256">
            2.16.840.1.101.3.4.3.10 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Nist.NistObjectIdentifiers.IdEcdsaWithSha3_384">
            2.16.840.1.101.3.4.3.11 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Nist.NistObjectIdentifiers.IdEcdsaWithSha3_512">
            2.16.840.1.101.3.4.3.12 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Nist.NistObjectIdentifiers.IdRsassaPkcs1V15WithSha3_224">
            2.16.840.1.101.3.4.3.9 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Nist.NistObjectIdentifiers.IdRsassaPkcs1V15WithSha3_256">
            2.16.840.1.101.3.4.3.10 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Nist.NistObjectIdentifiers.IdRsassaPkcs1V15WithSha3_384">
            2.16.840.1.101.3.4.3.11 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Nist.NistObjectIdentifiers.IdRsassaPkcs1V15WithSha3_512">
            2.16.840.1.101.3.4.3.12 
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Ntt.NttObjectIdentifiers">
            <summary>From RFC 3657</summary>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.OidTokenizer">
            class for breaking up an Oid into it's component tokens, ala
            java.util.StringTokenizer. We need this class as some of the
            lightweight Java environment don't support classes like
            StringTokenizer.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.EncryptedPrivateKeyInfo.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             EncryptedPrivateKeyInfo ::= Sequence {
                  encryptionAlgorithm AlgorithmIdentifier {{KeyEncryptionAlgorithms}},
                  encryptedData EncryptedData
             }
            
             EncryptedData ::= OCTET STRING
            
             KeyEncryptionAlgorithms ALGORITHM-IDENTIFIER ::= {
                      ... -- For local profiles
             }
             </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Pkcs.PkcsObjectIdentifiers.Sha512_224WithRSAEncryption">
            PKCS#1: 1.2.840.113549.1.1.15 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Pkcs.PkcsObjectIdentifiers.Sha512_256WithRSAEncryption">
            PKCS#1: 1.2.840.113549.1.1.16 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Pkcs.PkcsObjectIdentifiers.IdAlgAeadChaCha20Poly1305">
             <pre>
             id-alg-AEADChaCha20Poly1305 OBJECT IDENTIFIER ::=
             { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1)
                pkcs9(9) smime(16) alg(3) 18 }
            
             AEADChaCha20Poly1305Nonce ::= OCTET STRING (SIZE(12))
             </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Pkcs.PkcsObjectIdentifiers.IdAlgHssLmsHashsig">
            id-alg-hss-lms-hashsig OBJECT IDENTIFIER ::= { iso(1)
                member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs9(9)
               smime(16) alg(3) 17 }
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Pkcs.PkcsObjectIdentifiers.IdAADecryptKeyID">
            PKCS#9: 1.2.840.113549.1.9.16.2.37 - <a href="https://tools.ietf.org/html/rfc4108#section-2.2.5">RFC 4108</a> 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Pkcs.PkcsObjectIdentifiers.IdAAImplCryptoAlgs">
            PKCS#9: 1.2.840.113549.1.9.16.2.38 - <a href="https://tools.ietf.org/html/rfc4108#section-2.2.6">RFC 4108</a> 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Pkcs.PkcsObjectIdentifiers.IdAAAsymmDecryptKeyID">
            PKCS#9: 1.2.840.113549.1.9.16.2.54 <a href="https://tools.ietf.org/html/rfc7030">RFC7030</a>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Pkcs.PkcsObjectIdentifiers.IdAAImplCompressAlgs">
            PKCS#9: 1.2.840.113549.1.9.16.2.43   <a href="https://tools.ietf.org/html/rfc7030">RFC7030</a>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Pkcs.PkcsObjectIdentifiers.IdAACommunityIdentifiers">
            PKCS#9: 1.2.840.113549.1.9.16.2.40   <a href="https://tools.ietf.org/html/rfc7030">RFC7030</a>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Pkcs.PrivateKeyInfo">
              RFC 5958
            
              <pre>
              [IMPLICIT TAGS]
            
              OneAsymmetricKey ::= SEQUENCE {
                  version                   Version,
                  privateKeyAlgorithm       PrivateKeyAlgorithmIdentifier,
                  privateKey                PrivateKey,
                  attributes            [0] Attributes OPTIONAL,
                  ...,
                  [[2: publicKey        [1] PublicKey OPTIONAL ]],
                  ...
              }
            
              PrivateKeyInfo ::= OneAsymmetricKey
            
              Version ::= INTEGER { v1(0), v2(1) } (v1, ..., v2)
            
              PrivateKeyAlgorithmIdentifier ::= AlgorithmIdentifier
                                                 { PUBLIC-KEY,
                                                   { PrivateKeyAlgorithms } }
            
              PrivateKey ::= OCTET STRING
                                 -- Content varies based on type of key.  The
                                 -- algorithm identifier dictates the format of
                                 -- the key.
            
              PublicKey ::= BIT STRING
                                 -- Content varies based on type of key.  The
                                 -- algorithm identifier dictates the format of
                                 -- the key.
            
              Attributes ::= SET OF Attribute { { OneAsymmetricKeyAttributes } }
              </pre>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Pkcs.PrivateKeyInfo.HasPublicKey">
            <summary>Return true if a public key is present, false otherwise.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.PrivateKeyInfo.ParsePublicKey">
            <summary>For when the public key is an ASN.1 encoding.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Pkcs.PrivateKeyInfo.PublicKeyData">
            <summary>Return the public key as a raw bit string.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.RsaesOaepParameters.#ctor">
            The default version
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.RsaesOaepParameters.ToAsn1Object">
             <pre>
              RSAES-OAEP-params ::= SEQUENCE {
                 hashAlgorithm      [0] OAEP-PSSDigestAlgorithms     DEFAULT sha1,
                 maskGenAlgorithm   [1] PKCS1MGFAlgorithms  DEFAULT mgf1SHA1,
                 pSourceAlgorithm   [2] PKCS1PSourceAlgorithms  DEFAULT pSpecifiedEmpty
               }
            
               OAEP-PSSDigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
                 { OID id-sha1 PARAMETERS NULL   }|
                 { OID id-sha256 PARAMETERS NULL }|
                 { OID id-sha384 PARAMETERS NULL }|
                 { OID id-sha512 PARAMETERS NULL },
                 ...  -- Allows for future expansion --
               }
               PKCS1MGFAlgorithms    ALGORITHM-IDENTIFIER ::= {
                 { OID id-mgf1 PARAMETERS OAEP-PSSDigestAlgorithms },
                ...  -- Allows for future expansion --
               }
               PKCS1PSourceAlgorithms    ALGORITHM-IDENTIFIER ::= {
                 { OID id-pSpecified PARAMETERS OCTET STRING },
                 ...  -- Allows for future expansion --
              }
             </pre>
             @return the asn1 primitive representing the parameters.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.RsaPrivateKeyStructure.ToAsn1Object">
             This outputs the key in Pkcs1v2 format.
             <pre>
                  RsaPrivateKey ::= Sequence {
                                      version Version,
                                      modulus Integer, -- n
                                      publicExponent Integer, -- e
                                      privateExponent Integer, -- d
                                      prime1 Integer, -- p
                                      prime2 Integer, -- q
                                      exponent1 Integer, -- d mod (p-1)
                                      exponent2 Integer, -- d mod (q-1)
                                      coefficient Integer -- (inverse of q) mod p
                                  }
            
                  Version ::= Integer
             </pre>
             <p>This routine is written to output Pkcs1 version 0, private keys.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.RsassaPssParameters.#ctor">
            The default version
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.RsassaPssParameters.ToAsn1Object">
             <pre>
             RSASSA-PSS-params ::= SEQUENCE {
               hashAlgorithm      [0] OAEP-PSSDigestAlgorithms  DEFAULT sha1,
                maskGenAlgorithm   [1] PKCS1MGFAlgorithms  DEFAULT mgf1SHA1,
                saltLength         [2] INTEGER  DEFAULT 20,
                trailerField       [3] TrailerField  DEFAULT trailerFieldBC
              }
            
             OAEP-PSSDigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
                { OID id-sha1 PARAMETERS NULL   }|
                { OID id-sha256 PARAMETERS NULL }|
                { OID id-sha384 PARAMETERS NULL }|
                { OID id-sha512 PARAMETERS NULL },
                ...  -- Allows for future expansion --
             }
            
             PKCS1MGFAlgorithms    ALGORITHM-IDENTIFIER ::= {
               { OID id-mgf1 PARAMETERS OAEP-PSSDigestAlgorithms },
                ...  -- Allows for future expansion --
             }
            
             TrailerField ::= INTEGER { trailerFieldBC(1) }
             </pre>
             @return the asn1 primitive representing the parameters.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Sec.ECPrivateKeyStructure">
            the elliptic curve private key object from SEC 1
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Sec.ECPrivateKeyStructure.ToAsn1Object">
            ECPrivateKey ::= SEQUENCE {
                version INTEGER { ecPrivkeyVer1(1) } (ecPrivkeyVer1),
                privateKey OCTET STRING,
                parameters [0] Parameters OPTIONAL,
                publicKey [1] BIT STRING OPTIONAL }
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Sec.SecNamedCurves">
            <summary>Elliptic curve registry for the SEC standard.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Sec.SecNamedCurves.GetByName(System.String)">
            <summary>Look up the <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Sec.SecNamedCurves.GetByNameLazy(System.String)">
            <summary>Look up an <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given name.</summary>
            <remarks>
            Allows accessing the <see cref="T:Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of the
            full <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Sec.SecNamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given
            <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Sec.SecNamedCurves.GetByOidLazy(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up an <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given
            <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <remarks>
            Allows accessing the <see cref="T:Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of the
            full <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="oid">The <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Sec.SecNamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the name of the curve with the given <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Sec.SecNamedCurves.GetOid(System.String)">
            <summary>Look up the <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> of the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Sec.SecNamedCurves.Names">
            <summary>Enumerate the available curve names in this registry.</summary>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Sec.SecObjectIdentifiers.EllipticCurve">
            EllipticCurve OBJECT IDENTIFIER ::= {
                  iso(1) identified-organization(3) certicom(132) curve(0)
            }
        </member>
        <member name="T:Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves">
            <summary>Elliptic curve registry for curves defined in "ECC Brainpool Standard Curves and Curve Generation"
            http://www.ecc-brainpool.org/download/draft_pkix_additional_ecc_dp.txt .</summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves.GetByName(System.String)">
            <summary>Look up the <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves.GetByNameLazy(System.String)">
            <summary>Look up an <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given name.</summary>
            <remarks>
            Allows accessing the <see cref="T:Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of the
            full <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given
            <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves.GetByOidLazy(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up an <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given
            <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <remarks>
            Allows accessing the <see cref="T:Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of the
            full <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="oid">The <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the name of the curve with the given <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves.GetOid(System.String)">
            <summary>Look up the <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> of the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves.Names">
            <summary>Enumerate the available curve names in this registry.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers">
            Ukrainian object identifiers
            <p/>
            {iso(1) member-body(2) Ukraine(804) root(2) security(1) cryptography(1) pki(1)}
            <p/>
            { ...  pki-alg(1) pki-alg-sym(3) Dstu4145WithGost34311(1) PB(1)}
            <p/>
            DSTU4145 in polynomial basis has 2 oids, one for little-endian representation and one for big-endian
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.UaOid">
            Base OID: 1.2.804.2.1.1.1 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu4145le">
            DSTU4145 Little Endian presentation.  OID: 1.2.804.2.1.1.1.1.3.1.1 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu4145be">
            DSTU4145 Big Endian presentation.  OID: 1.2.804.2.1.1.1.1.3.1.1.1 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7564digest_256">
            DSTU7564 256-bit digest presentation. 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7564digest_384">
            DSTU7564 384-bit digest presentation. 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7564digest_512">
            DSTU7564 512-bit digest presentation. 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7564mac_256">
            DSTU7564 256-bit mac presentation. 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7564mac_384">
            DSTU7564 384-bit mac presentation. 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7564mac_512">
            DSTU7564 512-bit mac presentation. 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624ecb_128">
            DSTU7624 in ECB mode with 128 bit block/key presentation 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624ecb_256">
            DSTU7624 in ECB mode with 256 bit block/key presentation 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624ecb_512">
            DSTU7624 in ECB mode with 512 bit block/key presentation 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624ctr_128">
            DSTU7624 in CTR mode with 128 bit block/key presentation 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624ctr_256">
            DSTU7624 in CTR mode with 256 bit block/key presentation 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624ctr_512">
            DSTU7624 in CTR mode with 512 bit block/key presentation 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624cfb_128">
            DSTU7624 in CFB mode with 128 bit block/key presentation 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624cfb_256">
            DSTU7624 in CFB mode with 256 bit block/key presentation 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624cfb_512">
            DSTU7624 in CFB mode with 512 bit block/key presentation 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624cmac_128">
            DSTU7624 in MAC mode with 128 bit block/key presentation 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624cmac_256">
            DSTU7624 in MAC mode with 256 bit block/key presentation 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624cmac_512">
            DSTU7624 in MAC mode with 512 bit block/key presentation 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624cbc_128">
            DSTU7624 in CBC mode with 128 bit block/key presentation 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624cbc_256">
            DSTU7624 in CBC mode with 256 bit block/key presentation 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624cbc_512">
            DSTU7624 in CBC mode with 512 bit block/key presentation 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624ofb_128">
            DSTU7624 in OFB mode with 128 bit block/key presentation 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624ofb_256">
            DSTU7624 in OFB mode with 256 bit block/key presentation 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624ofb_512">
            DSTU7624 in OFB mode with 512 bit block/key presentation 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624gmac_128">
            DSTU7624 in GMAC (GCM witout encryption) mode with 128 bit block/key presentation 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624gmac_256">
            DSTU7624 in GMAC (GCM witout encryption) mode with 256 bit block/key presentation 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624gmac_512">
            DSTU7624 in GMAC (GCM witout encryption) mode with 512 bit block/key presentation 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624ccm_128">
            DSTU7624 in CCM mode with 128 bit block/key presentation 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624ccm_256">
            DSTU7624 in CCM mode with 256 bit block/key presentation 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624ccm_512">
            DSTU7624 in CCM mode with 512 bit block/key presentation 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624xts_128">
            DSTU7624 in XTS mode with 128 bit block/key presentation 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624xts_256">
            DSTU7624 in XTS mode with 256 bit block/key presentation 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624xts_512">
            DSTU7624 in XTS mode with 512 bit block/key presentation 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624kw_128">
            DSTU7624 in key wrap (KW) mode with 128 bit block/key presentation 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624kw_256">
            DSTU7624 in key wrap (KW) mode with 256 bit block/key presentation 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.UA.UAObjectIdentifiers.dstu7624kw_512">
            DSTU7624 in key wrap (KW) mode with 512 bit block/key presentation 
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Utilities.Asn1Dump.AsString(System.String,System.Boolean,Org.BouncyCastle.Asn1.Asn1Object,System.Text.StringBuilder)">
             dump a Der object as a formatted string with indentation
            
             @param obj the Asn1Object to be dumped out.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Utilities.Asn1Dump.Dump(System.IO.Stream,System.IO.TextWriter)">
            <summary>Parse ASN.1 objects from input <see cref="T:System.IO.Stream"/>, and write them to the output.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Utilities.Asn1Dump.DumpAsString(Org.BouncyCastle.Asn1.Asn1Encodable)">
             dump out a DER object as a formatted string, in non-verbose mode
            
             @param obj the Asn1Encodable to be dumped out.
             @return  the resulting string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Utilities.Asn1Dump.DumpAsString(Org.BouncyCastle.Asn1.Asn1Encodable,System.Boolean)">
             Dump out the object as a string
            
             @param obj the Asn1Encodable to be dumped out.
             @param verbose  if true, dump out the contents of octet and bit strings.
             @return  the resulting string.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier.Algorithm">
            <summary>
            Return the OID in the Algorithm entry of this identifier.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier.Parameters">
            <summary>
            Return the parameters structure in the Parameters entry of this identifier.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
                 AlgorithmIdentifier ::= Sequence {
                                       algorithm OBJECT IDENTIFIER,
                                       parameters ANY DEFINED BY algorithm OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttCertIssuer.#ctor(Org.BouncyCastle.Asn1.X509.GeneralNames)">
            <summary>
            Don't use this one if you are trying to be RFC 3281 compliant.
            Use it for v1 attribute certificates only.
            </summary>
            <param name="names">Our GeneralNames structure</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttCertIssuer.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             AttCertIssuer ::= CHOICE {
                  v1Form   GeneralNames,  -- MUST NOT be used in this
                                          -- profile
                  v2Form   [0] V2Form     -- v2 only
             }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttCertValidityPeriod.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             AttCertValidityPeriod  ::= Sequence {
                  notBeforeTime  GeneralizedTime,
                  notAfterTime   GeneralizedTime
             }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttributeX509.GetInstance(System.Object)">
             return an Attr object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttributeX509.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Attr ::= Sequence {
                attrType OBJECT IDENTIFIER,
                attrValues Set OF AttributeValue
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttributeCertificate.GetInstance(System.Object)">
            @param obj
            @return
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttributeCertificate.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             AttributeCertificate ::= Sequence {
                  acinfo               AttributeCertificateInfo,
                  signatureAlgorithm   AlgorithmIdentifier,
                  signatureValue       BIT STRING
             }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttributeCertificateInfo.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
              AttributeCertificateInfo ::= Sequence {
                   version              AttCertVersion -- version is v2,
                   holder               Holder,
                   issuer               AttCertIssuer,
                   signature            AlgorithmIdentifier,
                   serialNumber         CertificateSerialNumber,
                   attrCertValidityPeriod   AttCertValidityPeriod,
                   attributes           Sequence OF Attr,
                   issuerUniqueID       UniqueIdentifier OPTIONAL,
                   extensions           Extensions OPTIONAL
              }
            
              AttCertVersion ::= Integer { v2(1) }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.BasicConstraints.#ctor(System.Int32)">
             create a cA=true object for the given path length constraint.
            
             @param pathLenConstraint
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.BasicConstraints.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            BasicConstraints := Sequence {
               cA                  Boolean DEFAULT FALSE,
               pathLenConstraint   Integer (0..MAX) OPTIONAL
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.CertificateList">
             PKIX RFC-2459
            
             The X.509 v2 CRL syntax is as follows.  For signature calculation,
             the data that is to be signed is ASN.1 Der encoded.
            
             <pre>
             CertificateList  ::=  Sequence  {
                  tbsCertList          TbsCertList,
                  signatureAlgorithm   AlgorithmIdentifier,
                  signatureValue       BIT STRING  }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.CrlDistPoint.GetDistributionPoints">
             Return the distribution points making up the sequence.
            
             @return DistributionPoint[]
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.CrlDistPoint.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            CrlDistPoint ::= Sequence SIZE {1..MAX} OF DistributionPoint
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.CrlNumber">
            The CRLNumber object.
            <pre>
            CRLNumber::= Integer(0..MAX)
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.CrlReason">
            The CRLReason enumeration.
            <pre>
            CRLReason ::= Enumerated {
             unspecified             (0),
             keyCompromise           (1),
             cACompromise            (2),
             affiliationChanged      (3),
             superseded              (4),
             cessationOfOperation    (5),
             certificateHold         (6),
             removeFromCRL           (8),
             privilegeWithdrawn      (9),
             aACompromise           (10)
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.DigestInfo">
            The DigestInfo object.
            <pre>
            DigestInfo::=Sequence{
                     digestAlgorithm  AlgorithmIdentifier,
                     digest OCTET STRING }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.DistributionPoint">
            The DistributionPoint object.
            <pre>
            DistributionPoint ::= Sequence {
                 distributionPoint [0] DistributionPointName OPTIONAL,
                 reasons           [1] ReasonFlags OPTIONAL,
                 cRLIssuer         [2] GeneralNames OPTIONAL
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.DistributionPointName">
            The DistributionPointName object.
            <pre>
            DistributionPointName ::= CHOICE {
                fullName                 [0] GeneralNames,
                nameRelativeToCRLIssuer  [1] RDN
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.GeneralName">
             The GeneralName object.
             <pre>
             GeneralName ::= CHOICE {
                  otherName                       [0]     OtherName,
                  rfc822Name                      [1]     IA5String,
                  dNSName                         [2]     IA5String,
                  x400Address                     [3]     ORAddress,
                  directoryName                   [4]     Name,
                  ediPartyName                    [5]     EDIPartyName,
                  uniformResourceIdentifier       [6]     IA5String,
                  iPAddress                       [7]     OCTET STRING,
                  registeredID                    [8]     OBJECT IDENTIFIER}
            
             OtherName ::= Sequence {
                  type-id    OBJECT IDENTIFIER,
                  value      [0] EXPLICIT ANY DEFINED BY type-id }
            
             EDIPartyName ::= Sequence {
                  nameAssigner            [0]     DirectoryString OPTIONAL,
                  partyName               [1]     DirectoryString }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.GeneralName.#ctor(Org.BouncyCastle.Asn1.Asn1Object,System.Int32)">
             When the subjectAltName extension contains an Internet mail address,
             the address MUST be included as an rfc822Name. The format of an
             rfc822Name is an "addr-spec" as defined in RFC 822 [RFC 822].
            
             When the subjectAltName extension contains a domain name service
             label, the domain name MUST be stored in the dNSName (an IA5String).
             The name MUST be in the "preferred name syntax," as specified by RFC
             1034 [RFC 1034].
            
             When the subjectAltName extension contains a URI, the name MUST be
             stored in the uniformResourceIdentifier (an IA5String). The name MUST
             be a non-relative URL, and MUST follow the URL syntax and encoding
             rules specified in [RFC 1738].  The name must include both a scheme
             (e.g., "http" or "ftp") and a scheme-specific-part.  The scheme-
             specific-part must include a fully qualified domain name or IP
             address as the host.
            
             When the subjectAltName extension contains a iPAddress, the address
             MUST be stored in the octet string in "network byte order," as
             specified in RFC 791 [RFC 791]. The least significant bit (LSB) of
             each octet is the LSB of the corresponding byte in the network
             address. For IP Version 4, as specified in RFC 791, the octet string
             MUST contain exactly four octets.  For IP Version 6, as specified in
             RFC 1883, the octet string MUST contain exactly sixteen octets [RFC
             1883].
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.GeneralName.#ctor(System.Int32,System.String)">
             Create a GeneralName for the given tag from the passed in string.
             <p>
             This constructor can handle:
             <ul>
             <li>rfc822Name</li>
             <li>iPAddress</li>
             <li>directoryName</li>
             <li>dNSName</li>
             <li>uniformResourceIdentifier</li>
             <li>registeredID</li>
             </ul>
             For x400Address, otherName and ediPartyName there is no common string
             format defined.
             </p><p>
             Note: A directory name can be encoded in different ways into a byte
             representation. Be aware of this if the byte representation is used for
             comparing results.
             </p>
            
             @param tag tag number
             @param name string representation of name
             @throws ArgumentException if the string encoding is not correct or
                         not supported.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.GeneralNames.#ctor(Org.BouncyCastle.Asn1.X509.GeneralName)">
            <summary>Construct a GeneralNames object containing one GeneralName.</summary>
            <param name="name">The name to be contained.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.GeneralNames.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            GeneralNames ::= Sequence SIZE {1..MAX} OF GeneralName
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.Holder">
            The Holder object.
            <p>
            For an v2 attribute certificate this is:
            
            <pre>
                       Holder ::= SEQUENCE {
                             baseCertificateID   [0] IssuerSerial OPTIONAL,
                                      -- the issuer and serial number of
                                      -- the holder's Public Key Certificate
                             entityName          [1] GeneralNames OPTIONAL,
                                      -- the name of the claimant or role
                             objectDigestInfo    [2] ObjectDigestInfo OPTIONAL
                                      -- used to directly authenticate the holder,
                                      -- for example, an executable
                       }
            </pre>
            </p>
            <p>
            For an v1 attribute certificate this is:
            
            <pre>
                    subject CHOICE {
                     baseCertificateID [0] EXPLICIT IssuerSerial,
                     -- associated with a Public Key Certificate
                     subjectName [1] EXPLICIT GeneralNames },
                     -- associated with a name
            </pre>
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Holder.#ctor(Org.BouncyCastle.Asn1.Asn1TaggedObject)">
            Constructor for a holder for an v1 attribute certificate.
            
            @param tagObj The ASN.1 tagged holder object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Holder.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            Constructor for a holder for an v2 attribute certificate. *
            
            @param seq The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Holder.#ctor(Org.BouncyCastle.Asn1.X509.IssuerSerial,System.Int32)">
            Constructs a holder from a IssuerSerial.
            @param baseCertificateID The IssuerSerial.
            @param version The version of the attribute certificate. 
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.Holder.Version">
            Returns 1 for v2 attribute certificates or 0 for v1 attribute
            certificates. 
            @return The version of the attribute certificate.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Holder.#ctor(Org.BouncyCastle.Asn1.X509.GeneralNames)">
            Constructs a holder with an entityName for v2 attribute certificates or
            with a subjectName for v1 attribute certificates.
            
            @param entityName The entity or subject name.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Holder.#ctor(Org.BouncyCastle.Asn1.X509.GeneralNames,System.Int32)">
            Constructs a holder with an entityName for v2 attribute certificates or
            with a subjectName for v1 attribute certificates.
            
            @param entityName The entity or subject name.
            @param version The version of the attribute certificate. 
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Holder.#ctor(Org.BouncyCastle.Asn1.X509.ObjectDigestInfo)">
            Constructs a holder from an object digest info.
            
            @param objectDigestInfo The object digest info object.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.Holder.EntityName">
            Returns the entityName for an v2 attribute certificate or the subjectName
            for an v1 attribute certificate.
            
            @return The entityname or subjectname.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Holder.ToAsn1Object">
            The Holder object.
            <pre>
             Holder ::= Sequence {
                   baseCertificateID   [0] IssuerSerial OPTIONAL,
                            -- the issuer and serial number of
                            -- the holder's Public Key Certificate
                   entityName          [1] GeneralNames OPTIONAL,
                            -- the name of the claimant or role
                   objectDigestInfo    [2] ObjectDigestInfo OPTIONAL
                            -- used to directly authenticate the holder,
                            -- for example, an executable
             }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.IssuerSerial.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             IssuerSerial  ::=  Sequence {
                  issuer         GeneralNames,
                  serial         CertificateSerialNumber,
                  issuerUid      UniqueIdentifier OPTIONAL
             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint">
            <pre>
            IssuingDistributionPoint ::= SEQUENCE { 
              distributionPoint          [0] DistributionPointName OPTIONAL, 
              onlyContainsUserCerts      [1] BOOLEAN DEFAULT FALSE, 
              onlyContainsCACerts        [2] BOOLEAN DEFAULT FALSE, 
              onlySomeReasons            [3] ReasonFlags OPTIONAL, 
              indirectCRL                [4] BOOLEAN DEFAULT FALSE,
              onlyContainsAttributeCerts [5] BOOLEAN DEFAULT FALSE }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint.#ctor(Org.BouncyCastle.Asn1.X509.DistributionPointName,System.Boolean,System.Boolean,Org.BouncyCastle.Asn1.X509.ReasonFlags,System.Boolean,System.Boolean)">
            Constructor from given details.
            
            @param distributionPoint
                       May contain an URI as pointer to most current CRL.
            @param onlyContainsUserCerts Covers revocation information for end certificates.
            @param onlyContainsCACerts Covers revocation information for CA certificates.
            
            @param onlySomeReasons
                       Which revocation reasons does this point cover.
            @param indirectCRL
                       If <code>true</code> then the CRL contains revocation
                       information about certificates ssued by other CAs.
            @param onlyContainsAttributeCerts Covers revocation information for attribute certificates.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            Constructor from Asn1Sequence
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint.DistributionPoint">
            @return Returns the distributionPoint.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint.OnlySomeReasons">
            @return Returns the onlySomeReasons.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.KeyUsage">
             The KeyUsage object.
             <pre>
                id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }
            
                KeyUsage ::= BIT STRING {
                     digitalSignature        (0),
                     nonRepudiation          (1),
                     keyEncipherment         (2),
                     dataEncipherment        (3),
                     keyAgreement            (4),
                     keyCertSign             (5),
                     cRLSign                 (6),
                     encipherOnly            (7),
                     decipherOnly            (8) }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.KeyUsage.#ctor(System.Int32)">
             Basic constructor.
            
             @param usage - the bitwise OR of the Key Usage flags giving the
             allowed uses for the key.
             e.g. (KeyUsage.keyEncipherment | KeyUsage.dataEncipherment)
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.ObjectDigestInfo">
            ObjectDigestInfo ASN.1 structure used in v2 attribute certificates.
            
            <pre>
             
               ObjectDigestInfo ::= SEQUENCE {
                    digestedObjectType  ENUMERATED {
                            publicKey            (0),
                            publicKeyCert        (1),
                            otherObjectTypes     (2) },
                                    -- otherObjectTypes MUST NOT
                                    -- be used in this profile
                    otherObjectTypeID   OBJECT IDENTIFIER OPTIONAL,
                    digestAlgorithm     AlgorithmIdentifier,
                    objectDigest        BIT STRING
               }
              
            </pre>
            
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.ObjectDigestInfo.PublicKey">
            The public key is hashed.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.ObjectDigestInfo.PublicKeyCert">
            The public key certificate is hashed.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.ObjectDigestInfo.OtherObjectDigest">
            An other object is hashed.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.ObjectDigestInfo.#ctor(System.Int32,System.String,Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier,System.Byte[])">
            Constructor from given details.
            <p>
            If <code>digestedObjectType</code> is not {@link #publicKeyCert} or
            {@link #publicKey} <code>otherObjectTypeID</code> must be given,
            otherwise it is ignored.</p>
            
            @param digestedObjectType The digest object type.
            @param otherObjectTypeID The object type ID for
                       <code>otherObjectDigest</code>.
            @param digestAlgorithm The algorithm identifier for the hash.
            @param objectDigest The hash value.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.ObjectDigestInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            
            <pre>
             
               ObjectDigestInfo ::= SEQUENCE {
                    digestedObjectType  ENUMERATED {
                            publicKey            (0),
                            publicKeyCert        (1),
                            otherObjectTypes     (2) },
                                    -- otherObjectTypes MUST NOT
                                    -- be used in this profile
                    otherObjectTypeID   OBJECT IDENTIFIER OPTIONAL,
                    digestAlgorithm     AlgorithmIdentifier,
                    objectDigest        BIT STRING
               }
              
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.PrivateKeyUsagePeriod">
            <remarks>
            <pre>
            PrivateKeyUsagePeriod ::= SEQUENCE
            {
            notBefore       [0]     GeneralizedTime OPTIONAL,
            notAfter        [1]     GeneralizedTime OPTIONAL }
            </pre>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.ReasonFlags">
            The ReasonFlags object.
            <pre>
            ReasonFlags ::= BIT STRING {
               unused(0),
               keyCompromise(1),
               cACompromise(2),
               affiliationChanged(3),
               superseded(4),
               cessationOfOperation(5),
               certficateHold(6)
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.ReasonFlags.#ctor(System.Int32)">
            @param reasons - the bitwise OR of the Key Reason flags giving the
            allowed uses for the key.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.RsaPublicKeyStructure.ToAsn1Object">
            This outputs the key in Pkcs1v2 format.
            <pre>
                 RSAPublicKey ::= Sequence {
                                     modulus Integer, -- n
                                     publicExponent Integer, -- e
                                 }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.SubjectKeyIdentifier">
            The SubjectKeyIdentifier object.
            <pre>
            SubjectKeyIdentifier::= OCTET STRING
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectKeyIdentifier.#ctor(Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
             Calculates the keyIdentifier using a SHA1 hash over the BIT STRING
             from SubjectPublicKeyInfo as defined in RFC3280.
            
             @param spki the subject public key info.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectKeyIdentifier.CreateSha1KeyIdentifier(Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
            Return a RFC 3280 type 1 key identifier. As in:
            <pre>
            (1) The keyIdentifier is composed of the 160-bit SHA-1 hash of the
            value of the BIT STRING subjectPublicKey (excluding the tag,
            length, and number of unused bits).
            </pre>
            @param keyInfo the key info object containing the subjectPublicKey field.
            @return the key identifier.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectKeyIdentifier.CreateTruncatedSha1KeyIdentifier(Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
            Return a RFC 3280 type 2 key identifier. As in:
            <pre>
            (2) The keyIdentifier is composed of a four bit type field with
            the value 0100 followed by the least significant 60 bits of the
            SHA-1 hash of the value of the BIT STRING subjectPublicKey.
            </pre>
            @param keyInfo the key info object containing the subjectPublicKey field.
            @return the key identifier.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo">
            The object that contains the public key stored in a certficate.
            <p>
            The GetEncoded() method in the public keys in the JCE produces a DER
            encoded one of these.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo.ParsePublicKey">
             for when the public key is an encoded object - if the bitstring
             can't be decoded this routine raises an IOException.
            
             @exception IOException - if the bit string doesn't represent a Der
             encoded object.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo.PublicKeyData">
            for when the public key is raw bits...
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            SubjectPublicKeyInfo ::= Sequence {
                                     algorithm AlgorithmIdentifier,
                                     publicKey BIT STRING }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.TbsCertificateStructure">
            The TbsCertificate object.
            <pre>
            TbsCertificate ::= Sequence {
                 version          [ 0 ]  Version DEFAULT v1(0),
                 serialNumber            CertificateSerialNumber,
                 signature               AlgorithmIdentifier,
                 issuer                  Name,
                 validity                Validity,
                 subject                 Name,
                 subjectPublicKeyInfo    SubjectPublicKeyInfo,
                 issuerUniqueID    [ 1 ] IMPLICIT UniqueIdentifier OPTIONAL,
                 subjectUniqueID   [ 2 ] IMPLICIT UniqueIdentifier OPTIONAL,
                 extensions        [ 3 ] Extensions OPTIONAL
                 }
            </pre>
            <p>
            Note: issuerUniqueID and subjectUniqueID are both deprecated by the IETF. This class
            will parse them, but you really shouldn't be creating new ones.</p>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.TbsCertificateList">
            PKIX RFC-2459 - TbsCertList object.
            <pre>
            TbsCertList  ::=  Sequence  {
                 version                 Version OPTIONAL,
                                              -- if present, shall be v2
                 signature               AlgorithmIdentifier,
                 issuer                  Name,
                 thisUpdate              Time,
                 nextUpdate              Time OPTIONAL,
                 revokedCertificates     Sequence OF Sequence  {
                      userCertificate         CertificateSerialNumber,
                      revocationDate          Time,
                      crlEntryExtensions      Extensions OPTIONAL
                                                    -- if present, shall be v2
                                           }  OPTIONAL,
                 crlExtensions           [0]  EXPLICIT Extensions OPTIONAL
                                                    -- if present, shall be v2
                                           }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Time.#ctor(System.DateTime)">
            creates a time object from a given date - if the date is between 1950
            and 2049 a UTCTime object is Generated, otherwise a GeneralizedTime
            is used.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Time.ToDateTime">
            <summary>
            Return our time as DateTime.
            </summary>
            <returns>A date time.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Time.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Time ::= CHOICE {
                        utcTime        UTCTime,
                        generalTime    GeneralizedTime }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.V2Form.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             V2Form ::= Sequence {
                  issuerName            GeneralNames  OPTIONAL,
                  baseCertificateID     [0] IssuerSerial  OPTIONAL,
                  objectDigestInfo      [1] ObjectDigestInfo  OPTIONAL
                    -- issuerName MUST be present in this profile
                    -- baseCertificateID and objectDigestInfo MUST NOT
                    -- be present in this profile
             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509CertificateStructure">
            an X509Certificate structure.
            <pre>
             Certificate ::= Sequence {
                 tbsCertificate          TbsCertificate,
                 signatureAlgorithm      AlgorithmIdentifier,
                 signature               BIT STRING
             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509DefaultEntryConverter">
            The default converter for X509 DN entries when going from their
            string value to ASN.1 strings.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509DefaultEntryConverter.GetConvertedValue(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.String)">
             Apply default conversion for the given value depending on the oid
             and the character range of the value.
            
             @param oid the object identifier for the DN entry
             @param value the value associated with it
             @return the ASN.1 equivalent for the string value.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509Extension">
            an object for the elements in the X.509 V3 extension block.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extension.ConvertValueToObject(Org.BouncyCastle.Asn1.X509.X509Extension)">
            <sumary>Convert the value of the passed in extension to an object.</sumary>
            <param name="ext">The extension to parse.</param>
            <returns>The object the value string contains.</returns>
            <exception cref="T:System.ArgumentException">If conversion is not possible.</exception>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.SubjectDirectoryAttributes">
            Subject Directory Attributes
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.SubjectKeyIdentifier">
            Subject Key Identifier
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.KeyUsage">
            Key Usage
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.PrivateKeyUsagePeriod">
            Private Key Usage Period
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.SubjectAlternativeName">
            Subject Alternative Name
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.IssuerAlternativeName">
            Issuer Alternative Name
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.BasicConstraints">
            Basic Constraints
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.CrlNumber">
            CRL Number
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.ReasonCode">
            Reason code
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.InstructionCode">
            Hold Instruction Code
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.InvalidityDate">
            Invalidity Date
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.DeltaCrlIndicator">
            Delta CRL indicator
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.IssuingDistributionPoint">
            Issuing Distribution Point
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.CertificateIssuer">
            Certificate Issuer
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.NameConstraints">
            Name Constraints
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.CrlDistributionPoints">
            CRL Distribution Points
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.CertificatePolicies">
            Certificate Policies
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.PolicyMappings">
            Policy Mappings
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.AuthorityKeyIdentifier">
            Authority Key Identifier
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.PolicyConstraints">
            Policy Constraints
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.ExtendedKeyUsage">
            Extended Key Usage
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.FreshestCrl">
            Freshest CRL
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.InhibitAnyPolicy">
            Inhibit Any Policy
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.AuthorityInfoAccess">
            Authority Info Access
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.SubjectInfoAccess">
            Subject Info Access
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.LogoType">
            Logo Type
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.BiometricInfo">
            BiometricInfo
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.QCStatements">
            QCStatements
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.AuditIdentity">
            Audit identity extension in attribute certificates.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.NoRevAvail">
            NoRevAvail extension in attribute certificates.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.TargetInformation">
            TargetInformation extension in attribute certificates.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.ExpiredCertsOnCrl">
            Expired Certificates on CRL extension
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
            
             the extensions are a list of constructed sequences, either with (Oid, OctetString) or (Oid, Boolean, OctetString)
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(System.Collections.Generic.IDictionary{Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.X509.X509Extension})">
            constructor from a table of extensions.
            <p>
            it's is assumed the table contains Oid/string pairs.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(System.Collections.Generic.IList{Org.BouncyCastle.Asn1.DerObjectIdentifier},System.Collections.Generic.IDictionary{Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.X509.X509Extension})">
            Constructor from a table of extensions with ordering.
            <p>
            It's is assumed the table contains Oid/string pairs.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(System.Collections.Generic.IList{Org.BouncyCastle.Asn1.DerObjectIdentifier},System.Collections.Generic.IList{Org.BouncyCastle.Asn1.X509.X509Extension})">
             Constructor from two vectors
            
             @param objectIDs an ArrayList of the object identifiers.
             @param values an ArrayList of the extension values.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.X509Extensions.ExtensionOids">
            return an Enumeration of the extension field's object ids.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.GetExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the extension represented by the object identifier
             passed in.
            
             @return the extension if it's present, null otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.GetExtensionParsedValue(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the parsed value of the extension represented by the object identifier
             passed in.
            
             @return the parsed value of the extension if it's present, null otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.ToAsn1Object">
             <pre>
                 Extensions        ::=   SEQUENCE SIZE (1..MAX) OF Extension
            
                 Extension         ::=   SEQUENCE {
                    extnId            EXTENSION.&amp;id ({ExtensionSet}),
                    critical          BOOLEAN DEFAULT FALSE,
                    extnValue         OCTET STRING }
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509Name">
             <pre>
                 RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
            
                 RelativeDistinguishedName ::= SET SIZE (1..MAX) OF AttributeTypeAndValue
            
                 AttributeTypeAndValue ::= SEQUENCE {
                                               type  OBJECT IDENTIFIER,
                                               value ANY }
             </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.C">
            country code - StringType(SIZE(2))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.O">
            organization - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.OU">
            organizational unit name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.T">
            Title
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.CN">
            common name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.Street">
            street - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.SerialNumber">
            device serial number name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.L">
            locality name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.ST">
            state, or province name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.Surname">
            Naming attributes of type X520name
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.BusinessCategory">
            businessCategory - DirectoryString(SIZE(1..128)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.PostalCode">
            postalCode - DirectoryString(SIZE(1..40)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.DnQualifier">
            dnQualifier - DirectoryString(SIZE(1..64)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.Pseudonym">
            RFC 3039 Pseudonym - DirectoryString(SIZE(1..64)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.DateOfBirth">
            RFC 3039 DateOfBirth - GeneralizedTime - YYYYMMDD000000Z
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.PlaceOfBirth">
            RFC 3039 PlaceOfBirth - DirectoryString(SIZE(1..128)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.Gender">
            RFC 3039 DateOfBirth - PrintableString (SIZE(1)) -- "M", "F", "m" or "f"
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.CountryOfCitizenship">
            RFC 3039 CountryOfCitizenship - PrintableString (SIZE (2)) -- ISO 3166
            codes only
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.CountryOfResidence">
            RFC 3039 CountryOfCitizenship - PrintableString (SIZE (2)) -- ISO 3166
            codes only
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.NameAtBirth">
            ISIS-MTT NameAtBirth - DirectoryString(SIZE(1..64)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.PostalAddress">
            RFC 3039 PostalAddress - SEQUENCE SIZE (1..6) OF
            DirectoryString(SIZE(1..30))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.DmdName">
            RFC 2256 dmdName
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.TelephoneNumber">
            id-at-telephoneNumber
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.OrganizationIdentifier">
            id-at-organizationIdentifier
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.Name">
            id-at-name
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.EmailAddress">
            Email address (RSA PKCS#9 extension) - IA5String.
            <p>Note: if you're trying to be ultra orthodox, don't use this! It shouldn't be in here.</p>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.UnstructuredName">
            more from PKCS#9
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.E">
            email address in Verisign certificates
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.UID">
            LDAP User id.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.X509Name.DefaultReverse">
            determines whether or not strings should be processed and printed
            from back to front.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.DefaultSymbolsInternal">
            default look up table translating OID values into their common symbols following
            the convention in RFC 2253 with a few extras
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.RFC2253SymbolsInternal">
            look up table translating OID values into their common symbols following the convention in RFC 2253
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.RFC1779SymbolsInternal">
             look up table translating OID values into their common symbols following the convention in RFC 1779
            
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.DefaultLookupInternal">
            look up table translating common symbols into their OIDS.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             Return a X509Name based on the passed in tagged object.
            
             @param obj tag object holding name.
             @param explicitly true if explicitly tagged false otherwise.
             @return the X509Name
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence
            
             the principal will be a list of constructed sets, each containing an (OID, string) pair.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Collections.Generic.IList{Org.BouncyCastle.Asn1.DerObjectIdentifier},System.Collections.Generic.IDictionary{Org.BouncyCastle.Asn1.DerObjectIdentifier,System.String})">
            Constructor from a table of attributes with ordering.
            <p>
            it's is assumed the table contains OID/string pairs, and the contents
            of the table are copied into an internal table as part of the
            construction process. The ordering ArrayList should contain the OIDs
            in the order they are meant to be encoded or printed in ToString.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Collections.Generic.IList{Org.BouncyCastle.Asn1.DerObjectIdentifier},System.Collections.Generic.IDictionary{Org.BouncyCastle.Asn1.DerObjectIdentifier,System.String},Org.BouncyCastle.Asn1.X509.X509NameEntryConverter)">
            Constructor from a table of attributes with ordering.
            <p>
            it's is assumed the table contains OID/string pairs, and the contents
            of the table are copied into an internal table as part of the
            construction process. The ordering ArrayList should contain the OIDs
            in the order they are meant to be encoded or printed in ToString.</p>
            <p>
            The passed in converter will be used to convert the strings into their
            ASN.1 counterparts.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Collections.Generic.IList{Org.BouncyCastle.Asn1.DerObjectIdentifier},System.Collections.Generic.IList{System.String})">
            Takes two vectors one of the oids and the other of the values.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Collections.Generic.IList{Org.BouncyCastle.Asn1.DerObjectIdentifier},System.Collections.Generic.IList{System.String},Org.BouncyCastle.Asn1.X509.X509NameEntryConverter)">
            Takes two vectors one of the oids and the other of the values.
            <p>
            The passed in converter will be used to convert the strings into their
            ASN.1 counterparts.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.String)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.String,Org.BouncyCastle.Asn1.X509.X509NameEntryConverter)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes with each
            string value being converted to its associated ASN.1 type using the passed
            in converter.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Boolean,System.String)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes. If reverse
            is true, create the encoded version of the sequence starting from the
            last element in the string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Boolean,System.String,Org.BouncyCastle.Asn1.X509.X509NameEntryConverter)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes with each
            string value being converted to its associated ASN.1 type using the passed
            in converter. If reverse is true the ASN.1 sequence representing the DN will
            be built by starting at the end of the string, rather than the start.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Boolean,System.Collections.Generic.IDictionary{System.String,Org.BouncyCastle.Asn1.DerObjectIdentifier},System.String)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes. lookUp
            should provide a table of lookups, indexed by lowercase only strings and
            yielding a DerObjectIdentifier, other than that OID. and numeric oids
            will be processed automatically.
            <br/>
            If reverse is true, create the encoded version of the sequence
            starting from the last element in the string.
            @param reverse true if we should start scanning from the end (RFC 2553).
            @param lookUp table of names and their oids.
            @param dirName the X.500 string to be parsed.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Boolean,System.Collections.Generic.IDictionary{System.String,Org.BouncyCastle.Asn1.DerObjectIdentifier},System.String,Org.BouncyCastle.Asn1.X509.X509NameEntryConverter)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes. lookUp
            should provide a table of lookups, indexed by lowercase only strings and
            yielding a DerObjectIdentifier, other than that OID. and numeric oids
            will be processed automatically. The passed in converter is used to convert the
            string values to the right of each equals sign to their ASN.1 counterparts.
            <br/>
            @param reverse true if we should start scanning from the end, false otherwise.
            @param lookUp table of names and oids.
            @param dirName the string dirName
            @param converter the converter to convert string values into their ASN.1 equivalents
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.GetOidList">
            return an IList of the oids in the name, in the order they were found.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.GetValueList">
            return an IList of the values found in the name, in the order they
            were found.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.GetValueList(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return an IList of the values found in the name, in the order they
            were found, with the DN label corresponding to passed in oid.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.Equivalent(Org.BouncyCastle.Asn1.X509.X509Name,System.Boolean)">
            <param name="other">The X509Name object to test equivalency against.</param>
            <param name="inOrder">If true, the order of elements must be the same,
            as well as the values associated with each element.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.Equivalent(Org.BouncyCastle.Asn1.X509.X509Name)">
            test for equivalence - note: case is ignored.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.ToString(System.Boolean,System.Collections.Generic.IDictionary{Org.BouncyCastle.Asn1.DerObjectIdentifier,System.String})">
             convert the structure to a string - if reverse is true the
             oids and values are listed out starting with the last element
             in the sequence (ala RFC 2253), otherwise the string will begin
             with the first element of the structure. If no string definition
             for the oid is found in oidSymbols the string value of the oid is
             added. Two standard symbol tables are provided DefaultSymbols, and
             RFC2253Symbols as part of this class.
            
             @param reverse if true start at the end of the sequence and work back.
             @param oidSymbols look up table strings for oids.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509NameEntryConverter">
                 * It turns out that the number of standard ways the fields in a DN should be
                 * encoded into their ASN.1 counterparts is rapidly approaching the
                 * number of machines on the internet. By default the X509Name class
                 * will produce UTF8Strings in line with the current recommendations (RFC 3280).
                 * <p>
                 * An example of an encoder look like below:
                 * <pre>
                 * public class X509DirEntryConverter
                 *     : X509NameEntryConverter
                 * {
                 *     public Asn1Object GetConvertedValue(
                 *         DerObjectIdentifier  oid,
                 *         string               value)
                 *     {
                 *         if (str.Length() != 0 &amp;&amp; str.charAt(0) == '#')
                 *         {
                 *             return ConvertHexEncoded(str, 1);
                 *         }
                 *         if (oid.Equals(EmailAddress))
                 *         {
                 *             return new DerIA5String(str);
                 *         }
                 *         else if (CanBePrintable(str))
                 *         {
                 *             return new DerPrintableString(str);
                 *         }
                 *         else if (CanBeUTF8(str))
                 *         {
                 *             return new DerUtf8String(str);
                 *         }
                 *         else
                 *         {
                 *             return new DerBmpString(str);
                 *         }
                 *     }
                 * }
            	 * </pre>
            	 * </p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509NameEntryConverter.ConvertHexEncoded(System.String,System.Int32)">
             Convert an inline encoded hex string rendition of an ASN.1
             object back into its corresponding ASN.1 object.
            
             @param str the hex encoded object
             @param off the index at which the encoding starts
             @return the decoded object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509NameEntryConverter.CanBePrintable(System.String)">
            return true if the passed in string can be represented without
            loss as a PrintableString, false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509NameEntryConverter.GetConvertedValue(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.String)">
             Convert the passed in string value into the appropriate ASN.1
             encoded object.
            
             @param oid the oid associated with the value in the DN.
             @param value the value of the particular DN component.
             @return the ASN.1 equivalent for the value.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509NameTokenizer">
            class for breaking up an X500 Name into it's component tokens, ala
            java.util.StringTokenizer. We need this class as some of the
            lightweight Java environment don't support classes like
            StringTokenizer.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.ECNamedCurveTable">
            <summary>A unified elliptic curve registry of the various standard-specific registries.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.ECNamedCurveTable.GetByName(System.String)">
            <summary>Look up the <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.ECNamedCurveTable.GetByNameLazy(System.String)">
            <summary>Look up an <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given name.</summary>
            <remarks>
            Allows accessing the <see cref="T:Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of
            the full <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.ECNamedCurveTable.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given
            <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.ECNamedCurveTable.GetByOidLazy(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up an <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given
            <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <remarks>
            Allows accessing the <see cref="T:Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of
            the full <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="oid">The <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.ECNamedCurveTable.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the name of the curve with the given <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.ECNamedCurveTable.GetOid(System.String)">
            <summary>Look up the <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> of the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X9.ECNamedCurveTable.Names">
            <summary>Enumerate the available curve names in all the registries.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.X962NamedCurves">
            <summary>Elliptic curve registry for the curves defined in X.962 EC-DSA.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X962NamedCurves.GetByName(System.String)">
            <summary>Look up the <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X962NamedCurves.GetByNameLazy(System.String)">
            <summary>Look up an <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given name.</summary>
            <remarks>
            Allows accessing the <see cref="T:Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of the
            full <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X962NamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given
            <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X962NamedCurves.GetByOidLazy(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up an <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given
            <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <remarks>
            Allows accessing the <see cref="T:Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of the
            full <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="oid">The <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X962NamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the name of the curve with the given <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X962NamedCurves.GetOid(System.String)">
            <summary>Look up the <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> of the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X9.X962NamedCurves.Names">
            <summary>Enumerate the available curve names in this registry.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X962Parameters.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Parameters ::= CHOICE {
               ecParameters ECParameters,
               namedCurve   CURVES.&amp;id({CurveNames}),
               implicitlyCA Null
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.X9Curve">
            ASN.1 def for Elliptic-Curve Curve structure. See
            X9.62, for further details.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9Curve.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             Curve ::= Sequence {
                 a               FieldElement,
                 b               FieldElement,
                 seed            BIT STRING      OPTIONAL
             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.X9ECParameters">
            ASN.1 def for Elliptic-Curve ECParameters structure. See
            X9.62, for further details.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X9.X9ECParameters.CurveEntry">
             Return the ASN.1 entry representing the Curve.
            
             @return the X9Curve for the curve in these parameters.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X9.X9ECParameters.FieldIDEntry">
             Return the ASN.1 entry representing the FieldID.
            
             @return the X9FieldID for the FieldID in these parameters.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X9.X9ECParameters.BaseEntry">
             Return the ASN.1 entry representing the base point G.
            
             @return the X9ECPoint for the base point in these parameters.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9ECParameters.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             ECParameters ::= Sequence {
                 version         Integer { ecpVer1(1) } (ecpVer1),
                 fieldID         FieldID {{FieldTypes}},
                 curve           X9Curve,
                 base            X9ECPoint,
                 order           Integer,
                 cofactor        Integer OPTIONAL
             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.X9ECPoint">
            class for describing an ECPoint as a Der object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9ECPoint.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             ECPoint ::= OCTET STRING
            </pre>
            <p>
            Octet string produced using ECPoint.GetEncoded().</p>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.X9FieldElement">
            Class for processing an ECFieldElement as a DER object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9FieldElement.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             FieldElement ::= OCTET STRING
            </pre>
            <p>
            <ol>
            <li> if <i>q</i> is an odd prime then the field element is
            processed as an Integer and converted to an octet string
            according to x 9.62 4.3.1.</li>
            <li> if <i>q</i> is 2<sup>m</sup> then the bit string
            contained in the field element is converted into an octet
            string with the same ordering padded at the front if necessary.
            </li>
            </ol>
            </p>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.X9FieldID">
            ASN.1 def for Elliptic-Curve Field ID structure. See
            X9.62, for further details.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9FieldID.#ctor(Org.BouncyCastle.Math.BigInteger)">
            Constructor for elliptic curves over prime fields
            <code>F<sub>2</sub></code>.
            @param primeP The prime <code>p</code> defining the prime field.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9FieldID.#ctor(System.Int32,System.Int32)">
            Constructor for elliptic curves over binary fields
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9FieldID.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            Constructor for elliptic curves over binary fields
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>..
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9FieldID.ToAsn1Object">
            Produce a Der encoding of the following structure.
            <pre>
             FieldID ::= Sequence {
                 fieldType       FIELD-ID.&amp;id({IOSet}),
                 parameters      FIELD-ID.&amp;Type({IOSet}{&#64;fieldType})
             }
            </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X9.X9ObjectIdentifiers.IdDsaWithSha1">
            id-dsa-with-sha1 OBJECT IDENTIFIER ::=  { iso(1) member-body(2)
                  us(840) x9-57 (10040) x9cm(4) 3 }
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X9.X9ObjectIdentifiers.X9x63Scheme">
            X9.63
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X9.X9ObjectIdentifiers.ansi_x9_42">
            X9.42
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.ArmoredInputStream">
             reader for Base64 armored objects - read the headers and then start returning
             bytes when the data is reached. An IOException is thrown if the CRC check
             is detected and fails.
             <p>
             By default a missing CRC will not cause an exception. To force CRC detection use:
             <pre>
                 ArmoredInputStream aIn = ...
            
                 aIn.setDetectMissingCRC(true);
             </pre>
             </p>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredInputStream.Decode(System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[])">
             decode the base 64 encoded input data.
            
             @return the offset the data starts in out.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredInputStream.#ctor(System.IO.Stream)">
             Create a stream for reading a PGP armoured message, parsing up to a header
             and then reading the data that follows.
            
             @param input
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredInputStream.#ctor(System.IO.Stream,System.Boolean)">
             Create an armoured input stream which will assume the data starts
             straight away, or parse for headers first depending on the value of
             hasHeaders.
            
             @param input
             @param hasHeaders true if headers are to be looked for, false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredInputStream.IsClearText">
            @return true if we are inside the clear text section of a PGP
            signed message.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredInputStream.IsEndOfStream">
            @return true if the stream is actually at end of file.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredInputStream.GetArmorHeaderLine">
            Return the armor header line (if there is one)
            @return the armor header line, null if none present.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredInputStream.GetArmorHeaders">
            Return the armor headers (the lines after the armor header line),
            @return an array of armor headers, null if there aren't any.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredInputStream.SetDetectMissingCrc(System.Boolean)">
             Change how the stream should react if it encounters missing CRC checksum.
             The default value is false (ignore missing CRC checksums). If the behavior is set to true,
             an {@link IOException} will be thrown if a missing CRC checksum is encountered.
            
             @param detectMissing ignore missing CRC sums
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.ArmoredOutputStream">
            Basic output stream.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredOutputStream.Encode(System.IO.Stream,System.Int32[],System.Int32)">
            encode the input data producing a base 64 encoded byte array.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredOutputStream.SetHeader(System.String,System.String)">
            Set an additional header entry. Any current value(s) under the same name will be
            replaced by the new one. A null value will clear the entry for name.         *
            @param name the name of the header entry.
            @param v the value of the header entry.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredOutputStream.AddHeader(System.String,System.String)">
             Set an additional header entry. The current value(s) will continue to exist together
             with the new one. Adding a null value has no effect.
            
             @param name the name of the header entry.
             @param value the value of the header entry.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredOutputStream.ResetHeaders">
            Reset the headers to only contain a Version string (if one is present).
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredOutputStream.BeginClearText(Org.BouncyCastle.Bcpg.HashAlgorithmTag)">
            Start a clear text signed message.
            @param hashAlgorithm
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredOutputStream.Dispose(System.Boolean)">
            <b>Note</b>: Close() does not close the underlying stream. So it is possible to write
            multiple objects using armoring to a single stream.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Attr.ImageAttrib">
            <remarks>Basic type for a image attribute packet.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.BcpgInputStream">
            <remarks>Reader for PGP objects.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.BcpgInputStream.NextPacketTag">
            <summary>Returns the next packet tag in the stream.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.BcpgInputStream.PartialInputStream">
            <summary>
            A stream that overlays our input stream, allowing the user to only read a segment of it.
            NB: dataLength will be negative if the segment length is in the upper range above 2**31.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.BcpgObject">
            <remarks>Base class for a PGP object.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.BcpgOutputStream">
            <remarks>Basic output stream.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.BcpgOutputStream.#ctor(System.IO.Stream)">
            <summary>Create a stream representing a general packet.</summary>
            <param name="outStr">Output stream to write to.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.BcpgOutputStream.#ctor(System.IO.Stream,Org.BouncyCastle.Bcpg.PacketTag)">
            <summary>Create a stream representing an old style partial object.</summary>
            <param name="outStr">Output stream to write to.</param>
            <param name="tag">The packet tag for the object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.BcpgOutputStream.#ctor(System.IO.Stream,Org.BouncyCastle.Bcpg.PacketTag,System.Int64,System.Boolean)">
            <summary>Create a stream representing a general packet.</summary>
            <param name="outStr">Output stream to write to.</param>
            <param name="tag">Packet tag.</param>
            <param name="length">Size of chunks making up the packet.</param>
            <param name="oldFormat">If true, the header is written out in old format.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.BcpgOutputStream.#ctor(System.IO.Stream,Org.BouncyCastle.Bcpg.PacketTag,System.Int64)">
            <summary>Create a new style partial input stream buffered into chunks.</summary>
            <param name="outStr">Output stream to write to.</param>
            <param name="tag">Packet tag.</param>
            <param name="length">Size of chunks making up the packet.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.BcpgOutputStream.#ctor(System.IO.Stream,Org.BouncyCastle.Bcpg.PacketTag,System.Byte[])">
            <summary>Create a new style partial input stream buffered into chunks.</summary>
            <param name="outStr">Output stream to write to.</param>
            <param name="tag">Packet tag.</param>
            <param name="buffer">Buffer to use for collecting chunks.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.BcpgOutputStream.Flush">
            <summary>Flush the underlying stream.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.BcpgOutputStream.Finish">
            <summary>Finish writing out the current packet without closing the underlying stream.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.CompressedDataPacket">
            <remarks>Generic compressed data object.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.CompressedDataPacket.Algorithm">
            <summary>The algorithm tag value.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.CompressionAlgorithmTag">
            <remarks>Basic tags for compression algorithms.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.ContainedPacket">
            <remarks>Basic type for a PGP packet.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.DsaPublicBcpgKey">
            <remarks>Base class for a DSA public key.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.DsaPublicBcpgKey.#ctor(Org.BouncyCastle.Bcpg.BcpgInputStream)">
            <param name="bcpgIn">The stream to read the packet from.</param>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.DsaPublicBcpgKey.Format">
            <summary>The format, as a string, always "PGP".</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.DsaPublicBcpgKey.GetEncoded">
            <summary>Return the standard PGP encoding of the key.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.DsaSecretBcpgKey">
            <remarks>Base class for a DSA secret key.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.DsaSecretBcpgKey.#ctor(Org.BouncyCastle.Bcpg.BcpgInputStream)">
            @param in
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.DsaSecretBcpgKey.Format">
            <summary>The format, as a string, always "PGP".</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.DsaSecretBcpgKey.GetEncoded">
            <summary>Return the standard PGP encoding of the key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.DsaSecretBcpgKey.X">
            @return x
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.ECDHPublicBcpgKey">
            <remarks>Base class for an ECDH Public Key.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ECDHPublicBcpgKey.#ctor(Org.BouncyCastle.Bcpg.BcpgInputStream)">
            <param name="bcpgIn">The stream to read the packet from.</param>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.ECDsaPublicBcpgKey">
            <remarks>Base class for an ECDSA Public Key.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ECDsaPublicBcpgKey.#ctor(Org.BouncyCastle.Bcpg.BcpgInputStream)">
            <param name="bcpgIn">The stream to read the packet from.</param>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.ECPublicBcpgKey">
            <remarks>Base class for an EC Public Key.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ECPublicBcpgKey.#ctor(Org.BouncyCastle.Bcpg.BcpgInputStream)">
            <param name="bcpgIn">The stream to read the packet from.</param>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.ECPublicBcpgKey.Format">
            <summary>The format, as a string, always "PGP".</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ECPublicBcpgKey.GetEncoded">
            <summary>Return the standard PGP encoding of the key.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.ECSecretBcpgKey">
            <remarks>Base class for an EC Secret Key.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.ECSecretBcpgKey.Format">
            <summary>The format, as a string, always "PGP".</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ECSecretBcpgKey.GetEncoded">
            <summary>Return the standard PGP encoding of the key.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.ElGamalPublicBcpgKey">
            <remarks>Base class for an ElGamal public key.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.ElGamalPublicBcpgKey.Format">
            <summary>The format, as a string, always "PGP".</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ElGamalPublicBcpgKey.GetEncoded">
            <summary>Return the standard PGP encoding of the key.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.ElGamalSecretBcpgKey">
            <remarks>Base class for an ElGamal secret key.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ElGamalSecretBcpgKey.#ctor(Org.BouncyCastle.Bcpg.BcpgInputStream)">
            @param in
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ElGamalSecretBcpgKey.#ctor(Org.BouncyCastle.Math.BigInteger)">
            @param x
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.ElGamalSecretBcpgKey.Format">
            <summary>The format, as a string, always "PGP".</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ElGamalSecretBcpgKey.GetEncoded">
            <summary>Return the standard PGP encoding of the key.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.ExperimentalPacket">
            <remarks>Basic packet for an experimental packet.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.HashAlgorithmTag">
            <remarks>Basic tags for hash algorithms.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.IBcpgKey">
            <remarks>Base interface for a PGP key.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.IBcpgKey.Format">
            <summary>
            The base format for this key - in the case of the symmetric keys it will generally
            be raw indicating that the key is just a straight byte representation, for an asymmetric
            key the format will be PGP, indicating the key is a string of MPIs encoded in PGP format.
            </summary>
            <returns>"RAW" or "PGP".</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.InputStreamPacket.GetInputStream">
            <summary>Note: you can only read from this once...</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.LiteralDataPacket">
            <remarks>Generic literal data packet.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.LiteralDataPacket.Format">
            <summary>The format tag value.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.LiteralDataPacket.ModificationTime">
            <summary>The modification time of the file in milli-seconds (since Jan 1, 1970 UTC)</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.MarkerPacket">
            <remarks>Basic type for a marker packet.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.ModDetectionCodePacket">
            <remarks>Basic packet for a modification detection code packet.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.MPInteger">
            <remarks>A multiple precision integer</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OnePassSignaturePacket">
            <remarks>Generic signature object</remarks>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OnePassSignaturePacket.KeyAlgorithm">
            <summary>The encryption algorithm tag.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OnePassSignaturePacket.HashAlgorithm">
            <summary>The hash algorithm tag.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.PacketTag">
            <remarks>Basic PGP packet tag types.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag">
            <remarks>Public Key Algorithm tag numbers.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.PublicKeyEncSessionPacket">
            <remarks>Basic packet for a PGP public key.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.PublicKeyPacket">
            <remarks>Basic packet for a PGP public key.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.PublicKeyPacket.#ctor(Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag,System.DateTime,Org.BouncyCastle.Bcpg.IBcpgKey)">
            <summary>Construct a version 4 public key packet.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.PublicSubkeyPacket">
            <remarks>Basic packet for a PGP public subkey</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.PublicSubkeyPacket.#ctor(Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag,System.DateTime,Org.BouncyCastle.Bcpg.IBcpgKey)">
            <summary>Construct a version 4 public subkey packet.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.RsaPublicBcpgKey">
            <remarks>Base class for an RSA public key.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.RsaPublicBcpgKey.#ctor(Org.BouncyCastle.Bcpg.BcpgInputStream)">
            <summary>Construct an RSA public key from the passed in stream.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.RsaPublicBcpgKey.#ctor(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            <param name="n">The modulus.</param>
            <param name="e">The public exponent.</param>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.RsaPublicBcpgKey.Format">
            <summary>The format, as a string, always "PGP".</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.RsaPublicBcpgKey.GetEncoded">
            <summary>Return the standard PGP encoding of the key.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.RsaSecretBcpgKey">
            <remarks>Base class for an RSA secret (or priate) key.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.RsaSecretBcpgKey.Format">
            <summary>The format, as a string, always "PGP".</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.RsaSecretBcpgKey.GetEncoded">
            <summary>Return the standard PGP encoding of the key.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.S2k">
            <remarks>The string to key specifier class.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.S2k.HashAlgorithm">
            <summary>The hash algorithm.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.S2k.GetIV">
            <summary>The IV for the key generation algorithm.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.S2k.IterationCount">
            <summary>The iteration count</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.S2k.ProtectionMode">
            <summary>The protection mode - only if GnuDummyS2K</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.SecretKeyPacket">
            <remarks>Basic packet for a PGP secret key.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.SecretSubkeyPacket">
            <remarks>Basic packet for a PGP secret key.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.SignaturePacket">
            <remarks>Generic signature packet.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.SignaturePacket.#ctor(System.Int32,System.Int64,Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag,Org.BouncyCastle.Bcpg.HashAlgorithmTag,Org.BouncyCastle.Bcpg.SignatureSubpacket[],Org.BouncyCastle.Bcpg.SignatureSubpacket[],System.Byte[],Org.BouncyCastle.Bcpg.MPInteger[])">
             Generate a version 4 signature packet.
            
             @param signatureType
             @param keyAlgorithm
             @param hashAlgorithm
             @param hashedData
             @param unhashedData
             @param fingerprint
             @param signature
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.SignaturePacket.#ctor(System.Int32,System.Int32,System.Int64,Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag,Org.BouncyCastle.Bcpg.HashAlgorithmTag,System.Int64,System.Byte[],Org.BouncyCastle.Bcpg.MPInteger[])">
             Generate a version 2/3 signature packet.
            
             @param signatureType
             @param keyAlgorithm
             @param hashAlgorithm
             @param fingerprint
             @param signature
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.SignaturePacket.KeyId">
            return the keyId
            @return the keyId that created the signature.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.SignaturePacket.GetSignatureTrailer">
             return the signature trailer that must be included with the data
             to reconstruct the signature
            
             @return byte[]
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.SignaturePacket.GetSignature">
            		* return the signature as a set of integers - note this is normalised to be the
                    * ASN.1 encoding of what appears in the signature packet.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.SignaturePacket.GetSignatureBytes">
            Return the byte encoding of the signature section.
            @return uninterpreted signature bytes.
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.SignaturePacket.CreationTime">
            <summary>Return the creation time in milliseconds since 1 Jan., 1970 UTC.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.SignatureSubpacket">
            <remarks>Basic type for a PGP Signature sub-packet.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.SignatureSubpacket.GetData">
            <summary>Return the generic data making up the packet.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.SignatureSubpacketsParser">
            reader for signature sub-packets
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.SignatureSubpacketTag">
            Basic PGP signature sub-packet tag types.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.EmbeddedSignature">
            Packet embedded signature
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.Exportable">
            packet giving signature creation time.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.Features">
            packet giving signature expiration time.
        </member>
        <member name="F:Org.BouncyCastle.Bcpg.Sig.Features.FEATURE_MODIFICATION_DETECTION">
            Identifier for the Modification Detection (packets 18 and 19) 
        </member>
        <member name="F:Org.BouncyCastle.Bcpg.Sig.Features.FEATURE_AEAD_ENCRYPTED_DATA">
            Identifier for the AEAD Encrypted Data Packet (packet 20) and version 5
                     Symmetric-Key Encrypted Session Key Packets (packet 3) 
        </member>
        <member name="F:Org.BouncyCastle.Bcpg.Sig.Features.FEATURE_VERSION_5_PUBLIC_KEY">
            Identifier for the Version 5 Public-Key Packet format and corresponding new
                       fingerprint format 
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.Sig.Features.SupportsModificationDetection">
            Returns if modification detection is supported.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.Sig.Features.SupportsFeature(System.Byte)">
            Returns if a particular feature is supported.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.IssuerKeyId">
            packet giving signature creation time.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.KeyExpirationTime">
            packet giving time after creation at which the key expires.
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.Sig.KeyExpirationTime.Time">
             Return the number of seconds after creation time a key is valid for.
            
             @return second count for key validity.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.KeyFlags">
            Packet holding the key flag values.
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.Sig.KeyFlags.Flags">
            <summary>
            Return the flag values contained in the first 4 octets (note: at the moment
            the standard only uses the first one).
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.NotationData">
            Class provided a NotationData object according to
            RFC2440, Chapter 5.2.3.15. Notation Data
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.PreferredAlgorithms">
            packet giving signature creation time.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.PrimaryUserId">
            packet giving whether or not the signature is signed using the primary user ID for the key.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.Revocable">
            packet giving whether or not is revocable.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.SignatureCreationTime">
            packet giving signature creation time.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.SignatureExpirationTime">
            packet giving signature expiration time.
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.Sig.SignatureExpirationTime.Time">
            return time in seconds before signature expires after creation time.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.SignerUserId">
            packet giving the User ID of the signer.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.TrustSignature">
            packet giving trust.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.RevocationKey">
            <summary>
            Represents revocation key OpenPGP signature sub packet.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.RevocationReason">
            <summary>
            Represents revocation reason OpenPGP signature sub packet.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.SymmetricEncDataPacket">
            <remarks>Basic type for a symmetric key encrypted packet.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag">
            Basic tags for symmetric key algorithms
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.SymmetricKeyEncSessionPacket">
            Basic type for a symmetric encrypted session key packet
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.SymmetricKeyEncSessionPacket.EncAlgorithm">
            @return int
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.SymmetricKeyEncSessionPacket.S2k">
            @return S2k
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.SymmetricKeyEncSessionPacket.GetSecKeyData">
            @return byte[]
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.SymmetricKeyEncSessionPacket.Version">
            @return int
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.TrustPacket">
            <summary>Basic type for a trust packet.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.UserAttributePacket">
            Basic type for a user attribute packet.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.UserAttributeSubpacket">
            Basic type for a user attribute sub-packet.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.UserAttributeSubpacket.GetData">
            return the generic data making up the packet.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.UserAttributeSubpacketsParser">
            reader for user attribute sub-packets
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.UserAttributeSubpacketTag">
            Basic PGP user attribute sub-packet tag types.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.UserIdPacket">
            Basic type for a user ID packet.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpCompressedData">
            <remarks>Compressed data objects</remarks>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpCompressedData.Algorithm">
            <summary>The algorithm used for compression</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpCompressedData.GetInputStream">
            <summary>Get the raw input stream contained in the object.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpCompressedData.GetDataStream">
            <summary>Return an uncompressed input stream which allows reading of the compressed data.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpCompressedDataGenerator">
            <remarks>Class for producing compressed data packets.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpCompressedDataGenerator.Open(System.IO.Stream)">
            <summary>
            <p>
            Return an output stream which will save the data being written to
            the compressed object.
            </p>
            <p>
            The stream created can be closed off by either calling Close()
            on the stream or Close() on the generator. Closing the returned
            stream does not close off the Stream parameter <c>outStr</c>.
            </p>
            </summary>
            <param name="outStr">Stream to be used for output.</param>
            <returns>A Stream for output of the compressed data.</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpCompressedDataGenerator.Open(System.IO.Stream,System.Byte[])">
            <summary>
            <p>
            Return an output stream which will compress the data as it is written to it.
            The stream will be written out in chunks according to the size of the passed in buffer.
            </p>
            <p>
            The stream created can be closed off by either calling Close()
            on the stream or Close() on the generator. Closing the returned
            stream does not close off the Stream parameter <c>outStr</c>.
            </p>
            <p>
            <b>Note</b>: if the buffer is not a power of 2 in length only the largest power of 2
            bytes worth of the buffer will be used.
            </p>
            <p>
            <b>Note</b>: using this may break compatibility with RFC 1991 compliant tools.
            Only recent OpenPGP implementations are capable of accepting these streams.
            </p>
            </summary>
            <param name="outStr">Stream to be used for output.</param>
            <param name="buffer">The buffer to use.</param>
            <returns>A Stream for output of the compressed data.</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpException"></exception>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpDataValidationException">
            <summary>Thrown if the IV at the start of a data stream indicates the wrong key is being used.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedData.GetInputStream">
            <summary>Return the raw input stream for the data stream.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedData.IsIntegrityProtected">
            <summary>Return true if the message is integrity protected.</summary>
            <returns>True, if there is a modification detection code namespace associated
            with this stream.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedData.Verify">
            <summary>Note: This can only be called after the message has been read.</summary>
            <returns>True, if the message verifies, false otherwise</returns>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator">
            <remarks>Generator for encrypted objects.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator.#ctor(Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Security.SecureRandom)">
            <summary>Existing SecureRandom constructor.</summary>
            <param name="encAlgorithm">The symmetric algorithm to use.</param>
            <param name="random">Source of randomness.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator.#ctor(Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,System.Boolean,Org.BouncyCastle.Security.SecureRandom)">
            <summary>Creates a cipher stream which will have an integrity packet associated with it.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator.#ctor(Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Security.SecureRandom,System.Boolean)">
            <summary>Base constructor.</summary>
            <param name="encAlgorithm">The symmetric algorithm to use.</param>
            <param name="random">Source of randomness.</param>
            <param name="oldFormat">PGP 2.6.x compatibility required.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator.AddMethod(System.Char[],Org.BouncyCastle.Bcpg.HashAlgorithmTag)">
            <summary>Add a PBE encryption method to the encrypted object.</summary>
            <remarks>
            Conversion of the passphrase characters to bytes is performed using Convert.ToByte(), which is
            the historical behaviour of the library (1.7 and earlier).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator.AddMethodUtf8(System.Char[],Org.BouncyCastle.Bcpg.HashAlgorithmTag)">
            <summary>Add a PBE encryption method to the encrypted object.</summary>
            <remarks>
            The passphrase is encoded to bytes using UTF8 (Encoding.UTF8.GetBytes).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator.AddMethodRaw(System.Byte[],Org.BouncyCastle.Bcpg.HashAlgorithmTag)">
            <summary>Add a PBE encryption method to the encrypted object.</summary>
            <remarks>
            Allows the caller to handle the encoding of the passphrase to bytes.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator.AddMethod(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Add a public key encrypted session key to the encrypted object.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator.Open(System.IO.Stream,System.Int64,System.Byte[])">
            <summary>
            <p>
            If buffer is non null stream assumed to be partial, otherwise the length will be used
            to output a fixed length packet.
            </p>
            <p>
            The stream created can be closed off by either calling Close()
            on the stream or Close() on the generator. Closing the returned
            stream does not close off the Stream parameter <c>outStr</c>.
            </p>
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator.Open(System.IO.Stream,System.Int64)">
            <summary>
            <p>
            Return an output stream which will encrypt the data as it is written to it.
            </p>
            <p>
            The stream created can be closed off by either calling Close()
            on the stream or Close() on the generator. Closing the returned
            stream does not close off the Stream parameter <c>outStr</c>.
            </p>
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator.Open(System.IO.Stream,System.Byte[])">
            <summary>
            <p>
            Return an output stream which will encrypt the data as it is written to it.
            The stream will be written out in chunks according to the size of the passed in buffer.
            </p>
            <p>
            The stream created can be closed off by either calling Close()
            on the stream or Close() on the generator. Closing the returned
            stream does not close off the Stream parameter <c>outStr</c>.
            </p>
            <p>
            <b>Note</b>: if the buffer is not a power of 2 in length only the largest power of 2
            bytes worth of the buffer will be used.
            </p>
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataList">
            <remarks>A holder for a list of PGP encryption method packets.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpException">
            <summary>Generic exception class for PGP encoding/decoding problems.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyFlags">
            <remarks>Key flag values for the KeyFlags subpacket.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair">
            <remarks>
            General class to handle JCA key pairs and convert them into OpenPGP ones.
            <p>
            A word for the unwary, the KeyId for an OpenPGP public key is calculated from
            a hash that includes the time of creation, if you pass a different date to the
            constructor below with the same public private key pair the KeyIs will not be the
            same as for previous generations of the key, so ideally you only want to do
            this once.
            </p>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair.#ctor(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey)">
            <summary>Create a key pair from a PgpPrivateKey and a PgpPublicKey.</summary>
            <param name="pub">The public key.</param>
            <param name="priv">The private key.</param>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair.KeyId">
            <summary>The keyId associated with this key pair.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator">
            <remarks>
            Generator for a PGP master and subkey ring.
            This class will generate both the secret and public key rings
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.#ctor(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,System.String,Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,System.Char[],System.Boolean,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Create a new key ring generator.
            </summary>
            <remarks>
            Conversion of the passphrase characters to bytes is performed using Convert.ToByte(), which is
            the historical behaviour of the library (1.7 and earlier).
            </remarks>
            <param name="certificationLevel">The certification level for keys on this ring.</param>
            <param name="masterKey">The master key pair.</param>
            <param name="id">The id to be associated with the ring.</param>
            <param name="encAlgorithm">The algorithm to be used to protect secret keys.</param>
            <param name="passPhrase">The passPhrase to be used to protect secret keys.</param>
            <param name="useSha1">Checksum the secret keys with SHA1 rather than the older 16 bit checksum.</param>
            <param name="hashedPackets">Packets to be included in the certification hash.</param>
            <param name="unhashedPackets">Packets to be attached unhashed to the certification.</param>
            <param name="rand">input secured random.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.#ctor(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,System.String,Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,System.Boolean,System.Char[],System.Boolean,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Create a new key ring generator.
            </summary>
            <param name="certificationLevel">The certification level for keys on this ring.</param>
            <param name="masterKey">The master key pair.</param>
            <param name="id">The id to be associated with the ring.</param>
            <param name="encAlgorithm">The algorithm to be used to protect secret keys.</param>
            <param name="utf8PassPhrase">
            If true, conversion of the passphrase to bytes uses Encoding.UTF8.GetBytes(), otherwise the conversion
            is performed using Convert.ToByte(), which is the historical behaviour of the library (1.7 and earlier).
            </param>
            <param name="passPhrase">The passPhrase to be used to protect secret keys.</param>
            <param name="useSha1">Checksum the secret keys with SHA1 rather than the older 16 bit checksum.</param>
            <param name="hashedPackets">Packets to be included in the certification hash.</param>
            <param name="unhashedPackets">Packets to be attached unhashed to the certification.</param>
            <param name="rand">input secured random.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.#ctor(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,System.String,Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,System.Byte[],System.Boolean,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Create a new key ring generator.
            </summary>
            <param name="certificationLevel">The certification level for keys on this ring.</param>
            <param name="masterKey">The master key pair.</param>
            <param name="id">The id to be associated with the ring.</param>
            <param name="encAlgorithm">The algorithm to be used to protect secret keys.</param>
            <param name="rawPassPhrase">The passPhrase to be used to protect secret keys.</param>
            <param name="useSha1">Checksum the secret keys with SHA1 rather than the older 16 bit checksum.</param>
            <param name="hashedPackets">Packets to be included in the certification hash.</param>
            <param name="unhashedPackets">Packets to be attached unhashed to the certification.</param>
            <param name="rand">input secured random.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.#ctor(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,System.String,Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Bcpg.HashAlgorithmTag,System.Char[],System.Boolean,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Create a new key ring generator.
            </summary>
            <remarks>
            Conversion of the passphrase characters to bytes is performed using Convert.ToByte(), which is
            the historical behaviour of the library (1.7 and earlier).
            </remarks>
            <param name="certificationLevel">The certification level for keys on this ring.</param>
            <param name="masterKey">The master key pair.</param>
            <param name="id">The id to be associated with the ring.</param>
            <param name="encAlgorithm">The algorithm to be used to protect secret keys.</param>
            <param name="hashAlgorithm">The hash algorithm.</param>
            <param name="passPhrase">The passPhrase to be used to protect secret keys.</param>
            <param name="useSha1">Checksum the secret keys with SHA1 rather than the older 16 bit checksum.</param>
            <param name="hashedPackets">Packets to be included in the certification hash.</param>
            <param name="unhashedPackets">Packets to be attached unhashed to the certification.</param>
            <param name="rand">input secured random.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.#ctor(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,System.String,Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Bcpg.HashAlgorithmTag,System.Boolean,System.Char[],System.Boolean,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Create a new key ring generator.
            </summary>
            <param name="certificationLevel">The certification level for keys on this ring.</param>
            <param name="masterKey">The master key pair.</param>
            <param name="id">The id to be associated with the ring.</param>
            <param name="encAlgorithm">The algorithm to be used to protect secret keys.</param>
            <param name="hashAlgorithm">The hash algorithm.</param>
            <param name="utf8PassPhrase">
            If true, conversion of the passphrase to bytes uses Encoding.UTF8.GetBytes(), otherwise the conversion
            is performed using Convert.ToByte(), which is the historical behaviour of the library (1.7 and earlier).
            </param>
            <param name="passPhrase">The passPhrase to be used to protect secret keys.</param>
            <param name="useSha1">Checksum the secret keys with SHA1 rather than the older 16 bit checksum.</param>
            <param name="hashedPackets">Packets to be included in the certification hash.</param>
            <param name="unhashedPackets">Packets to be attached unhashed to the certification.</param>
            <param name="rand">input secured random.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.#ctor(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,System.String,Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Bcpg.HashAlgorithmTag,System.Byte[],System.Boolean,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Create a new key ring generator.
            </summary>
            <remarks>
            Allows the caller to handle the encoding of the passphrase to bytes.
            </remarks>
            <param name="certificationLevel">The certification level for keys on this ring.</param>
            <param name="masterKey">The master key pair.</param>
            <param name="id">The id to be associated with the ring.</param>
            <param name="encAlgorithm">The algorithm to be used to protect secret keys.</param>
            <param name="hashAlgorithm">The hash algorithm.</param>
            <param name="rawPassPhrase">The passPhrase to be used to protect secret keys.</param>
            <param name="useSha1">Checksum the secret keys with SHA1 rather than the older 16 bit checksum.</param>
            <param name="hashedPackets">Packets to be included in the certification hash.</param>
            <param name="unhashedPackets">Packets to be attached unhashed to the certification.</param>
            <param name="rand">input secured random.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.AddSubKey(Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair)">
            <summary>Add a subkey to the key ring to be generated with default certification.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.AddSubKey(Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,Org.BouncyCastle.Bcpg.HashAlgorithmTag)">
            <summary>
            Add a subkey to the key ring to be generated with default certification.
            </summary>
            <param name="keyPair">The key pair.</param>
            <param name="hashAlgorithm">The hash algorithm.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.AddSubKey(Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,Org.BouncyCastle.Bcpg.HashAlgorithmTag,Org.BouncyCastle.Bcpg.HashAlgorithmTag)">
            <summary>
            Add a signing subkey to the key ring to be generated with default certification and a primary key binding signature.
            </summary>
            <param name="keyPair">The key pair.</param>
            <param name="hashAlgorithm">The hash algorithm.</param>
            <param name="primaryKeyBindingHashAlgorithm">The primary-key binding hash algorithm.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.AddSubKey(Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector)">
            <summary>
            Add a subkey with specific hashed and unhashed packets associated with it and
            default certification using SHA-1.
            </summary>
            <param name="keyPair">Public/private key pair.</param>
            <param name="hashedPackets">Hashed packet values to be included in certification.</param>
            <param name="unhashedPackets">Unhashed packets values to be included in certification.</param>
            <exception cref="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.AddSubKey(Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.HashAlgorithmTag)">
            <summary>
            Add a subkey with specific hashed and unhashed packets associated with it and
            default certification.
            </summary>
            <param name="keyPair">Public/private key pair.</param>
            <param name="hashedPackets">Hashed packet values to be included in certification.</param>
            <param name="unhashedPackets">Unhashed packets values to be included in certification.</param>
            <param name="hashAlgorithm">The hash algorithm.</param>
            <exception cref="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpException">exception adding subkey: </exception>
            <exception cref="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.AddSubKey(Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.HashAlgorithmTag,Org.BouncyCastle.Bcpg.HashAlgorithmTag)">
            <summary>
            Add a signing subkey with specific hashed and unhashed packets associated with it and
            default certifications, including the primary-key binding signature.
            </summary>
            <param name="keyPair">Public/private key pair.</param>
            <param name="hashedPackets">Hashed packet values to be included in certification.</param>
            <param name="unhashedPackets">Unhashed packets values to be included in certification.</param>
            <param name="hashAlgorithm">The hash algorithm.</param>
            <param name="primaryKeyBindingHashAlgorithm">The primary-key binding hash algorithm.</param>
            <exception cref="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpException">exception adding subkey: </exception>
            <exception cref="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.GenerateSecretKeyRing">
            <summary>Return the secret key ring.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.GeneratePublicKeyRing">
            <summary>Return the public key ring that corresponds to the secret key ring.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyValidationException">
            <summary>Thrown if the key checksum is invalid.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralData">
            <summary>Class for processing literal data objects.</summary>
        </member>
        <member name="F:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralData.Console">
            <summary>The special name indicating a "for your eyes only" packet.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralData.Format">
            <summary>The format of the data stream - Binary or Text</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralData.FileName">
            <summary>The file name that's associated with the data stream.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralData.GetRawFileName">
            Return the file name as an unintrepreted byte array.
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralData.ModificationTime">
            <summary>The modification time for the file.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralData.GetInputStream">
            <summary>The raw input stream for the data stream.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralData.GetDataStream">
            <summary>The input stream representing the data stream.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralDataGenerator">
            <remarks>Class for producing literal data packets.</remarks>
        </member>
        <member name="F:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralDataGenerator.Console">
            <summary>The special name indicating a "for your eyes only" packet.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralDataGenerator.#ctor(System.Boolean)">
            <summary>
            Generates literal data objects in the old format.
            This is important if you need compatibility with PGP 2.6.x.
            </summary>
            <param name="oldFormat">If true, uses old format.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralDataGenerator.Open(System.IO.Stream,System.Char,System.String,System.Int64,System.DateTime)">
            <summary>
            <p>
            Open a literal data packet, returning a stream to store the data inside the packet.
            </p>
            <p>
            The stream created can be closed off by either calling Close()
            on the stream or Close() on the generator. Closing the returned
            stream does not close off the Stream parameter <c>outStr</c>.
            </p>
            </summary>
            <param name="outStr">The stream we want the packet in.</param>
            <param name="format">The format we are using.</param>
            <param name="name">The name of the 'file'.</param>
            <param name="length">The length of the data we will write.</param>
            <param name="modificationTime">The time of last modification we want stored.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralDataGenerator.Open(System.IO.Stream,System.Char,System.String,System.DateTime,System.Byte[])">
            <summary>
            <p>
            Open a literal data packet, returning a stream to store the data inside the packet,
            as an indefinite length stream. The stream is written out as a series of partial
            packets with a chunk size determined by the size of the passed in buffer.
            </p>
            <p>
            The stream created can be closed off by either calling Close()
            on the stream or Close() on the generator. Closing the returned
            stream does not close off the Stream parameter <c>outStr</c>.
            </p>
            <p>
            <b>Note</b>: if the buffer is not a power of 2 in length only the largest power of 2
            bytes worth of the buffer will be used.</p>
            </summary>
            <param name="outStr">The stream we want the packet in.</param>
            <param name="format">The format we are using.</param>
            <param name="name">The name of the 'file'.</param>
            <param name="modificationTime">The time of last modification we want stored.</param>
            <param name="buffer">The buffer to use for collecting data to put into chunks.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralDataGenerator.Open(System.IO.Stream,System.Char,System.IO.FileInfo)">
            <summary>
            <p>
            Open a literal data packet for the passed in <c>FileInfo</c> object, returning
            an output stream for saving the file contents.
            </p>
            <p>
            The stream created can be closed off by either calling Close()
            on the stream or Close() on the generator. Closing the returned
            stream does not close off the Stream parameter <c>outStr</c>.
            </p>
            </summary>
            <param name="outStr">The stream we want the packet in.</param>
            <param name="format">The format we are using.</param>
            <param name="file">The <c>FileInfo</c> object containg the packet details.</param>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpMarker">
            <remarks>
            A PGP marker packet - in general these should be ignored other than where
            the idea is to preserve the original input stream.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpObjectFactory">
            <remarks>
            General class for reading a PGP object stream.
            <p>
            Note: if this class finds a PgpPublicKey or a PgpSecretKey it
            will create a PgpPublicKeyRing, or a PgpSecretKeyRing for each
            key found. If all you are trying to do is read a key ring file use
            either PgpPublicKeyRingBundle or PgpSecretKeyRingBundle.</p>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpObjectFactory.NextPgpObject">
            <summary>Return the next object in the stream, or null if the end is reached.</summary>
            <exception cref="T:System.IO.IOException">On a parse error</exception>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpObjectFactory.AllPgpObjects">
            <summary>
            Return all available objects in a list.
            </summary>
            <returns>An <c>IList</c> containing all objects from this factory, in order.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpObjectFactory.FilterPgpObjects``1">
            <summary>
            Read all available objects, returning only those that are assignable to the specified type.
            </summary>
            <returns>An <see cref="T:System.Collections.Generic.IList`1"/> containing the filtered objects from this factory, in order.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpOnePassSignature">
            <remarks>A one pass signature object.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpOnePassSignature.InitVerify(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Initialise the signature object for verification.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpOnePassSignature.Verify(Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature)">
            <summary>Verify the calculated signature against the passed in PgpSignature.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpOnePassSignatureList">
            <remarks>Holder for a list of PgpOnePassSignature objects.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpPad">
            <remarks>Padding functions.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpPbeEncryptedData">
            <remarks>A password based encryption object.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPbeEncryptedData.GetInputStream">
            <summary>Return the raw input stream for the data stream.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPbeEncryptedData.GetDataStream(System.Char[])">
            <summary>Return the decrypted input stream, using the passed in passphrase.</summary>
            <remarks>
            Conversion of the passphrase characters to bytes is performed using Convert.ToByte(), which is
            the historical behaviour of the library (1.7 and earlier).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPbeEncryptedData.GetDataStreamUtf8(System.Char[])">
            <summary>Return the decrypted input stream, using the passed in passphrase.</summary>
            <remarks>
            The passphrase is encoded to bytes using UTF8 (Encoding.UTF8.GetBytes).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPbeEncryptedData.GetDataStreamRaw(System.Byte[])">
            <summary>Return the decrypted input stream, using the passed in passphrase.</summary>
            <remarks>
            Allows the caller to handle the encoding of the passphrase to bytes.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey">
            <remarks>General class to contain a private key for use with other OpenPGP objects.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey.#ctor(System.Int64,Org.BouncyCastle.Bcpg.PublicKeyPacket,Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Create a PgpPrivateKey from a keyID, the associated public data packet, and a regular private key.
            </summary>
            <param name="keyID">ID of the corresponding public key.</param>
            <param name="publicKeyPacket">the public key data packet to be associated with this private key.</param>
            <param name="privateKey">the private key data packet to be associated with this private key.</param>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey.KeyId">
            <summary>The keyId associated with the contained private key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey.PublicKeyPacket">
            <summary>The public key packet associated with this private key, if available.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey.Key">
            <summary>The contained private key.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey">
            <remarks>General class to handle a PGP public key object.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.#ctor(Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.DateTime)">
            <summary>
            Create a PgpPublicKey from the passed in lightweight one.
            </summary>
            <remarks>
            Note: the time passed in affects the value of the key's keyId, so you probably only want
            to do this once for a lightweight key, or make sure you keep track of the time you used.
            </remarks>
            <param name="algorithm">Asymmetric algorithm type representing the public key.</param>
            <param name="pubKey">Actual public key to associate.</param>
            <param name="time">Date of creation.</param>
            <exception cref="T:System.ArgumentException">If <c>pubKey</c> is not public.</exception>
            <exception cref="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpException">On key creation problem.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.#ctor(Org.BouncyCastle.Bcpg.PublicKeyPacket,Org.BouncyCastle.Bcpg.TrustPacket,System.Collections.Generic.IList{Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature})">
            <summary>Constructor for a sub-key.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.#ctor(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Copy constructor.</summary>
            <param name="pubKey">The public key to copy.</param>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.Version">
            <summary>The version of this key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.CreationTime">
            <summary>The creation time of this key.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetTrustData">
            <summary>Return the trust data associated with the public key, if present.</summary>
            <returns>A byte array with trust data, null otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetValidSeconds">
            <summary>The number of valid seconds from creation time - zero means no expiry.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.KeyId">
            <summary>The keyId associated with the public key.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetFingerprint">
            <summary>The fingerprint of the key</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.IsEncryptionKey">
            <summary>
            Check if this key has an algorithm type that makes it suitable to use for encryption.
            </summary>
            <remarks>
            Note: with version 4 keys KeyFlags subpackets should also be considered when present for
            determining the preferred use of the key.
            </remarks>
            <returns>
            <c>true</c> if this key algorithm is suitable for encryption.
            </returns>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.IsMasterKey">
            <summary>True, if this could be a master key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.Algorithm">
            <summary>The algorithm code associated with the public key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.BitStrength">
            <summary>The strength of the key in bits.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetKey">
            <summary>The public key contained in the object.</summary>
            <returns>A lightweight public key.</returns>
            <exception cref="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpException">If the key algorithm is not recognised.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetUserIds">
            <summary>Allows enumeration of any user IDs associated with the key.</summary>
            <returns>An <c>IEnumerable</c> of <c>string</c> objects.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetUserAttributes">
            <summary>Allows enumeration of any user attribute vectors associated with the key.</summary>
            <returns>An <c>IEnumerable</c> of <c>PgpUserAttributeSubpacketVector</c> objects.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetSignaturesForId(System.String)">
            <summary>Allows enumeration of any signatures associated with the passed in id.</summary>
            <param name="id">The ID to be matched.</param>
            <returns>An <c>IEnumerable</c> of <c>PgpSignature</c> objects.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetSignaturesForKeyID(System.Int64)">
            <summary>Return any signatures associated with the passed in key identifier keyID.</summary>
            <param name="keyID">the key id to be matched.</param>
            <returns>An <c>IEnumerable</c> of <c>PgpSignature</c> objects issued by the key with keyID.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetSignaturesForUserAttribute(Org.BouncyCastle.Bcpg.OpenPgp.PgpUserAttributeSubpacketVector)">
            <summary>Allows enumeration of signatures associated with the passed in user attributes.</summary>
            <param name="userAttributes">The vector of user attributes to be matched.</param>
            <returns>An <c>IEnumerable</c> of <c>PgpSignature</c> objects.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetSignaturesOfType(System.Int32)">
            <summary>Allows enumeration of signatures of the passed in type that are on this key.</summary>
            <param name="signatureType">The type of the signature to be returned.</param>
            <returns>An <c>IEnumerable</c> of <c>PgpSignature</c> objects.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetSignatures">
            <summary>Allows enumeration of all signatures/certifications associated with this key.</summary>
            <returns>An <c>IEnumerable</c> with all signatures/certifications.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetKeySignatures">
             Return all signatures/certifications directly associated with this key (ie, not to a user id).
            
             @return an iterator (possibly empty) with all signatures/certifications.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.IsRevoked">
            <summary>Check whether this (sub)key has a revocation signature on it.</summary>
            <returns>True, if this (sub)key has been revoked.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.AddCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,System.String,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature)">
            <summary>Add a certification for an id to the given public key.</summary>
            <param name="key">The key the certification is to be added to.</param>
            <param name="id">The ID the certification is associated with.</param>
            <param name="certification">The new certification.</param>
            <returns>The re-certified key.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.AddCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,Org.BouncyCastle.Bcpg.OpenPgp.PgpUserAttributeSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature)">
            <summary>Add a certification for the given UserAttributeSubpackets to the given public key.</summary>
            <param name="key">The key the certification is to be added to.</param>
            <param name="userAttributes">The attributes the certification is associated with.</param>
            <param name="certification">The new certification.</param>
            <returns>The re-certified key.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.RemoveCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,Org.BouncyCastle.Bcpg.OpenPgp.PgpUserAttributeSubpacketVector)">
            <summary>
            Remove any certifications associated with a user attribute subpacket on a key.
            </summary>
            <param name="key">The key the certifications are to be removed from.</param>
            <param name="userAttributes">The attributes to be removed.</param>
            <returns>
            The re-certified key, or null if the user attribute subpacket was not found on the key.
            </returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.RemoveCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,System.String)">
            <summary>Remove any certifications associated with a given ID on a key.</summary>
            <param name="key">The key the certifications are to be removed from.</param>
            <param name="id">The ID that is to be removed.</param>
            <returns>The re-certified key, or null if the ID was not found on the key.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.RemoveCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,System.String,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature)">
            <summary>Remove a certification associated with a given ID on a key.</summary>
            <param name="key">The key the certifications are to be removed from.</param>
            <param name="id">The ID that the certfication is to be removed from.</param>
            <param name="certification">The certfication to be removed.</param>
            <returns>The re-certified key, or null if the certification was not found.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.RemoveCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,Org.BouncyCastle.Bcpg.OpenPgp.PgpUserAttributeSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature)">
            <summary>Remove a certification associated with a given user attributes on a key.</summary>
            <param name="key">The key the certifications are to be removed from.</param>
            <param name="userAttributes">The user attributes that the certfication is to be removed from.</param>
            <param name="certification">The certification to be removed.</param>
            <returns>The re-certified key, or null if the certification was not found.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.AddCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature)">
            <summary>Add a revocation or some other key certification to a key.</summary>
            <param name="key">The key the revocation is to be added to.</param>
            <param name="certification">The key signature to be added.</param>
            <returns>The new changed public key object.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.RemoveCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature)">
            <summary>Remove a certification from the key.</summary>
            <param name="key">The key the certifications are to be removed from.</param>
            <param name="certification">The certfication to be removed.</param>
            <returns>The modified key, null if the certification was not found.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyEncryptedData">
            <remarks>A public key encrypted data object.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyEncryptedData.KeyId">
            <summary>The key ID for the key used to encrypt the data.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyEncryptedData.GetSymmetricAlgorithm(Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey)">
            <summary>
            Return the algorithm code for the symmetric algorithm used to encrypt the data.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyEncryptedData.GetDataStream(Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey)">
            <summary>Return the decrypted data stream for the packet.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing">
            <remarks>
            Class to hold a single master public key and its subkeys.
            <p>
            Often PGP keyring files consist of multiple master keys, if you are trying to process
            or construct one of these you should use the <c>PgpPublicKeyRingBundle</c> class.
            </p>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing.GetPublicKey">
            <summary>Return the first public key in the ring.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing.GetPublicKey(System.Int64)">
            <summary>Return the public key referred to by the passed in key ID if it is present.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing.GetPublicKeys">
            <summary>Allows enumeration of all the public keys.</summary>
            <returns>An <c>IEnumerable</c> of <c>PgpPublicKey</c> objects.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing.InsertPublicKey(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>
            Returns a new key ring with the public key passed in either added or
            replacing an existing one.
            </summary>
            <param name="pubRing">The public key ring to be modified.</param>
            <param name="pubKey">The public key to be inserted.</param>
            <returns>A new <c>PgpPublicKeyRing</c></returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing.RemovePublicKey(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Returns a new key ring with the public key passed in removed from the key ring.</summary>
            <param name="pubRing">The public key ring to be modified.</param>
            <param name="pubKey">The public key to be removed.</param>
            <returns>A new <c>PgpPublicKeyRing</c>, or null if pubKey is not found.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle">
            <remarks>
            Often a PGP key ring file is made up of a succession of master/sub-key key rings.
            If you want to read an entire public key file in one hit this is the class for you.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.#ctor(System.IO.Stream)">
            <summary>Build a PgpPublicKeyRingBundle from the passed in input stream.</summary>
            <param name="inputStream">Input stream containing data.</param>
            <exception cref="T:System.IO.IOException">If a problem parsing the stream occurs.</exception>
            <exception cref="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpException">If an object is encountered which isn't a PgpPublicKeyRing.</exception>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.Count">
            <summary>Return the number of key rings in this collection.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.GetKeyRings">
            <summary>Allow enumeration of the public key rings making up this collection.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.GetKeyRings(System.String)">
            <summary>Allow enumeration of the key rings associated with the passed in userId.</summary>
            <param name="userId">The user ID to be matched.</param>
            <returns>An <c>IEnumerable</c> of key rings which matched (possibly none).</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.GetKeyRings(System.String,System.Boolean)">
            <summary>Allow enumeration of the key rings associated with the passed in userId.</summary>
            <param name="userId">The user ID to be matched.</param>
            <param name="matchPartial">If true, userId need only be a substring of an actual ID string to match.</param>
            <returns>An <c>IEnumerable</c> of key rings which matched (possibly none).</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.GetKeyRings(System.String,System.Boolean,System.Boolean)">
            <summary>Allow enumeration of the key rings associated with the passed in userId.</summary>
            <param name="userID">The user ID to be matched.</param>
            <param name="matchPartial">If true, userId need only be a substring of an actual ID string to match.</param>
            <param name="ignoreCase">If true, case is ignored in user ID comparisons.</param>
            <returns>An <c>IEnumerable</c> of key rings which matched (possibly none).</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.GetPublicKey(System.Int64)">
            <summary>Return the PGP public key associated with the given key id.</summary>
            <param name="keyId">The ID of the public key to return.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.GetPublicKeyRing(System.Int64)">
            <summary>Return the public key ring which contains the key referred to by keyId</summary>
            <param name="keyId">key ID to match against</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.Contains(System.Int64)">
            <summary>
            Return true if a key matching the passed in key ID is present, false otherwise.
            </summary>
            <param name="keyID">key ID to look for.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.AddPublicKeyRing(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing)">
            <summary>
            Return a new bundle containing the contents of the passed in bundle and
            the passed in public key ring.
            </summary>
            <param name="bundle">The <c>PgpPublicKeyRingBundle</c> the key ring is to be added to.</param>
            <param name="publicKeyRing">The key ring to be added.</param>
            <returns>A new <c>PgpPublicKeyRingBundle</c> merging the current one with the passed in key ring.</returns>
            <exception cref="T:System.ArgumentException">If the keyId for the passed in key ring is already present.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.RemovePublicKeyRing(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing)">
            <summary>
            Return a new bundle containing the contents of the passed in bundle with
            the passed in public key ring removed.
            </summary>
            <param name="bundle">The <c>PgpPublicKeyRingBundle</c> the key ring is to be removed from.</param>
            <param name="publicKeyRing">The key ring to be removed.</param>
            <returns>A new <c>PgpPublicKeyRingBundle</c> not containing the passed in key ring.</returns>
            <exception cref="T:System.ArgumentException">If the keyId for the passed in key ring is not present.</exception>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey">
            <remarks>General class to handle a PGP secret key object.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.#ctor(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,System.String,Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,System.Char[],System.Boolean,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Security.SecureRandom)">
            <remarks>
            Conversion of the passphrase characters to bytes is performed using Convert.ToByte(), which is
            the historical behaviour of the library (1.7 and earlier).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.#ctor(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,System.String,Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,System.Boolean,System.Char[],System.Boolean,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Security.SecureRandom)">
            <remarks>
            If utf8PassPhrase is true, conversion of the passphrase to bytes uses Encoding.UTF8.GetBytes(), otherwise the conversion
            is performed using Convert.ToByte(), which is the historical behaviour of the library (1.7 and earlier).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.#ctor(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,System.String,Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,System.Byte[],System.Boolean,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Security.SecureRandom)">
            <remarks>
            Allows the caller to handle the encoding of the passphrase to bytes.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.#ctor(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,System.String,Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Bcpg.HashAlgorithmTag,System.Char[],System.Boolean,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Security.SecureRandom)">
            <remarks>
            Conversion of the passphrase characters to bytes is performed using Convert.ToByte(), which is
            the historical behaviour of the library (1.7 and earlier).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.#ctor(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,System.String,Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Bcpg.HashAlgorithmTag,System.Boolean,System.Char[],System.Boolean,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Security.SecureRandom)">
            <remarks>
            If utf8PassPhrase is true, conversion of the passphrase to bytes uses Encoding.UTF8.GetBytes(), otherwise the conversion
            is performed using Convert.ToByte(), which is the historical behaviour of the library (1.7 and earlier).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.#ctor(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,System.String,Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Bcpg.HashAlgorithmTag,System.Byte[],System.Boolean,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Security.SecureRandom)">
            <remarks>
            Allows the caller to handle the encoding of the passphrase to bytes.
            </remarks>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.IsSigningKey">
            <summary>
            Check if this key has an algorithm type that makes it suitable to use for signing.
            </summary>
            <remarks>
            Note: with version 4 keys KeyFlags subpackets should also be considered when present for
            determining the preferred use of the key.
            </remarks>
            <returns>
            <c>true</c> if this key algorithm is suitable for use with signing.
            </returns>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.IsMasterKey">
            <summary>True, if this is a master key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.IsPrivateKeyEmpty">
            <summary>Detect if the Secret Key's Private Key is empty or not</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.KeyEncryptionAlgorithm">
            <summary>The algorithm the key is encrypted with.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.KeyId">
            <summary>The key ID of the public key associated with this key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.S2kUsage">
            <summary>Return the S2K usage associated with this key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.S2k">
            <summary>Return the S2K used to process this key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.PublicKey">
            <summary>The public key associated with this key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.UserIds">
            <summary>Allows enumeration of any user IDs associated with the key.</summary>
            <returns>An <c>IEnumerable</c> of <c>string</c> objects.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.UserAttributes">
            <summary>Allows enumeration of any user attribute vectors associated with the key.</summary>
            <returns>An <c>IEnumerable</c> of <c>string</c> objects.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.ExtractPrivateKey(System.Char[])">
            <summary>Extract a <c>PgpPrivateKey</c> from this secret key's encrypted contents.</summary>
            <remarks>
            Conversion of the passphrase characters to bytes is performed using Convert.ToByte(), which is
            the historical behaviour of the library (1.7 and earlier).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.ExtractPrivateKeyUtf8(System.Char[])">
            <summary>Extract a <c>PgpPrivateKey</c> from this secret key's encrypted contents.</summary>
            <remarks>
            The passphrase is encoded to bytes using UTF8 (Encoding.UTF8.GetBytes).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.ExtractPrivateKeyRaw(System.Byte[])">
            <summary>Extract a <c>PgpPrivateKey</c> from this secret key's encrypted contents.</summary>
            <remarks>
            Allows the caller to handle the encoding of the passphrase to bytes.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.CopyWithNewPassword(Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey,System.Char[],System.Char[],Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Return a copy of the passed in secret key, encrypted using a new password
            and the passed in algorithm.
            </summary>
            <remarks>
            Conversion of the passphrase characters to bytes is performed using Convert.ToByte(), which is
            the historical behaviour of the library (1.7 and earlier).
            </remarks>
            <param name="key">The PgpSecretKey to be copied.</param>
            <param name="oldPassPhrase">The current password for the key.</param>
            <param name="newPassPhrase">The new password for the key.</param>
            <param name="newEncAlgorithm">The algorithm to be used for the encryption.</param>
            <param name="rand">Source of randomness.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.CopyWithNewPasswordUtf8(Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey,System.Char[],System.Char[],Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Return a copy of the passed in secret key, encrypted using a new password
            and the passed in algorithm.
            </summary>
            <remarks>
            The passphrase is encoded to bytes using UTF8 (Encoding.UTF8.GetBytes).
            </remarks>
            <param name="key">The PgpSecretKey to be copied.</param>
            <param name="oldPassPhrase">The current password for the key.</param>
            <param name="newPassPhrase">The new password for the key.</param>
            <param name="newEncAlgorithm">The algorithm to be used for the encryption.</param>
            <param name="rand">Source of randomness.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.CopyWithNewPasswordRaw(Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey,System.Byte[],System.Byte[],Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Return a copy of the passed in secret key, encrypted using a new password
            and the passed in algorithm.
            </summary>
            <remarks>
            Allows the caller to handle the encoding of the passphrase to bytes.
            </remarks>
            <param name="key">The PgpSecretKey to be copied.</param>
            <param name="rawOldPassPhrase">The current password for the key.</param>
            <param name="rawNewPassPhrase">The new password for the key.</param>
            <param name="newEncAlgorithm">The algorithm to be used for the encryption.</param>
            <param name="rand">Source of randomness.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.ReplacePublicKey(Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Replace the passed the public key on the passed in secret key.</summary>
            <param name="secretKey">Secret key to change.</param>
            <param name="publicKey">New public key.</param>
            <returns>A new secret key.</returns>
            <exception cref="T:System.ArgumentException">If KeyId's do not match.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.ParseSecretKeyFromSExpr(System.IO.Stream,System.Char[],Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>
            Parse a secret key from one of the GPG S expression keys associating it with the passed in public key.
            </summary>
            <remarks>
            Conversion of the passphrase characters to bytes is performed using Convert.ToByte(), which is
            the historical behaviour of the library (1.7 and earlier).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.ParseSecretKeyFromSExprUtf8(System.IO.Stream,System.Char[],Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>
            Parse a secret key from one of the GPG S expression keys associating it with the passed in public key.
            </summary>
            <remarks>
            The passphrase is encoded to bytes using UTF8 (Encoding.UTF8.GetBytes).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.ParseSecretKeyFromSExprRaw(System.IO.Stream,System.Byte[],Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>
            Parse a secret key from one of the GPG S expression keys associating it with the passed in public key.
            </summary>
            <remarks>
            Allows the caller to handle the encoding of the passphrase to bytes.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.ParseSecretKeyFromSExpr(System.IO.Stream,System.Char[])">
            <summary>
            Parse a secret key from one of the GPG S expression keys.
            </summary>
            <remarks>
            Conversion of the passphrase characters to bytes is performed using Convert.ToByte(), which is
            the historical behaviour of the library (1.7 and earlier).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.ParseSecretKeyFromSExprUtf8(System.IO.Stream,System.Char[])">
            <summary>
            Parse a secret key from one of the GPG S expression keys.
            </summary>
            <remarks>
            The passphrase is encoded to bytes using UTF8 (Encoding.UTF8.GetBytes).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.ParseSecretKeyFromSExprRaw(System.IO.Stream,System.Byte[])">
            <summary>
            Parse a secret key from one of the GPG S expression keys.
            </summary>
            <remarks>
            Allows the caller to handle the encoding of the passphrase to bytes.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.DoParseSecretKeyFromSExpr(System.IO.Stream,System.Byte[],System.Boolean)">
            <summary>
            Parse a secret key from one of the GPG S expression keys.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing">
            <remarks>
            Class to hold a single master secret key and its subkeys.
            <p>
            Often PGP keyring files consist of multiple master keys, if you are trying to process
            or construct one of these you should use the <c>PgpSecretKeyRingBundle</c> class.
            </p>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing.GetPublicKey">
            <summary>Return the public key for the master key.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing.GetKeysWithSignaturesBy(System.Int64)">
             Return any keys carrying a signature issued by the key represented by keyID.
            
             @param keyID the key id to be matched against.
             @return an iterator (possibly empty) of PGPPublicKey objects carrying signatures from keyID.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing.GetSecretKey">
            <summary>Return the master private key.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing.GetSecretKeys">
            <summary>Allows enumeration of the secret keys.</summary>
            <returns>An <c>IEnumerable</c> of <c>PgpSecretKey</c> objects.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing.GetExtraPublicKeys">
            <summary>
            Return an iterator of the public keys in the secret key ring that
            have no matching private key. At the moment only personal certificate data
            appears in this fashion.
            </summary>
            <returns>An <c>IEnumerable</c> of unattached, or extra, public keys.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing.ReplacePublicKeys(Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing)">
            <summary>
            Replace the public key set on the secret ring with the corresponding key off the public ring.
            </summary>
            <param name="secretRing">Secret ring to be changed.</param>
            <param name="publicRing">Public ring containing the new public key set.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing.CopyWithNewPassword(Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing,System.Char[],System.Char[],Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Return a copy of the passed in secret key ring, with the master key and sub keys encrypted
            using a new password and the passed in algorithm.
            </summary>
            <param name="ring">The <c>PgpSecretKeyRing</c> to be copied.</param>
            <param name="oldPassPhrase">The current password for key.</param>
            <param name="newPassPhrase">The new password for the key.</param>
            <param name="newEncAlgorithm">The algorithm to be used for the encryption.</param>
            <param name="rand">Source of randomness.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing.InsertSecretKey(Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing,Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey)">
            <summary>
            Returns a new key ring with the secret key passed in either added or
            replacing an existing one with the same key ID.
            </summary>
            <param name="secRing">The secret key ring to be modified.</param>
            <param name="secKey">The secret key to be inserted.</param>
            <returns>A new <c>PgpSecretKeyRing</c></returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing.RemoveSecretKey(Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing,Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey)">
            <summary>Returns a new key ring with the secret key passed in removed from the key ring.</summary>
            <param name="secRing">The secret key ring to be modified.</param>
            <param name="secKey">The secret key to be removed.</param>
            <returns>A new <c>PgpSecretKeyRing</c>, or null if secKey is not found.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle">
            <remarks>
            Often a PGP key ring file is made up of a succession of master/sub-key key rings.
            If you want to read an entire secret key file in one hit this is the class for you.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.#ctor(System.IO.Stream)">
            <summary>Build a PgpSecretKeyRingBundle from the passed in input stream.</summary>
            <param name="inputStream">Input stream containing data.</param>
            <exception cref="T:System.IO.IOException">If a problem parsing the stream occurs.</exception>
            <exception cref="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpException">If an object is encountered which isn't a PgpSecretKeyRing.</exception>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.Count">
            <summary>Return the number of rings in this collection.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.GetKeyRings">
            <summary>Allow enumeration of the secret key rings making up this collection.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.GetKeyRings(System.String)">
            <summary>Allow enumeration of the key rings associated with the passed in userId.</summary>
            <param name="userId">The user ID to be matched.</param>
            <returns>An <c>IEnumerable</c> of key rings which matched (possibly none).</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.GetKeyRings(System.String,System.Boolean)">
            <summary>Allow enumeration of the key rings associated with the passed in userId.</summary>
            <param name="userId">The user ID to be matched.</param>
            <param name="matchPartial">If true, userId need only be a substring of an actual ID string to match.</param>
            <returns>An <c>IEnumerable</c> of key rings which matched (possibly none).</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.GetKeyRings(System.String,System.Boolean,System.Boolean)">
            <summary>Allow enumeration of the key rings associated with the passed in userId.</summary>
            <param name="userID">The user ID to be matched.</param>
            <param name="matchPartial">If true, userId need only be a substring of an actual ID string to match.</param>
            <param name="ignoreCase">If true, case is ignored in user ID comparisons.</param>
            <returns>An <c>IEnumerable</c> of key rings which matched (possibly none).</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.GetSecretKey(System.Int64)">
            <summary>Return the PGP secret key associated with the given key id.</summary>
            <param name="keyId">The ID of the secret key to return.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.GetSecretKeyRing(System.Int64)">
            <summary>Return the secret key ring which contains the key referred to by keyId</summary>
            <param name="keyId">The ID of the secret key</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.Contains(System.Int64)">
            <summary>
            Return true if a key matching the passed in key ID is present, false otherwise.
            </summary>
            <param name="keyID">key ID to look for.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.AddSecretKeyRing(Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle,Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing)">
            <summary>
            Return a new bundle containing the contents of the passed in bundle and
            the passed in secret key ring.
            </summary>
            <param name="bundle">The <c>PgpSecretKeyRingBundle</c> the key ring is to be added to.</param>
            <param name="secretKeyRing">The key ring to be added.</param>
            <returns>A new <c>PgpSecretKeyRingBundle</c> merging the current one with the passed in key ring.</returns>
            <exception cref="T:System.ArgumentException">If the keyId for the passed in key ring is already present.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.RemoveSecretKeyRing(Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle,Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing)">
            <summary>
            Return a new bundle containing the contents of the passed in bundle with
            the passed in secret key ring removed.
            </summary>
            <param name="bundle">The <c>PgpSecretKeyRingBundle</c> the key ring is to be removed from.</param>
            <param name="secretKeyRing">The key ring to be removed.</param>
            <returns>A new <c>PgpSecretKeyRingBundle</c> not containing the passed in key ring.</returns>
            <exception cref="T:System.ArgumentException">If the keyId for the passed in key ring is not present.</exception>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature">
            <remarks>A PGP signature object.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.Version">
            <summary>The OpenPGP version number for this signature.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.KeyAlgorithm">
            <summary>The key algorithm associated with this signature.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.HashAlgorithm">
            <summary>The hash algorithm associated with this signature.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.IsCertification">
            <summary>Return true if this signature represents a certification.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.VerifyCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpUserAttributeSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>
            Verify the signature as certifying the passed in public key as associated
            with the passed in user attributes.
            </summary>
            <param name="userAttributes">User attributes the key was stored under.</param>
            <param name="key">The key to be verified.</param>
            <returns>True, if the signature matches, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.VerifyCertification(System.String,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>
            Verify the signature as certifying the passed in public key as associated
            with the passed in ID.
            </summary>
            <param name="id">ID the key was stored under.</param>
            <param name="key">The key to be verified.</param>
            <returns>True, if the signature matches, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.VerifyCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Verify a certification for the passed in key against the passed in master key.</summary>
            <param name="masterKey">The key we are verifying against.</param>
            <param name="pubKey">The key we are verifying.</param>
            <returns>True, if the certification is valid, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.VerifyCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Verify a key certification, such as revocation, for the passed in key.</summary>
            <param name="pubKey">The key we are checking.</param>
            <returns>True, if the certification is valid, false otherwise.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.KeyId">
            <summary>The ID of the key that created the signature.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.CreationTime">
            <summary>The creation time of this signature.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.HasSubpackets">
            <summary>
            Return true if the signature has either hashed or unhashed subpackets.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.IsCertification(System.Int32)">
            <summary>
            Return true if the passed in signature type represents a certification, false if the signature type is not.
            </summary>
            <param name="signatureType"></param>
            <returns>true if signatureType is a certification, false otherwise.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator">
            <remarks>Generator for PGP signatures.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator.#ctor(Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag,Org.BouncyCastle.Bcpg.HashAlgorithmTag)">
            <summary>Create a generator for the passed in keyAlgorithm and hashAlgorithm codes.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator.InitSign(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey)">
            <summary>Initialise the generator for signing.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator.InitSign(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey,Org.BouncyCastle.Security.SecureRandom)">
            <summary>Initialise the generator for signing.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator.GenerateOnePassVersion(System.Boolean)">
            <summary>Return the one pass header associated with the current signature.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator.Generate">
            <summary>Return a signature object containing the current signature state.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator.GenerateCertification(System.String,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Generate a certification for the passed in ID and key.</summary>
            <param name="id">The ID we are certifying against the public key.</param>
            <param name="pubKey">The key we are certifying against the ID.</param>
            <returns>The certification.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator.GenerateCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpUserAttributeSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Generate a certification for the passed in userAttributes.</summary>
            <param name="userAttributes">The ID we are certifying against the public key.</param>
            <param name="pubKey">The key we are certifying against the ID.</param>
            <returns>The certification.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator.GenerateCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Generate a certification for the passed in key against the passed in master key.</summary>
            <param name="masterKey">The key we are certifying against.</param>
            <param name="pubKey">The key we are certifying.</param>
            <returns>The certification.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator.GenerateCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Generate a certification, such as a revocation, for the passed in key.</summary>
            <param name="pubKey">The key we are certifying.</param>
            <returns>The certification.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureList">
            <remarks>A list of PGP signatures - normally in the signature block after literal data.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketGenerator">
            <remarks>Generator for signature subpackets.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketGenerator.#ctor">
             <summary>
            Base constructor, creates an empty generator.
             </summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketGenerator.#ctor(Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector)">
             <summary>
             Constructor for pre-initialising the generator from an existing one.
             </summary>
             <param name="sigSubV">
             sigSubV an initial set of subpackets.
             </param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketGenerator.SetTrust(System.Boolean,System.Int32,System.Int32)">
            <summary>
            Add a TrustSignature packet to the signature. The values for depth and trust are largely
            installation dependent but there are some guidelines in RFC 4880 - 5.2.3.13.
            </summary>
            <param name="isCritical">true if the packet is critical.</param>
            <param name="depth">depth level.</param>
            <param name="trustAmount">trust amount.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketGenerator.SetKeyExpirationTime(System.Boolean,System.Int64)">
            <summary>
            Set the number of seconds a key is valid for after the time of its creation.
            A value of zero means the key never expires.
            </summary>
            <param name="isCritical">True, if should be treated as critical, false otherwise.</param>
            <param name="seconds">The number of seconds the key is valid, or zero if no expiry.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketGenerator.SetSignatureExpirationTime(System.Boolean,System.Int64)">
            <summary>
            Set the number of seconds a signature is valid for after the time of its creation.
            A value of zero means the signature never expires.
            </summary>
            <param name="isCritical">True, if should be treated as critical, false otherwise.</param>
            <param name="seconds">The number of seconds the signature is valid, or zero if no expiry.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketGenerator.SetSignatureCreationTime(System.Boolean,System.DateTime)">
            <summary>
            Set the creation time for the signature.
            <p>
            Note: this overrides the generation of a creation time when the signature
            is generated.</p>
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketGenerator.SetRevocationReason(System.Boolean,Org.BouncyCastle.Bcpg.RevocationReasonTag,System.String)">
            <summary>
            Sets revocation reason sub packet
            </summary>	    
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketGenerator.SetRevocationKey(System.Boolean,Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag,System.Byte[])">
            <summary>
            Sets revocation key sub packet
            </summary>	
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketGenerator.SetIssuerKeyID(System.Boolean,System.Int64)">
            <summary>
            Sets issuer key sub packet
            </summary>	
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector">
            <remarks>Container for a list of signature subpackets.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector.HasSubpacket(Org.BouncyCastle.Bcpg.SignatureSubpacketTag)">
             Return true if a particular subpacket type exists.
            
             @param type type to look for.
             @return true if present, false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector.GetSubpackets(Org.BouncyCastle.Bcpg.SignatureSubpacketTag)">
            Return all signature subpackets of the passed in type.
            @param type subpacket type code
            @return an array of zero or more matching subpackets.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector.GetSignatureExpirationTime">
            <summary>
            Return the number of seconds a signature is valid for after its creation date.
            A value of zero means the signature never expires.
            </summary>
            <returns>Seconds a signature is valid for.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector.GetKeyExpirationTime">
            <summary>
            Return the number of seconds a key is valid for after its creation date.
            A value of zero means the key never expires.
            </summary>
            <returns>Seconds a signature is valid for.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector.Count">
            <summary>Return the number of packets this vector contains.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpUserAttributeSubpacketVector">
            <remarks>Container for a list of user attribute subpackets.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpUtilities">
            <remarks>Basic utility class.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpUtilities.GetCurveName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             Return the EC curve name for the passed in OID.
            
             @param oid the EC curve object identifier in the PGP key
             @return  a string representation of the OID.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpUtilities.MakeKeyFromPassPhrase(Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Bcpg.S2k,System.Char[])">
            <remarks>
            Conversion of the passphrase characters to bytes is performed using Convert.ToByte(), which is
            the historical behaviour of the library (1.7 and earlier).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpUtilities.MakeKeyFromPassPhraseUtf8(Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Bcpg.S2k,System.Char[])">
            <remarks>
            The passphrase is encoded to bytes using UTF8 (Encoding.UTF8.GetBytes).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpUtilities.MakeKeyFromPassPhraseRaw(Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Bcpg.S2k,System.Byte[])">
            <remarks>
            Allows the caller to handle the encoding of the passphrase to bytes.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpUtilities.WriteFileToLiteralData(System.IO.Stream,System.Char,System.IO.FileInfo)">
            <summary>Write out the passed in file as a literal data packet.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpUtilities.WriteFileToLiteralData(System.IO.Stream,System.Char,System.IO.FileInfo,System.Byte[])">
            <summary>Write out the passed in file as a literal data packet in partial packet format.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpUtilities.GetDecoderStream(System.IO.Stream)">
            <summary>
            Return either an ArmoredInputStream or a BcpgInputStream based on whether
            the initial characters of the stream are binary PGP encodings or not.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpV3SignatureGenerator">
            <remarks>Generator for old style PGP V3 Signatures.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpV3SignatureGenerator.#ctor(Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag,Org.BouncyCastle.Bcpg.HashAlgorithmTag)">
            <summary>Create a generator for the passed in keyAlgorithm and hashAlgorithm codes.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpV3SignatureGenerator.InitSign(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey)">
            <summary>Initialise the generator for signing.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpV3SignatureGenerator.InitSign(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey,Org.BouncyCastle.Security.SecureRandom)">
            <summary>Initialise the generator for signing.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpV3SignatureGenerator.GenerateOnePassVersion(System.Boolean)">
            <summary>Return the one pass header associated with the current signature.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpV3SignatureGenerator.Generate">
            <summary>Return a V3 signature object containing the current signature state.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.SXprUtilities">
            Utility functions for looking a S-expression keys. This class will move when it finds a better home!
            <p>
            Format documented here:
            http://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob;f=agent/keyformat.txt;h=42c4b1f06faf1bbe71ffadc2fee0fad6bec91a97;hb=refs/heads/master
            </p>
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsAttributeTableParameter">
            <remarks>
            The 'Signature' parameter is only available when generating unsigned attributes.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsEnvelopedGenerator">
             General class for generating a CMS enveloped-data message.
            
             A simple example of usage.
            
             <pre>
                  CMSEnvelopedDataGenerator  fact = new CMSEnvelopedDataGenerator();
            
                  fact.addKeyTransRecipient(cert);
            
                  CMSEnvelopedData         data = fact.generate(content, algorithm, "BC");
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedGenerator.#ctor(Org.BouncyCastle.Security.SecureRandom)">
            <summary>Constructor allowing specific source of randomness</summary>
            <param name="random">Instance of <c>SecureRandom</c> to use.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedGenerator.AddKeyTransRecipient(Org.BouncyCastle.X509.X509Certificate)">
             add a recipient.
            
             @param cert recipient's public key certificate
             @exception ArgumentException if there is a problem with the certificate
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedGenerator.AddKeyTransRecipient(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[])">
             add a recipient
            
             @param key the public key used by the recipient
             @param subKeyId the identifier for the recipient's public key
             @exception ArgumentException if there is a problem with the key
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedGenerator.AddKekRecipient(System.String,Org.BouncyCastle.Crypto.Parameters.KeyParameter,System.Byte[])">
            add a KEK recipient.
            @param key the secret key to use for wrapping
            @param keyIdentifier the byte string that identifies the key
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedGenerator.AddKekRecipient(System.String,Org.BouncyCastle.Crypto.Parameters.KeyParameter,Org.BouncyCastle.Asn1.Cms.KekIdentifier)">
            add a KEK recipient.
            @param key the secret key to use for wrapping
            @param keyIdentifier the byte string that identifies the key
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedGenerator.AddKeyAgreementRecipient(System.String,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.X509.X509Certificate,System.String)">
             Add a key agreement based recipient.
            
             @param agreementAlgorithm key agreement algorithm to use.
             @param senderPrivateKey private key to initialise sender side of agreement with.
             @param senderPublicKey sender public key to include with message.
             @param recipientCert recipient's public key certificate.
             @param cekWrapAlgorithm OID for key wrapping algorithm to use.
             @exception SecurityUtilityException if the algorithm requested cannot be found
             @exception InvalidKeyException if the keys are inappropriate for the algorithm specified
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedGenerator.AddKeyAgreementRecipients(System.String,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Collections.Generic.IEnumerable{Org.BouncyCastle.X509.X509Certificate},System.String)">
             Add multiple key agreement based recipients (sharing a single KeyAgreeRecipientInfo structure).
            
             @param agreementAlgorithm key agreement algorithm to use.
             @param senderPrivateKey private key to initialise sender side of agreement with.
             @param senderPublicKey sender public key to include with message.
             @param recipientCerts recipients' public key certificates.
             @param cekWrapAlgorithm OID for key wrapping algorithm to use.
             @exception SecurityUtilityException if the algorithm requested cannot be found
             @exception InvalidKeyException if the keys are inappropriate for the algorithm specified
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedGenerator.AddRecipientInfoGenerator(Org.BouncyCastle.Cms.RecipientInfoGenerator)">
            <summary>
            Add a generator to produce the recipient info required.
            </summary>
            <param name="recipientInfoGenerator">a generator of a recipient info object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsProcessable.Write(System.IO.Stream)">
            <summary>
            Generic routine to copy out the data we want processed.
            </summary>
            <remarks>
            This routine may be called multiple times.
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Cms.CmsSignedGenerator.Data">
            Default type for the signed data.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedGenerator.#ctor(Org.BouncyCastle.Security.SecureRandom)">
            <summary>Constructor allowing specific source of randomness</summary>
            <param name="random">Instance of <c>SecureRandom</c> to use.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedGenerator.AddSigners(Org.BouncyCastle.Cms.SignerInformationStore)">
             Add a store of precalculated signers to the generator.
            
             @param signerStore store of signers
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedGenerator.GetGeneratedDigests">
             Return a map of oids and byte arrays representing the digests calculated on the content during
             the last generate.
            
             @return a map of oids (as string objects) and byte[] representing digests.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedHelper.GetDigestAlgName(System.String)">
            Return the digest algorithm using one of the standard JCA string
            representations rather than the algorithm identifier (if possible).
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedHelper.GetEncryptionAlgName(System.String)">
            Return the digest encryption algorithm using one of the standard
            JCA string representations rather than the algorithm identifier (if
            possible).
        </member>
        <member name="T:Org.BouncyCastle.Cms.KekRecipientInformation">
            the RecipientInfo class for a recipient who has been sent a message
            encrypted using a secret key known to the other side.
        </member>
        <member name="M:Org.BouncyCastle.Cms.KekRecipientInformation.GetContentStream(Org.BouncyCastle.Crypto.ICipherParameters)">
            decrypt the content and return an input stream.
        </member>
        <member name="T:Org.BouncyCastle.Cms.KeyAgreeRecipientInformation">
            the RecipientInfo class for a recipient who has been sent a message
            encrypted using key agreement.
        </member>
        <member name="M:Org.BouncyCastle.Cms.KeyAgreeRecipientInformation.GetContentStream(Org.BouncyCastle.Crypto.ICipherParameters)">
            decrypt the content and return an input stream.
        </member>
        <member name="T:Org.BouncyCastle.Cms.KeyTransRecipientInformation">
            the KeyTransRecipientInformation class for a recipient who has been sent a secret
            key encrypted using their public key that needs to be used to
            extract the message.
        </member>
        <member name="M:Org.BouncyCastle.Cms.KeyTransRecipientInformation.GetContentStream(Org.BouncyCastle.Crypto.ICipherParameters)">
            decrypt the content and return it as a byte array.
        </member>
        <member name="T:Org.BouncyCastle.Cms.OriginatorID">
            a basic index for an originator.
        </member>
        <member name="T:Org.BouncyCastle.Cms.PasswordRecipientInformation">
            the RecipientInfo class for a recipient who has been sent a message
            encrypted using a password.
        </member>
        <member name="P:Org.BouncyCastle.Cms.PasswordRecipientInformation.KeyDerivationAlgorithm">
             return the object identifier for the key derivation algorithm, or null
             if there is none present.
            
             @return OID for key derivation algorithm, if present.
        </member>
        <member name="M:Org.BouncyCastle.Cms.PasswordRecipientInformation.GetContentStream(Org.BouncyCastle.Crypto.ICipherParameters)">
            decrypt the content and return an input stream.
        </member>
        <member name="M:Org.BouncyCastle.Cms.RecipientInfoGenerator.Generate(Org.BouncyCastle.Crypto.Parameters.KeyParameter,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Generate a RecipientInfo object for the given key.
            </summary>
            <param name="contentEncryptionKey">
            A <see cref="T:Org.BouncyCastle.Crypto.Parameters.KeyParameter"/>
            </param>
            <param name="random">
            A <see cref="T:Org.BouncyCastle.Security.SecureRandom"/>
            </param>
            <returns>
            A <see cref="T:Org.BouncyCastle.Asn1.Cms.RecipientInfo"/>
            </returns>
            <exception cref="T:Org.BouncyCastle.Security.GeneralSecurityException"></exception>
        </member>
        <member name="P:Org.BouncyCastle.Cms.RecipientInformation.KeyEncryptionAlgOid">
                    * return the object identifier for the key encryption algorithm.
                    * 
            		* @return OID for key encryption algorithm.
        </member>
        <member name="P:Org.BouncyCastle.Cms.RecipientInformation.KeyEncryptionAlgParams">
                    * return the ASN.1 encoded key encryption algorithm parameters, or null if
                    * there aren't any.
                    * 
            		* @return ASN.1 encoding of key encryption algorithm parameters.
        </member>
        <member name="M:Org.BouncyCastle.Cms.RecipientInformation.GetMac">
             Return the MAC calculated for the content stream. Note: this call is only meaningful once all
             the content has been read.
            
             @return  byte array containing the mac.
        </member>
        <member name="M:Org.BouncyCastle.Cms.RecipientInformationStore.GetFirstRecipient(Org.BouncyCastle.Cms.RecipientID)">
             Return the first RecipientInformation object that matches the
             passed in selector. Null if there are no matches.
            
             @param selector to identify a recipient
             @return a single RecipientInformation object. Null if none matches.
        </member>
        <member name="P:Org.BouncyCastle.Cms.RecipientInformationStore.Count">
             Return the number of recipients in the collection.
            
             @return number of recipients identified.
        </member>
        <member name="M:Org.BouncyCastle.Cms.RecipientInformationStore.GetRecipients">
             Return all recipients in the collection
            
             @return a collection of recipients.
        </member>
        <member name="M:Org.BouncyCastle.Cms.RecipientInformationStore.GetRecipients(Org.BouncyCastle.Cms.RecipientID)">
             Return possible empty collection with recipients matching the passed in RecipientID
            
             @param selector a recipient id to select against.
             @return a collection of RecipientInformation objects.
        </member>
        <member name="T:Org.BouncyCastle.Cms.SignerID">
            a basic index for a signer.
        </member>
        <member name="T:Org.BouncyCastle.Cms.SignerInformation">
            an expanded SignerInfo block from a CMS Signed message
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.#ctor(Org.BouncyCastle.Cms.SignerInformation)">
             Protected constructor. In some cases clients have their own idea about how to encode
             the signed attributes and calculate the signature. This constructor is to allow developers
             to deal with that by extending off the class and overriding e.g. SignedAttributes property.
            
             @param baseInfo the SignerInformation to base this one on.
        </member>
        <member name="P:Org.BouncyCastle.Cms.SignerInformation.Version">
            return the version number for this objects underlying SignerInfo structure.
        </member>
        <member name="P:Org.BouncyCastle.Cms.SignerInformation.DigestAlgOid">
            return the object identifier for the signature.
        </member>
        <member name="P:Org.BouncyCastle.Cms.SignerInformation.DigestAlgParams">
            return the signature parameters, or null if there aren't any.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.GetContentDigest">
            return the content digest that was calculated during verification.
        </member>
        <member name="P:Org.BouncyCastle.Cms.SignerInformation.EncryptionAlgOid">
            return the object identifier for the signature.
        </member>
        <member name="P:Org.BouncyCastle.Cms.SignerInformation.EncryptionAlgParams">
            return the signature/encryption algorithm parameters, or null if
            there aren't any.
        </member>
        <member name="P:Org.BouncyCastle.Cms.SignerInformation.SignedAttributes">
            return a table of the signed attributes - indexed by
            the OID of the attribute.
        </member>
        <member name="P:Org.BouncyCastle.Cms.SignerInformation.UnsignedAttributes">
            return a table of the unsigned attributes indexed by
            the OID of the attribute.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.GetSignature">
            return the encoded signature
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.GetCounterSignatures">
            Return a SignerInformationStore containing the counter signatures attached to this
            signer. If no counter signatures are present an empty store is returned.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.GetEncodedSignedAttributes">
            return the DER encoding of the signed attributes.
            @throws IOException if an encoding error occurs.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.Verify(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            verify that the given public key successfully handles and confirms the
            signature associated with this signer.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.Verify(Org.BouncyCastle.X509.X509Certificate)">
            verify that the given certificate successfully handles and confirms
            the signature associated with this signer and, if a signingTime
            attribute is available, that the certificate was valid at the time the
            signature was generated.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.ToSignerInfo">
             Return the base ASN.1 CMS structure that this object contains.
            
             @return an object containing a CMS SignerInfo structure.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.ReplaceUnsignedAttributes(Org.BouncyCastle.Cms.SignerInformation,Org.BouncyCastle.Asn1.Cms.AttributeTable)">
             Return a signer information object with the passed in unsigned
             attributes replacing the ones that are current associated with
             the object passed in.
            
             @param signerInformation the signerInfo to be used as the basis.
             @param unsignedAttributes the unsigned attributes to add.
             @return a copy of the original SignerInformationObject with the changed attributes.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.AddCounterSigners(Org.BouncyCastle.Cms.SignerInformation,Org.BouncyCastle.Cms.SignerInformationStore)">
             Return a signer information object with passed in SignerInformationStore representing counter
             signatures attached as an unsigned attribute.
            
             @param signerInformation the signerInfo to be used as the basis.
             @param counterSigners signer info objects carrying counter signature.
             @return a copy of the original SignerInformationObject with the changed attributes.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformationStore.#ctor(Org.BouncyCastle.Cms.SignerInformation)">
             Create a store containing a single SignerInformation object.
            
             @param signerInfo the signer information to contain.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformationStore.#ctor(System.Collections.Generic.IEnumerable{Org.BouncyCastle.Cms.SignerInformation})">
             Create a store containing a collection of SignerInformation objects.
            
             @param signerInfos a collection signer information objects to contain.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformationStore.GetFirstSigner(Org.BouncyCastle.Cms.SignerID)">
             Return the first SignerInformation object that matches the
             passed in selector. Null if there are no matches.
            
             @param selector to identify a signer
             @return a single SignerInformation object. Null if none matches.
        </member>
        <member name="P:Org.BouncyCastle.Cms.SignerInformationStore.Count">
            <summary>The number of signers in the collection.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformationStore.GetSigners">
            <returns>An ICollection of all signers in the collection</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformationStore.GetSigners(Org.BouncyCastle.Cms.SignerID)">
             Return possible empty collection with signers matching the passed in SignerID
            
             @param selector a signer id to select against.
             @return a collection of SignerInformation objects.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.DHBasicAgreement">
            a Diffie-Hellman key agreement class.
            <p>
            note: This is only the basic algorithm, it doesn't take advantage of
            long term public keys if they are available. See the DHAgreement class
            for a "better" implementation.</p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.DHBasicAgreement.CalculateAgreement(Org.BouncyCastle.Crypto.ICipherParameters)">
            given a short term public key from a given party calculate the next
            message in the agreement sequence.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.ECDHBasicAgreement">
             P1363 7.2.1 ECSVDP-DH
            
             ECSVDP-DH is Elliptic Curve Secret Value Derivation Primitive,
             Diffie-Hellman version. It is based on the work of [DH76], [Mil86],
             and [Kob87]. This primitive derives a shared secret value from one
             party's private key and another party's public key, where both have
             the same set of EC domain parameters. If two parties correctly
             execute this primitive, they will produce the same output. This
             primitive can be invoked by a scheme to derive a shared secret key;
             specifically, it may be used with the schemes ECKAS-DH1 and
             DL/ECKAS-DH2. It assumes that the input keys are valid (see also
             Section 7.2.2).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.ECDHCBasicAgreement">
             P1363 7.2.2 ECSVDP-DHC
            
             ECSVDP-DHC is Elliptic Curve Secret Value Derivation Primitive,
             Diffie-Hellman version with cofactor multiplication. It is based on
             the work of [DH76], [Mil86], [Kob87], [LMQ98] and [Kal98a]. This
             primitive derives a shared secret value from one party's private key
             and another party's public key, where both have the same set of EC
             domain parameters. If two parties correctly execute this primitive,
             they will produce the same output. This primitive can be invoked by a
             scheme to derive a shared secret key; specifically, it may be used
             with the schemes ECKAS-DH1 and DL/ECKAS-DH2. It does not assume the
             validity of the input public key (see also Section 7.2.1).
             <p>
             Note: As stated P1363 compatibility mode with ECDH can be preset, and
             in this case the implementation doesn't have a ECDH compatibility mode
             (if you want that just use ECDHBasicAgreement and note they both implement
             BasicAgreement!).</p>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.Kdf.ECDHKekGenerator">
            X9.63 based key derivation function for ECDH CMS.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.AsymmetricCipherKeyPair">
            a holding class for public/private parameter pairs.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.AsymmetricCipherKeyPair.#ctor(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
             basic constructor.
            
             @param publicParam a public key parameters object.
             @param privateParam the corresponding private key parameters.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.AsymmetricCipherKeyPair.Public">
             return the public key parameters.
            
             @return the public key parameters.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.AsymmetricCipherKeyPair.Private">
             return the private key parameters.
            
             @return the private key parameters.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher">
            The AEAD block ciphers already handle buffering internally, so this class
            just takes care of implementing IBufferedCipher methods.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the cipher.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.GetBlockSize">
             return the blocksize for the underlying cipher.
            
             @return the blocksize for the underlying cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.GetOutputSize(System.Int32)">
             return the size of the output buffer required for an update plus a
             doFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update and doFinal
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if necessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param len the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output, or the input is not block size aligned and should be.
             @exception InvalidOperationException if the underlying cipher is not
             initialised.
             @exception InvalidCipherTextException if padding is expected and not found.
             @exception DataLengthException if the input is not block size
             aligned.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.Reset">
            Reset the buffer and cipher. After resetting the object is in the same
            state as it was after the last init (if there was one).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.BufferedAeadCipher">
            The AEAD ciphers already handle buffering internally, so this class
            just takes care of implementing IBufferedCipher methods.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the cipher.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadCipher.GetBlockSize">
             return the blocksize for the underlying cipher.
            
             @return the blocksize for the underlying cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadCipher.GetOutputSize(System.Int32)">
             return the size of the output buffer required for an update plus a
             doFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update and doFinal
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if necessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param len the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output, or the input is not block size aligned and should be.
             @exception InvalidOperationException if the underlying cipher is not
             initialised.
             @exception InvalidCipherTextException if padding is expected and not found.
             @exception DataLengthException if the input is not block size
             aligned.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadCipher.Reset">
            Reset the buffer and cipher. After resetting the object is in the same
            state as it was after the last init (if there was one).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher">
            a buffer wrapper for an asymmetric block cipher, allowing input
            to be accumulated in a piecemeal fashion until final processing.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher)">
             base constructor.
            
             @param cipher the cipher this buffering object wraps.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher.GetBufferPosition">
             return the amount of data sitting in the buffer.
            
             @return the amount of data sitting in the buffer.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the buffer and the underlying cipher.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher.DoFinal">
             process the contents of the buffer using the underlying
             cipher.
            
             @return the result of the encryption/decryption process on the
             buffer.
             @exception InvalidCipherTextException if we are given a garbage block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher.Reset">
            <summary>Reset the buffer</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.BufferedBlockCipher">
            A wrapper class that allows block ciphers to be used to process data in
            a piecemeal fashion. The BufferedBlockCipher outputs a block only when the
            buffer is full and more data is being added, or on a doFinal.
            <p>
            Note: in the case where the underlying cipher is either a CFB cipher or an
            OFB one the last block may not be a multiple of the block size.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.#ctor">
            constructor for subclasses
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.#ctor(Org.BouncyCastle.Crypto.Modes.IBlockCipherMode)">
             Create a buffered block cipher without padding.
            
             @param cipher the underlying block cipher this buffering object wraps.
             false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the cipher.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.GetBlockSize">
             return the blocksize for the underlying cipher.
            
             @return the blocksize for the underlying cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.GetOutputSize(System.Int32)">
             return the size of the output buffer required for an update plus a
             doFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update and doFinal
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if necessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param len the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output, or the input is not block size aligned and should be.
             @exception InvalidOperationException if the underlying cipher is not
             initialised.
             @exception InvalidCipherTextException if padding is expected and not found.
             @exception DataLengthException if the input is not block size
             aligned.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.Reset">
            Reset the buffer and cipher. After resetting the object is in the same
            state as it was after the last init (if there was one).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.CipherKeyGenerator">
            The base class for symmetric, or secret, cipher key generators.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.CipherKeyGenerator.Init(Org.BouncyCastle.Crypto.KeyGenerationParameters)">
             initialise the key generator.
            
             @param param the parameters to be used for key generation
        </member>
        <member name="M:Org.BouncyCastle.Crypto.CipherKeyGenerator.GenerateKey">
             Generate a secret key.
            
             @return a byte array containing the key value.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.DataLengthException">
            <summary>This exception is thrown if a buffer that is meant to have output copied into it turns out to be too
            short, or if we've been given insufficient input.</summary>
            <remarks>
            In general this exception will get thrown rather than an <see cref="T:System.IndexOutOfRangeException"/>.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Blake2bDigest">
            Implementation of the cryptographic hash function Blake2b.
            <p/>
            Blake2b offers a built-in keying mechanism to be used directly
            for authentication ("Prefix-MAC") rather than a HMAC construction.
            <p/>
            Blake2b offers a built-in support for a salt for randomized hashing
            and a personal string for defining a unique hash function for each application.
            <p/>
            BLAKE2b is optimized for 64-bit platforms and produces digests of any size
            between 1 and 64 bytes.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake2bDigest.#ctor(System.Int32)">
             Basic sized constructor - size in bits.
            
             @param digestSize size of the digest in bits
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake2bDigest.#ctor(System.Byte[])">
             Blake2b for authentication ("Prefix-MAC mode").
             After calling the doFinal() method, the key will
             remain to be used for further computations of
             this instance.
             The key can be overwritten using the clearKey() method.
            
             @param key A key up to 64 bytes or null
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake2bDigest.#ctor(System.Byte[],System.Int32,System.Byte[],System.Byte[])">
             Blake2b with key, required digest length (in bytes), salt and personalization.
             After calling the doFinal() method, the key, the salt and the personal string
             will remain and might be used for further computations with this instance.
             The key can be overwritten using the clearKey() method, the salt (pepper)
             can be overwritten using the clearSalt() method.
            
             @param key             A key up to 64 bytes or null
             @param digestLength    from 1 up to 64 bytes
             @param salt            16 bytes or null
             @param personalization 16 bytes or null
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake2bDigest.Update(System.Byte)">
             update the message digest with a single byte.
            
             @param b the input byte to be entered.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake2bDigest.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
             update the message digest with a block of bytes.
            
             @param message the byte array containing the data.
             @param offset  the offset into the byte array where the data starts.
             @param len     the length of the data.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake2bDigest.DoFinal(System.Byte[],System.Int32)">
             close the digest, producing the final digest value. The doFinal
             call leaves the digest reset.
             Key, salt and personal string remain.
            
             @param out       the array the digest is to be copied into.
             @param outOffset the offset into the out array the digest is to start at.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake2bDigest.Reset">
            Reset the digest back to it's initial state.
            The key, the salt and the personal string will
            remain for further computations.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Digests.Blake2bDigest.AlgorithmName">
             return the algorithm name
            
             @return the algorithm name
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake2bDigest.GetDigestSize">
             return the size, in bytes, of the digest produced by this message digest.
            
             @return the size, in bytes, of the digest produced by this message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake2bDigest.GetByteLength">
             Return the size in bytes of the internal buffer the digest applies it's compression
             function to.
            
             @return byte length of the digests internal buffer.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake2bDigest.ClearKey">
            Overwrite the key
            if it is no longer used (zeroization)
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake2bDigest.ClearSalt">
            Overwrite the salt (pepper) if it
            is secret and no longer used (zeroization)
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Blake2sDigest">
            Implementation of the cryptographic hash function BLAKE2s.
            <p/>
            BLAKE2s offers a built-in keying mechanism to be used directly
            for authentication ("Prefix-MAC") rather than a HMAC construction.
            <p/>
            BLAKE2s offers a built-in support for a salt for randomized hashing
            and a personal string for defining a unique hash function for each application.
            <p/>
            BLAKE2s is optimized for 32-bit platforms and produces digests of any size
            between 1 and 32 bytes.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake2sDigest.blake2s_IV">
             BLAKE2s Initialization Vector
            
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake2sDigest.blake2s_sigma">
             Message word permutations
            
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake2sDigest.buffer">
            Whenever this buffer overflows, it will be processed in the Compress()
            function. For performance issues, long messages will not use this buffer.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake2sDigest.bufferPos">
             Position of last inserted byte
            
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake2sDigest.internalState">
             Internal state, in the BLAKE2 paper it is called v
            
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake2sDigest.chainValue">
             State vector, in the BLAKE2 paper it is called h
            
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake2sDigest.t0">
             holds least significant bits of counter
            
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake2sDigest.t1">
             holds most significant bits of counter
            
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake2sDigest.f0">
             finalization flag, for last block: ~0
            
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake2sDigest.#ctor">
            BLAKE2s-256 for hashing.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake2sDigest.#ctor(System.Int32)">
             BLAKE2s for hashing.
            
             @param digestBits the desired digest length in bits. Must be a multiple of 8 and less than 256.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake2sDigest.#ctor(System.Byte[])">
             BLAKE2s for authentication ("Prefix-MAC mode").
             <p/>
             After calling the doFinal() method, the key will remain to be used for
             further computations of this instance. The key can be overwritten using
             the clearKey() method.
            
             @param key a key up to 32 bytes or null
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake2sDigest.#ctor(System.Byte[],System.Int32,System.Byte[],System.Byte[])">
             BLAKE2s with key, required digest length, salt and personalization.
             <p/>
             After calling the doFinal() method, the key, the salt and the personal
             string will remain and might be used for further computations with this
             instance. The key can be overwritten using the clearKey() method, the
             salt (pepper) can be overwritten using the clearSalt() method.
            
             @param key             a key up to 32 bytes or null
             @param digestBytes     from 1 up to 32 bytes
             @param salt            8 bytes or null
             @param personalization 8 bytes or null
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake2sDigest.Update(System.Byte)">
             Update the message digest with a single byte.
            
             @param b the input byte to be entered.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake2sDigest.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
             Update the message digest with a block of bytes.
            
             @param message the byte array containing the data.
             @param offset  the offset into the byte array where the data starts.
             @param len     the length of the data.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake2sDigest.DoFinal(System.Byte[],System.Int32)">
             Close the digest, producing the final digest value. The doFinal() call
             leaves the digest reset. Key, salt and personal string remain.
            
             @param out       the array the digest is to be copied into.
             @param outOffset the offset into the out array the digest is to start at.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake2sDigest.Reset">
            Reset the digest back to its initial state. The key, the salt and the
            personal string will remain for further computations.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Digests.Blake2sDigest.AlgorithmName">
             Return the algorithm name.
            
             @return the algorithm name
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake2sDigest.GetDigestSize">
             Return the size in bytes of the digest produced by this message digest.
            
             @return the size in bytes of the digest produced by this message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake2sDigest.GetByteLength">
             Return the size in bytes of the internal buffer the digest applies its
             compression function to.
            
             @return byte length of the digest's internal buffer.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake2sDigest.ClearKey">
            Overwrite the key if it is no longer used (zeroization).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake2sDigest.ClearSalt">
            Overwrite the salt (pepper) if it is secret and no longer used
            (zeroization).
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.ERR_OUTPUTTING">
            Already outputting error.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.NUMWORDS">
            Number of Words.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.ROUNDS">
            Number of Rounds.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.BLOCKLEN">
            Buffer length.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.CHUNKLEN">
            Chunk length.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.CHUNKSTART">
            ChunkStart Flag.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.CHUNKEND">
            ChunkEnd Flag.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.PARENT">
            Parent Flag.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.ROOT">
            Root Flag.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.KEYEDHASH">
            KeyedHash Flag.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.DERIVECONTEXT">
            DeriveContext Flag.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.DERIVEKEY">
            DeriveKey Flag.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.CHAINING0">
            Chaining0 State Locations.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.CHAINING1">
            Chaining1 State Location.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.CHAINING2">
            Chaining2 State Location.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.CHAINING3">
            Chaining3 State Location.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.CHAINING4">
            Chaining4 State Location.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.CHAINING5">
            Chaining5 State Location.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.CHAINING6">
            Chaining6 State Location.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.CHAINING7">
            Chaining7 State Location.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.IV0">
            IV0 State Locations.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.IV1">
            IV1 State Location.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.IV2">
            IV2 State Location.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.IV3">
            IV3 State Location.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.COUNT0">
            Count0 State Location.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.COUNT1">
            Count1 State Location.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.DATALEN">
            DataLen State Location.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.FLAGS">
            Flags State Location.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.SIGMA">
            Message word permutations.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.IV">
            Blake3 Initialization Vector.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.m_theBuffer">
            The byte input/output buffer.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.m_theK">
            The key.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.m_theChaining">
            The chaining value.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.m_theV">
            The state.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.m_theM">
            The message Buffer.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.m_theIndices">
            The indices.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.m_theStack">
            The chainingStack.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.m_theDigestLen">
            The default digestLength.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.m_outputting">
            Are we outputting?
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.m_outputAvailable">
            How many more bytes can we output?
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.m_theMode">
            The current mode.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.m_theOutputMode">
            The output mode.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.m_theOutputDataLen">
            The output dataLen.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.m_theCounter">
            The block counter.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.m_theCurrBytes">
            The # of bytes in the current block.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Blake3Digest.m_thePos">
            The position of the next byte in the buffer.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake3Digest.#ctor(System.Int32)">
            <param name="pDigestSize">the default digest size (in bits)</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake3Digest.#ctor(Org.BouncyCastle.Crypto.Digests.Blake3Digest)">
             Constructor.
            
             @param pSource the source digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake3Digest.Init(Org.BouncyCastle.Crypto.Parameters.Blake3Parameters)">
             Initialise.
            
             @param pParams the parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake3Digest.CompressBlock(System.Byte[],System.Int32)">
             Compress next block of the message.
            
             @param pMessage the message buffer
             @param pMsgPos  the position within the message buffer
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake3Digest.InitM(System.Byte[],System.Int32)">
             Initialise M from message.
            
             @param pMessage the source message
             @param pMsgPos  the message position
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake3Digest.AdjustStack">
            Adjust the stack.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake3Digest.CompressFinalBlock(System.Int32)">
             Compress final block.
            
             @param pDataLen the data length
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake3Digest.ProcessStack">
            Process the stack.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake3Digest.Compress">
            Perform compression.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake3Digest.PerformRound">
            Perform a round.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake3Digest.AdjustChaining">
            Adjust Chaining after compression.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake3Digest.MixG(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
             Mix function G.
            
             @param msgIdx the message index
             @param posA   position A in V
             @param posB   position B in V
             @param posC   position C in V
             @param posD   poistion D in V
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake3Digest.InitIndices">
            initialise the indices.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake3Digest.PermuteIndices">
            PermuteIndices.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake3Digest.InitNullKey">
            Initialise null key.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake3Digest.InitKey(System.Byte[])">
             Initialise key.
            
             @param pKey the keyBytes
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake3Digest.InitKeyFromContext">
            Initialise key from context.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake3Digest.InitChunkBlock(System.Int32,System.Boolean)">
             Initialise chunk block.
            
             @param pDataLen the dataLength
             @param pFinal   is this the final chunk?
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake3Digest.InitParentBlock">
            Initialise parent block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake3Digest.NextOutputBlock">
            Initialise output block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake3Digest.IncrementBlockCount">
            IncrementBlockCount.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake3Digest.ResetBlockCount">
            ResetBlockCount.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Blake3Digest.SetRoot">
            Set root indication.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Dstu7564Digest">
            implementation of Ukrainian DSTU 7564 hash function
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.GeneralDigest">
            base implementation of MD4 family style digest as outlined in
            "Handbook of Applied Cryptography", pages 344 - 347.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Gost3411Digest">
            implementation of GOST R 34.11-94
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Gost3411Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Gost3411Digest.#ctor(System.Byte[])">
            Constructor to allow use of a particular sbox with GOST28147
            @see GOST28147Engine#getSBox(String)
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Gost3411Digest.#ctor(Org.BouncyCastle.Crypto.Digests.Gost3411Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Gost3411Digest.C2">
            reset the chaining variables to the IV values.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.KeccakDigest">
            <summary>
            Implementation of Keccak based on following KeccakNISTInterface.c from http://keccak.noekeon.org/
            </summary>
            <remarks>
            Following the naming conventions used in the C source code to enable easy review of the implementation.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.KeccakDigest.GetByteLength">
             Return the size of block that the compression function is applied to in bytes.
            
             @return internal byte length of a block.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.LongDigest">
            Base class for SHA-384 and SHA-512.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.LongDigest.#ctor">
            Constructor for variable length word
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.LongDigest.#ctor(Org.BouncyCastle.Crypto.Digests.LongDigest)">
            Copy constructor.  We are using copy constructors in place
            of the object.Clone() interface as this interface is not
            supported by J2ME.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.LongDigest.AdjustByteCounts">
            adjust the byte counts so that byteCount2 represents the
            upper long (less 3 bits) word of the byte count.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.MD2Digest">
            implementation of MD2
            as outlined in RFC1319 by B.Kaliski from RSA Laboratories April 1992
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Digests.MD2Digest.AlgorithmName">
             return the algorithm name
            
             @return the algorithm name
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD2Digest.DoFinal(System.Byte[],System.Int32)">
             Close the digest, producing the final digest value. The doFinal
             call leaves the digest reset.
            
             @param out the array the digest is to be copied into.
             @param outOff the offset into the out array the digest is to start at.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD2Digest.Reset">
            reset the digest back to it's initial state.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD2Digest.Update(System.Byte)">
             update the message digest with a single byte.
            
             @param in the input byte to be entered.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD2Digest.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
             update the message digest with a block of bytes.
            
             @param in the byte array containing the data.
             @param inOff the offset into the byte array where the data starts.
             @param len the length of the data.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.MD4Digest">
            implementation of MD4 as RFC 1320 by R. Rivest, MIT Laboratory for
            Computer Science and RSA Data Security, Inc.
            <p>
            <b>NOTE</b>: This algorithm is only included for backwards compatibility
            with legacy applications, it's not secure, don't use it for anything new!</p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD4Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD4Digest.#ctor(Org.BouncyCastle.Crypto.Digests.MD4Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD4Digest.Reset">
            reset the chaining variables to the IV values.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.MD5Digest">
            implementation of MD5 as outlined in "Handbook of Applied Cryptography", pages 346 - 347.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD5Digest.#ctor(Org.BouncyCastle.Crypto.Digests.MD5Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD5Digest.Reset">
            reset the chaining variables to the IV values.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.RipeMD128Digest">
            implementation of RipeMD128
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD128Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD128Digest.#ctor(Org.BouncyCastle.Crypto.Digests.RipeMD128Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD128Digest.Reset">
            reset the chaining variables to the IV values.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.RipeMD160Digest">
            implementation of RipeMD see,
            http://www.esat.kuleuven.ac.be/~bosselae/ripemd160.html
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD160Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD160Digest.#ctor(Org.BouncyCastle.Crypto.Digests.RipeMD160Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD160Digest.Reset">
            reset the chaining variables to the IV values.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.RipeMD256Digest">
            <remarks>
            <p>Implementation of RipeMD256.</p>
            <p><b>Note:</b> this algorithm offers the same level of security as RipeMD128.</p>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD256Digest.#ctor">
            <summary> Standard constructor</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD256Digest.#ctor(Org.BouncyCastle.Crypto.Digests.RipeMD256Digest)">
            <summary> Copy constructor.  This will copy the state of the provided
            message digest.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD256Digest.Reset">
            <summary> reset the chaining variables to the IV values.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.RipeMD320Digest">
            <remarks>
            <p>Implementation of RipeMD 320.</p>
            <p><b>Note:</b> this algorithm offers the same level of security as RipeMD160.</p>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD320Digest.#ctor">
            <summary> Standard constructor</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD320Digest.#ctor(Org.BouncyCastle.Crypto.Digests.RipeMD320Digest)">
            <summary> Copy constructor.  This will copy the state of the provided
            message digest.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD320Digest.Reset">
            <summary> reset the chaining variables to the IV values.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Sha1Digest">
             implementation of SHA-1 as outlined in "Handbook of Applied Cryptography", pages 346 - 349.
            
             It is interesting to ponder why the, apart from the extra IV, the other difference here from MD5
             is the "endianness" of the word processing!
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha1Digest.#ctor(Org.BouncyCastle.Crypto.Digests.Sha1Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha1Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Sha224Digest">
            SHA-224 as described in RFC 3874
            <pre>
                    block  word  digest
            SHA-1   512    32    160
            SHA-224 512    32    224
            SHA-256 512    32    256
            SHA-384 1024   64    384
            SHA-512 1024   64    512
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha224Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha224Digest.#ctor(Org.BouncyCastle.Crypto.Digests.Sha224Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha224Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Sha256Digest">
             Draft FIPS 180-2 implementation of SHA-256. <b>Note:</b> As this is
             based on a draft this implementation is subject to change.
            
             <pre>
                     block  word  digest
             SHA-1   512    32    160
             SHA-256 512    32    256
             SHA-384 1024   64    384
             SHA-512 1024   64    512
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha256Digest.#ctor(Org.BouncyCastle.Crypto.Digests.Sha256Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha256Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Sha384Digest">
             Draft FIPS 180-2 implementation of SHA-384. <b>Note:</b> As this is
             based on a draft this implementation is subject to change.
            
             <pre>
                     block  word  digest
             SHA-1   512    32    160
             SHA-256 512    32    256
             SHA-384 1024   64    384
             SHA-512 1024   64    512
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha384Digest.#ctor(Org.BouncyCastle.Crypto.Digests.Sha384Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha384Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Sha3Digest">
            <summary>
            Implementation of SHA-3 based on following KeccakNISTInterface.c from http://keccak.noekeon.org/
            </summary>
            <remarks>
            Following the naming conventions used in the C source code to enable easy review of the implementation.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Sha512Digest">
             Draft FIPS 180-2 implementation of SHA-512. <b>Note:</b> As this is
             based on a draft this implementation is subject to change.
            
             <pre>
                     block  word  digest
             SHA-1   512    32    160
             SHA-256 512    32    256
             SHA-384 1024   64    384
             SHA-512 1024   64    512
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha512Digest.#ctor(Org.BouncyCastle.Crypto.Digests.Sha512Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha512Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Sha512tDigest">
            FIPS 180-4 implementation of SHA-512/t
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha512tDigest.#ctor(System.Int32)">
            Standard constructor
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha512tDigest.#ctor(Org.BouncyCastle.Crypto.Digests.Sha512tDigest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha512tDigest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.ShakeDigest">
            <summary>
            Implementation of SHAKE based on following KeccakNISTInterface.c from http://keccak.noekeon.org/
            </summary>
            <remarks>
            Following the naming conventions used in the C source code to enable easy review of the implementation.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.SM3Digest">
            <summary>
            Implementation of Chinese SM3 digest as described at
            http://tools.ietf.org/html/draft-shen-sm3-hash-00
            and at .... ( Chinese PDF )
            </summary>
            <remarks>
            The specification says "process a bit stream",
            but this is written to process bytes in blocks of 4,
            meaning this will process 32-bit word groups.
            But so do also most other digest specifications,
            including the SHA-256 which was a origin for
            this specification.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.SM3Digest.#ctor">
            <summary>
            Standard constructor
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.SM3Digest.#ctor(Org.BouncyCastle.Crypto.Digests.SM3Digest)">
            <summary>
            Copy constructor.  This will copy the state of the provided
            message digest.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.SM3Digest.Reset">
            <summary>
            reset the chaining variables
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.TigerDigest">
            implementation of Tiger based on:
            <a href="http://www.cs.technion.ac.il/~biham/Reports/Tiger">
             http://www.cs.technion.ac.il/~biham/Reports/Tiger</a>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.TigerDigest.#ctor">
            Standard constructor
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.TigerDigest.#ctor(Org.BouncyCastle.Crypto.Digests.TigerDigest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.TigerDigest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.WhirlpoolDigest">
            Implementation of WhirlpoolDigest, based on Java source published by Barreto and Rijmen.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.WhirlpoolDigest.#ctor(Org.BouncyCastle.Crypto.Digests.WhirlpoolDigest)">
            Copy constructor. This will copy the state of the provided message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.WhirlpoolDigest.Reset">
            Reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.EC.CustomNamedCurves">
            <summary>Elliptic curve registry for various customized curve implementations.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.EC.CustomNamedCurves.GetByName(System.String)">
            <summary>Look up the <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.EC.CustomNamedCurves.GetByNameLazy(System.String)">
            <summary>Look up an <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given name.</summary>
            <remarks>
            Allows accessing the <see cref="T:Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of the
            full <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.EC.CustomNamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/> for the curve with the given
            <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.EC.CustomNamedCurves.GetByOidLazy(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up an <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParametersHolder"/> for the curve with the given
            <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <remarks>
            Allows accessing the <see cref="T:Org.BouncyCastle.Math.EC.ECCurve">curve</see> without necessarily triggering the creation of the
            full <see cref="T:Org.BouncyCastle.Asn1.X9.X9ECParameters"/>.
            </remarks>
            <param name="oid">The <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.EC.CustomNamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Look up the name of the curve with the given <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see>.</summary>
            <param name="oid">The <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> for the curve.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.EC.CustomNamedCurves.GetOid(System.String)">
            <summary>Look up the <see cref="T:Org.BouncyCastle.Asn1.DerObjectIdentifier">OID</see> of the curve with the given name.</summary>
            <param name="name">The name of the curve.</param>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.EC.CustomNamedCurves.Names">
            <summary>Enumerate the available curve names in this registry.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding">
            ISO 9796-1 padding. Note in the light of recent results you should
            only use this with RSA (rather than the "simpler" Rabin keys) and you
            should never use it with anything other than a hash (ie. even if the
            message is small don't sign the message, sign it's hash) or some "random"
            value. See your favorite search engine for details.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding.GetInputBlockSize">
            return the input block size. The largest message we can process
            is (key_size_in_bits + 3)/16, which in our world comes to
            key_size_in_bytes / 2.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding.GetOutputBlockSize">
            return the maximum possible size for the output.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding.SetPadBits(System.Int32)">
            set the number of bits in the next message to be treated as
            pad bits.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding.GetPadBits">
            retrieve the number of pad bits in the last decoded message.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding.DecodeBlock(System.Byte[],System.Int32,System.Int32)">
            @exception InvalidCipherTextException if the decrypted block is not a valid ISO 9796 bit string
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Encodings.OaepEncoding">
            Optimal Asymmetric Encryption Padding (OAEP) - see PKCS 1 V 2.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.OaepEncoding.DecodeBlock(System.Byte[],System.Int32,System.Int32)">
            @exception InvalidCipherTextException if the decrypted block turns out to
            be badly formatted.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.OaepEncoding.MaskGeneratorFunction1(System.Byte[],System.Int32,System.Int32,System.Int32)">
            mask generator function, as described in PKCS1v2.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding">
            this does your basic Pkcs 1 v1.5 padding - whether or not you should be using this
            depends on your application - see Pkcs1 Version 2 for details.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.StrictLengthEnabledProperty">
            some providers fail to include the leading zero in PKCS1 encoded blocks. If you need to
            work with one of these set the system property Org.BouncyCastle.Pkcs1.Strict to false.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.StrictLengthEnabled">
            The same effect can be achieved by setting the static property directly
            <p>
            The static property is checked during construction of the encoding object, it is set to
            true by default.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher)">
             Basic constructor.
            
             @param cipher
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,System.Int32)">
            Constructor for decryption with a fixed plaintext length.
            
            @param cipher The cipher to use for cryptographic operation.
            @param pLen Length of the expected plaintext.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,System.Byte[])">
            Constructor for decryption with a fixed plaintext length and a fallback
            value that is returned, if the padding is incorrect.
            
            @param cipher
                       The cipher to use for cryptographic operation.
            @param fallback
                       The fallback value, we don't to a arraycopy here.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.CheckPkcs1Encoding(System.Byte[],System.Int32)">
            Checks if the argument is a correctly PKCS#1.5 encoded Plaintext
            for encryption.
            
            @param encoded The Plaintext.
            @param pLen Expected length of the plaintext.
            @return Either 0, if the encoding is correct, or -1, if it is incorrect.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.DecodeBlockOrRandom(System.Byte[],System.Int32,System.Int32)">
            Decode PKCS#1.5 encoding, and return a random value if the padding is not correct.
            
            @param in The encrypted block.
            @param inOff Offset in the encrypted block.
            @param inLen Length of the encrypted block.
            @param pLen Length of the desired output.
            @return The plaintext without padding, or a random value if the padding was incorrect.
            @throws InvalidCipherTextException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.DecodeBlock(System.Byte[],System.Int32,System.Int32)">
            @exception InvalidCipherTextException if the decrypted block is not in Pkcs1 format.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.AesEngine">
             an implementation of the AES (Rijndael), from FIPS-197.
             <p>
             For further details see: <a href="http://csrc.nist.gov/encryption/aes/">http://csrc.nist.gov/encryption/aes/</a>.
            
             This implementation is based on optimizations from Dr. Brian Gladman's paper and C code at
             <a href="http://fp.gladman.plus.com/cryptography_technology/rijndael/">http://fp.gladman.plus.com/cryptography_technology/rijndael/</a>
            
             There are three levels of tradeoff of speed vs memory
             Because java has no preprocessor, they are written as three separate classes from which to choose
            
             The fastest uses 8Kbytes of static tables to precompute round calculations, 4 256 word tables for encryption
             and 4 for decryption.
            
             The middle performance version uses only one 256 word table for each, for a total of 2Kbytes,
             adding 12 rotate operations per round to compute the values contained in the other tables from
             the contents of the first.
            
             The slowest version uses no static tables at all and computes the values in each round.
             </p>
             <p>
             This file contains the middle performance version with 2Kbytes of static tables for round precomputation.
             </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.AesEngine.GenerateWorkingKey(System.Byte[],System.Boolean)">
            Calculate the necessary round keys
            The number of calculations depends on key size and block size
            AES specified a fixed block size of 128 bits and key sizes 128/192/256 bits
            This code is written assuming those are the only possible values
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.AesEngine.#ctor">
            default constructor - 128 bit block size.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.AesEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise an AES cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.AesWrapEngine">
            <remarks>
            An implementation of the AES Key Wrapper from the NIST Key Wrap Specification.
            <p/>
            For further details see: <a href="http://csrc.nist.gov/encryption/kms/key-wrap.pdf">http://csrc.nist.gov/encryption/kms/key-wrap.pdf</a>.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.AesWrapEngine.#ctor">
            <summary>
            Create a regular AesWrapEngine specifying the encrypt for wrapping, decrypt for unwrapping.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.AesWrapEngine.#ctor(System.Boolean)">
            <summary>
            Create an AESWrapEngine where the underlying cipher is (optionally) set to decrypt for wrapping, encrypt for
            unwrapping.
            </summary>
            <param name="useReverseDirection">true if underlying cipher should be used in decryption mode, false
            otherwise.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.AriaEngine">
            RFC 5794.
            
            ARIA is a 128-bit block cipher with 128-, 192-, and 256-bit keys.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.BlowfishEngine">
            A class that provides Blowfish key encryption operations,
            such as encoding data and generating keys.
            All the algorithms herein are from Applied Cryptography
            and implement a simplified cryptography interface.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.BlowfishEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a Blowfish cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.BlowfishEngine.ProcessTable(System.UInt32,System.UInt32,System.UInt32[])">
            apply the encryption cycle to each value pair in the table.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.CamelliaEngine">
            Camellia - based on RFC 3713.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.CamelliaWrapEngine">
            <remarks>
            An implementation of the Camellia key wrapper based on RFC 3657/RFC 3394.
            <p/>
            For further details see: <a href="http://www.ietf.org/rfc/rfc3657.txt">http://www.ietf.org/rfc/rfc3657.txt</a>.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.Cast5Engine">
             A class that provides CAST key encryption operations,
             such as encoding data and generating keys.
            
             All the algorithms herein are from the Internet RFC's
            
             RFC2144 - Cast5 (64bit block, 40-128bit key)
             RFC2612 - CAST6 (128bit block, 128-256bit key)
            
             and implement a simplified cryptography interface.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast5Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a CAST cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast5Engine.F1(System.UInt32,System.UInt32,System.Int32)">
             The first of the three processing functions for the
             encryption and decryption.
            
             @param D            the input to be processed
             @param Kmi        the mask to be used from Km[n]
             @param Kri        the rotation value to be used
            
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast5Engine.F2(System.UInt32,System.UInt32,System.Int32)">
             The second of the three processing functions for the
             encryption and decryption.
            
             @param D            the input to be processed
             @param Kmi        the mask to be used from Km[n]
             @param Kri        the rotation value to be used
            
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast5Engine.F3(System.UInt32,System.UInt32,System.Int32)">
             The third of the three processing functions for the
             encryption and decryption.
            
             @param D            the input to be processed
             @param Kmi        the mask to be used from Km[n]
             @param Kri        the rotation value to be used
            
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast5Engine.CAST_Encipher(System.UInt32,System.UInt32,System.UInt32[])">
             Does the 16 rounds to encrypt the block.
            
             @param L0    the LH-32bits of the plaintext block
             @param R0    the RH-32bits of the plaintext block
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.Cast6Engine">
             A class that provides CAST6 key encryption operations,
             such as encoding data and generating keys.
            
             All the algorithms herein are from the Internet RFC
            
             RFC2612 - CAST6 (128bit block, 128-256bit key)
            
             and implement a simplified cryptography interface.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast6Engine.CAST_Encipher(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32[])">
             Does the 12 quad rounds rounds to encrypt the block.
            
             @param A    the 00-31  bits of the plaintext block
             @param B    the 32-63  bits of the plaintext block
             @param C    the 64-95  bits of the plaintext block
             @param D    the 96-127 bits of the plaintext block
             @param result the resulting ciphertext
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast6Engine.CAST_Decipher(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32[])">
             Does the 12 quad rounds rounds to decrypt the block.
            
             @param A    the 00-31  bits of the ciphertext block
             @param B    the 32-63  bits of the ciphertext block
             @param C    the 64-95  bits of the ciphertext block
             @param D    the 96-127 bits of the ciphertext block
             @param result the resulting plaintext
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.ChaCha7539Engine">
            <summary>
            Implementation of Daniel J. Bernstein's ChaCha stream cipher.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ChaCha7539Engine.#ctor">
            <summary>
            Creates a 20 rounds ChaCha engine.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.ChaChaEngine">
            <summary>
            Implementation of Daniel J. Bernstein's ChaCha stream cipher.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ChaChaEngine.#ctor">
            <summary>
            Creates a 20 rounds ChaCha engine.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ChaChaEngine.#ctor(System.Int32)">
            <summary>
            Creates a ChaCha engine with a specific number of rounds.
            </summary>
            <param name="rounds">the number of rounds (must be an even number).</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.DesEdeEngine">
            <remarks>A class that provides a basic DESede (or Triple DES) engine.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEdeEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a DESede cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine">
                * Wrap keys according to
                * <a href="http://www.ietf.org/internet-drafts/draft-ietf-smime-key-wrap-01.txt">
                * draft-ietf-smime-key-wrap-01.txt</a>.
                * <p>
                * Note:
                * <ul>
                * <li>this is based on a draft, and as such is subject to change - don't use this class for anything requiring long term storage.</li>
                * <li>if you are using this to wrap triple-des keys you need to set the
                * parity bits on the key and, if it's a two-key triple-des key, pad it
                * yourself.</li>
                * </ul>
            	* </p>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.engine">
            Field engine 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.param">
            Field param 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.paramPlusIV">
            Field paramPlusIV 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.iv">
            Field iv 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.forWrapping">
            Field forWrapping 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.IV2">
            Field IV2           
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Method init
            
             @param forWrapping
             @param param
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.AlgorithmName">
             Method GetAlgorithmName
            
             @return
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.Wrap(System.Byte[],System.Int32,System.Int32)">
             Method wrap
            
             @param in
             @param inOff
             @param inLen
             @return
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.Unwrap(System.Byte[],System.Int32,System.Int32)">
             Method unwrap
            
             @param in
             @param inOff
             @param inLen
             @return
             @throws InvalidCipherTextException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.CalculateCmsKeyChecksum(System.Byte[])">
             Some key wrap algorithms make use of the Key Checksum defined
             in CMS [CMS-Algorithms]. This is used to provide an integrity
             check value for the key being wrapped. The algorithm is
            
             - Compute the 20 octet SHA-1 hash on the key being wrapped.
             - Use the first 8 octets of this hash as the checksum value.
            
             @param key
             @return
             @throws Exception
             @see http://www.w3.org/TR/xmlenc-core/#sec-CMSKeyChecksum
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.CheckCmsKeyChecksum(System.Byte[],System.Byte[])">
            @param key
            @param checksum
            @return
            @see http://www.w3.org/TR/xmlenc-core/#sec-CMSKeyChecksum
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.DesEngine">
            <remarks>A class that provides a basic DES engine.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a DES cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.DesEngine.bytebit">
            what follows is mainly taken from "Applied Cryptography", by
            Bruce Schneier, however it also bears great resemblance to Richard
            Outerbridge's D3DES...
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEngine.GenerateWorkingKey(System.Boolean,System.Byte[])">
             Generate an integer based working key based on our secret key
             and what we processing we are planning to do.
            
             Acknowledgements for this routine go to James Gillogly and Phil Karn.
                     (whoever, and wherever they are!).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.ElGamalEngine">
            this does your basic ElGamal algorithm.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ElGamalEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the ElGamal engine.
            
             @param forEncryption true if we are encrypting, false otherwise.
             @param param the necessary ElGamal key parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ElGamalEngine.GetInputBlockSize">
             Return the maximum size for an input block to this engine.
             For ElGamal this is always one byte less than the size of P on
             encryption, and twice the length as the size of P on decryption.
            
             @return maximum size for an input block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ElGamalEngine.GetOutputBlockSize">
             Return the maximum size for an output block to this engine.
             For ElGamal this is always one byte less than the size of P on
             decryption, and twice the length as the size of P on encryption.
            
             @return maximum size for an output block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ElGamalEngine.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
             Process a single block using the basic ElGamal algorithm.
            
             @param in the input array.
             @param inOff the offset into the input buffer where the data starts.
             @param length the length of the data to be processed.
             @return the result of the ElGamal process.
             @exception DataLengthException the input block is too large.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.Gost28147Engine">
            implementation of GOST 28147-89
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Gost28147Engine.#ctor">
            standard constructor.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Gost28147Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise an Gost28147 cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Gost28147Engine.GetSBox(System.String)">
            Return the S-Box associated with SBoxName
            @param sBoxName name of the S-Box
            @return byte array representing the S-Box
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.HC128Engine">
             HC-128 is a software-efficient stream cipher created by Hongjun Wu. It
             generates keystream from a 128-bit secret key and a 128-bit initialization
             vector.
             <p>
             http://www.ecrypt.eu.org/stream/p3ciphers/hc/hc128_p3.pdf
             </p><p>
             It is a third phase candidate in the eStream contest, and is patent-free.
             No attacks are known as of today (April 2007). See
            
             http://www.ecrypt.eu.org/stream/hcp3.html
             </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.HC128Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise a HC-128 cipher.
            
             @param forEncryption whether or not we are for encryption. Irrelevant, as
                                  encryption and decryption are the same.
             @param params        the parameters required to set up the cipher.
             @throws ArgumentException if the params argument is
                                              inappropriate (ie. the key is not 128 bit long).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.HC256Engine">
            HC-256 is a software-efficient stream cipher created by Hongjun Wu. It 
            generates keystream from a 256-bit secret key and a 256-bit initialization 
            vector.
            <p>
            http://www.ecrypt.eu.org/stream/p3ciphers/hc/hc256_p3.pdf
            </p><p>
            Its brother, HC-128, is a third phase candidate in the eStream contest.
            The algorithm is patent-free. No attacks are known as of today (April 2007). 
            See
            
            http://www.ecrypt.eu.org/stream/hcp3.html
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.HC256Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise a HC-256 cipher.
            
             @param forEncryption whether or not we are for encryption. Irrelevant, as
                                  encryption and decryption are the same.
             @param params        the parameters required to set up the cipher.
             @throws ArgumentException if the params argument is
                                              inappropriate (ie. the key is not 256 bit long).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.IdeaEngine">
            A class that provides a basic International Data Encryption Algorithm (IDEA) engine.
            <p>
            This implementation is based on the "HOWTO: INTERNATIONAL DATA ENCRYPTION ALGORITHM"
            implementation summary by Fauzan Mirza (F.U.Mirza@sheffield.ac.uk). (barring 1 typo at the
            end of the MulInv function!).
            </p>
            <p>
            It can be found at ftp://ftp.funet.fi/pub/crypt/cryptography/symmetric/idea/
            </p>
            <p>
            Note: This algorithm was patented in the USA, Japan and Europe. These patents expired in 2011/2012.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IdeaEngine.#ctor">
            standard constructor.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IdeaEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise an IDEA cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IdeaEngine.Mul(System.Int32,System.Int32)">
             return x = x * y where the multiplication is done modulo
             65537 (0x10001) (as defined in the IDEA specification) and
             a zero input is taken to be 65536 (0x10000).
            
             @param x the x value
             @param y the y value
             @return x = x * y
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IdeaEngine.ExpandKey(System.Byte[])">
            The following function is used to expand the user key to the encryption
            subkey. The first 16 bytes are the user key, and the rest of the subkey
            is calculated by rotating the previous 16 bytes by 25 bits to the left,
            and so on until the subkey is completed.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IdeaEngine.MulInv(System.Int32)">
            This function computes multiplicative inverse using Euclid's Greatest
            Common Divisor algorithm. Zero and one are self inverse.
            <p>
            i.e. x * MulInv(x) == 1 (modulo BASE)
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IdeaEngine.AddInv(System.Int32)">
            Return the additive inverse of x.
            <p>
            i.e. x + AddInv(x) == 0
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IdeaEngine.InvertKey(System.Int32[])">
            The function to invert the encryption subkey to the decryption subkey.
            It also involves the multiplicative inverse and the additive inverse functions.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.IesEngine">
            support class for constructing intergrated encryption ciphers
            for doing basic message exchanges on top of key agreement ciphers
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IesEngine.#ctor(Org.BouncyCastle.Crypto.IBasicAgreement,Org.BouncyCastle.Crypto.IDerivationFunction,Org.BouncyCastle.Crypto.IMac)">
             set up for use with stream mode, where the key derivation function
             is used to provide a stream of bytes to xor with the message.
            
             @param agree the key agreement used as the basis for the encryption
             @param kdf the key derivation function used for byte generation
             @param mac the message authentication code generator for the message
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IesEngine.#ctor(Org.BouncyCastle.Crypto.IBasicAgreement,Org.BouncyCastle.Crypto.IDerivationFunction,Org.BouncyCastle.Crypto.IMac,Org.BouncyCastle.Crypto.BufferedBlockCipher)">
             set up for use in conjunction with a block cipher to handle the
             message.
            
             @param agree the key agreement used as the basis for the encryption
             @param kdf the key derivation function used for byte generation
             @param mac the message authentication code generator for the message
             @param cipher the cipher to used for encrypting the message
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IesEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters,Org.BouncyCastle.Crypto.ICipherParameters,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the encryptor.
            
             @param forEncryption whether or not this is encryption/decryption.
             @param privParam our private key parameters
             @param pubParam the recipient's/sender's public key parameters
             @param param encoding and derivation parameters.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.NoekeonEngine">
            A Noekeon engine, using direct-key mode.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.NoekeonEngine.#ctor">
            Create an instance of the Noekeon encryption algorithm
            and set some defaults
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.NoekeonEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise
            
             @param forEncryption whether or not we are for encryption.
             @param params the parameters required to set up the cipher.
             @exception ArgumentException if the params argument is
             inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RC2Engine">
            an implementation of RC2 as described in RFC 2268
                 "A Description of the RC2(r) Encryption Algorithm" R. Rivest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC2Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a RC2 cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC2Engine.RotateWordLeft(System.Int32,System.Int32)">
            return the result rotating the 16 bit number in x left by y
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine">
            Wrap keys according to RFC 3217 - RC2 mechanism
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.engine">
            Field engine 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.parameters">
            Field param 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.paramPlusIV">
            Field paramPlusIV 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.iv">
            Field iv 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.forWrapping">
            Field forWrapping 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.IV2">
            Field IV2           
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Method init
            
             @param forWrapping
             @param param
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.AlgorithmName">
             Method GetAlgorithmName
            
             @return
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.Wrap(System.Byte[],System.Int32,System.Int32)">
             Method wrap
            
             @param in
             @param inOff
             @param inLen
             @return
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.Unwrap(System.Byte[],System.Int32,System.Int32)">
             Method unwrap
            
             @param in
             @param inOff
             @param inLen
             @return
             @throws InvalidCipherTextException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.CalculateCmsKeyChecksum(System.Byte[])">
             Some key wrap algorithms make use of the Key Checksum defined
             in CMS [CMS-Algorithms]. This is used to provide an integrity
             check value for the key being wrapped. The algorithm is
            
             - Compute the 20 octet SHA-1 hash on the key being wrapped.
             - Use the first 8 octets of this hash as the checksum value.
            
             @param key
             @return
             @throws Exception
             @see http://www.w3.org/TR/xmlenc-core/#sec-CMSKeyChecksum
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.CheckCmsKeyChecksum(System.Byte[],System.Byte[])">
            @param key
            @param checksum
            @return
            @see http://www.w3.org/TR/xmlenc-core/#sec-CMSKeyChecksum
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC4Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a RC4 cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RC532Engine">
            The specification for RC5 came from the <code>RC5 Encryption Algorithm</code>
            publication in RSA CryptoBytes, Spring of 1995.
            <em>http://www.rsasecurity.com/rsalabs/cryptobytes</em>.
            <p>
            This implementation has a word size of 32 bits.</p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC532Engine.#ctor">
            Create an instance of the RC5 encryption algorithm
            and set some defaults
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC532Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a RC5-32 cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC532Engine.SetKey(System.Byte[])">
             Re-key the cipher.
            
             @param  key  the key to be used
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RC564Engine">
            The specification for RC5 came from the <code>RC5 Encryption Algorithm</code>
            publication in RSA CryptoBytes, Spring of 1995.
            <em>http://www.rsasecurity.com/rsalabs/cryptobytes</em>.
            <p>
            This implementation is set to work with a 64 bit word size.</p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC564Engine.#ctor">
            Create an instance of the RC5 encryption algorithm
            and set some defaults
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC564Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a RC5-64 cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC564Engine.SetKey(System.Byte[])">
             Re-key the cipher.
            
             @param  key  the key to be used
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RC6Engine">
            An RC6 engine.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC6Engine.#ctor">
            Create an instance of the RC6 encryption algorithm
            and set some defaults
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC6Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a RC5-32 cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC6Engine.SetKey(System.Byte[])">
             Re-key the cipher.
            
             @param inKey the key to be used
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.Rfc3211WrapEngine">
            an implementation of the RFC 3211 Key Wrap
            Specification.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.Rfc3394WrapEngine">
            <remarks>
            An implementation of the AES Key Wrapper from the NIST Key Wrap
            Specification as described in RFC 3394.
            <p/>
            For further details see: <a href="http://www.ietf.org/rfc/rfc3394.txt">http://www.ietf.org/rfc/rfc3394.txt</a>
            and  <a href="http://csrc.nist.gov/encryption/kms/key-wrap.pdf">http://csrc.nist.gov/encryption/kms/key-wrap.pdf</a>.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RijndaelEngine">
            an implementation of Rijndael, based on the documentation and reference implementation
            by Paulo Barreto, Vincent Rijmen, for v2.0 August '99.
            <p>
            Note: this implementation is based on information prior to readonly NIST publication.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.Mul0x2(System.Int32)">
            multiply two elements of GF(2^m)
            needed for MixColumn and InvMixColumn
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.KeyAddition(System.Int64[])">
            xor corresponding text input and round key input bytes
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.ShiftRow(System.Byte[])">
            Row 0 remains unchanged
            The other three rows are shifted a variable amount
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.Substitution(System.Byte[])">
            Replace every byte of the input by the byte at that place
            in the nonlinear S-box
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.MixColumn">
            Mix the bytes of every column in a linear way
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.InvMixColumn">
            Mix the bytes of every column in a linear way
            This is the opposite operation of Mixcolumn
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.GenerateWorkingKey(System.Byte[])">
            Calculate the necessary round keys
            The number of calculations depends on keyBits and blockBits
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.#ctor">
            default constructor - 128 bit block size.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.#ctor(System.Int32)">
             basic constructor - set the cipher up for a given blocksize
            
             @param blocksize the blocksize in bits, must be 128, 192, or 256.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a Rijndael cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine">
            this does your basic RSA algorithm with blinding
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the RSA engine.
            
             @param forEncryption true if we are encrypting, false otherwise.
             @param param the necessary RSA key parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine.GetInputBlockSize">
             Return the maximum size for an input block to this engine.
             For RSA this is always one byte less than the key size on
             encryption, and the same length as the key size on decryption.
            
             @return maximum size for an input block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine.GetOutputBlockSize">
             Return the maximum size for an output block to this engine.
             For RSA this is always one byte less than the key size on
             decryption, and the same length as the key size on encryption.
            
             @return maximum size for an output block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
             Process a single block using the basic RSA algorithm.
            
             @param inBuf the input array.
             @param inOff the offset into the input buffer where the data starts.
             @param inLen the length of the data to be processed.
             @return the result of the RSA process.
             @exception DataLengthException the input block is too large.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RsaCoreEngine">
            this does your basic RSA algorithm.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaCoreEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the RSA engine.
            
             @param forEncryption true if we are encrypting, false otherwise.
             @param param the necessary RSA key parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaCoreEngine.GetInputBlockSize">
             Return the maximum size for an input block to this engine.
             For RSA this is always one byte less than the key size on
             encryption, and the same length as the key size on decryption.
            
             @return maximum size for an input block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaCoreEngine.GetOutputBlockSize">
             Return the maximum size for an output block to this engine.
             For RSA this is always one byte less than the key size on
             decryption, and the same length as the key size on encryption.
            
             @return maximum size for an output block.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.Salsa20Engine">
            <summary>
            Implementation of Daniel J. Bernstein's Salsa20 stream cipher, Snuffle 2005
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.Salsa20Engine.StateSize">
            Constants 
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Salsa20Engine.#ctor">
            <summary>
            Creates a 20 round Salsa20 engine.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Salsa20Engine.#ctor(System.Int32)">
            <summary>
            Creates a Salsa20 engine with a specific number of rounds.
            </summary>
            <param name="rounds">the number of rounds (must be an even number).</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.SeedEngine">
            Implementation of the SEED algorithm as described in RFC 4009
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.SeedWrapEngine">
            <remarks>
            An implementation of the SEED key wrapper based on RFC 4010/RFC 3394.
            <p/>
            For further details see: <a href="http://www.ietf.org/rfc/rfc4010.txt">http://www.ietf.org/rfc/rfc4010.txt</a>.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.SerpentEngine">
                 * Serpent is a 128-bit 32-round block cipher with variable key lengths,
                 * including 128, 192 and 256 bit keys conjectured to be at least as
                 * secure as three-key triple-DES.
                 * <p>
                 * Serpent was designed by Ross Anderson, Eli Biham and Lars Knudsen as a
                 * candidate algorithm for the NIST AES Quest.
            	 * </p>
                 * <p>
                 * For full details see <a href="http://www.cl.cam.ac.uk/~rja14/serpent.html">The Serpent home page</a>
            	 * </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.MakeWorkingKey(System.Byte[])">
             Expand a user-supplied key material into a session key.
            
             @param key  The user-key bytes (multiples of 4) to use.
             @exception ArgumentException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a Serpent cipher.
            
             @param encrypting whether or not we are for encryption.
             @param params     the parameters required to set up the cipher.
             @throws IllegalArgumentException if the params argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Process one block of input from the array in and write it to
             the out array.
            
             @param in     the array containing the input data.
             @param inOff  offset into the in array the data starts at.
             @param out    the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @return the number of bytes processed and produced.
             @throws DataLengthException if there isn't enough data in in, or
             space in out.
             @throws IllegalStateException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Ib0(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvSO - {13, 3,11, 0,10, 6, 5,12, 1,14, 4, 7,15, 9, 8, 2 } - 15 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Sb1(System.Int32,System.Int32,System.Int32,System.Int32)">
            S1 - {15,12, 2, 7, 9, 0, 5,10, 1,11,14, 8, 6,13, 3, 4 } - 14 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Ib1(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS1 - { 5, 8, 2,14,15, 6,12, 3,11, 4, 7, 9, 1,13,10, 0 } - 14 steps.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Sb2(System.Int32,System.Int32,System.Int32,System.Int32)">
            S2 - { 8, 6, 7, 9, 3,12,10,15,13, 1,14, 4, 0,11, 5, 2 } - 16 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Ib2(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS2 - {12, 9,15, 4,11,14, 1, 2, 0, 3, 6,13, 5, 8,10, 7 } - 16 steps.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Sb3(System.Int32,System.Int32,System.Int32,System.Int32)">
            S3 - { 0,15,11, 8,12, 9, 6, 3,13, 1, 2, 4,10, 7, 5,14 } - 16 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Ib3(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS3 - { 0, 9,10, 7,11,14, 6,13, 3, 5,12, 2, 4, 8,15, 1 } - 15 terms
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Sb4(System.Int32,System.Int32,System.Int32,System.Int32)">
            S4 - { 1,15, 8, 3,12, 0,11, 6, 2, 5, 4,10, 9,14, 7,13 } - 15 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Ib4(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS4 - { 5, 0, 8, 3,10, 9, 7,14, 2,12,11, 6, 4,15,13, 1 } - 15 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Sb5(System.Int32,System.Int32,System.Int32,System.Int32)">
            S5 - {15, 5, 2,11, 4,10, 9,12, 0, 3,14, 8,13, 6, 7, 1 } - 16 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Ib5(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS5 - { 8,15, 2, 9, 4, 1,13,14,11, 6, 5, 3, 7,12,10, 0 } - 16 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Sb6(System.Int32,System.Int32,System.Int32,System.Int32)">
            S6 - { 7, 2,12, 5, 8, 4, 6,11,14, 9, 1,15,13, 3,10, 0 } - 15 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Ib6(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS6 - {15,10, 1,13, 5, 3, 6, 0, 4, 9,14, 7, 2,12, 8,11 } - 15 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Sb7(System.Int32,System.Int32,System.Int32,System.Int32)">
            S7 - { 1,13,15, 0,14, 8, 2,11, 7, 4,12,10, 9, 3, 5, 6 } - 16 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Ib7(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS7 - { 3, 0, 6,13, 9,14,15, 8, 5,12,11, 7,10, 1, 4, 2 } - 17 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.LT">
            Apply the linear transformation to the register set.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.InverseLT">
            Apply the inverse of the linear transformation to the register set.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.SkipjackEngine">
            a class that provides a basic SKIPJACK engine.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SkipjackEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a SKIPJACK cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SkipjackEngine.G(System.Int32,System.Int32)">
            The G permutation
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SkipjackEngine.H(System.Int32,System.Int32)">
            the inverse of the G permutation.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.SM4Engine">
            <summary>SM4 Block Cipher - SM4 is a 128 bit block cipher with a 128 bit key.</summary>
            <remarks>
            The implementation here is based on the document <a href="http://eprint.iacr.org/2008/329.pdf">http://eprint.iacr.org/2008/329.pdf</a>
            by Whitfield Diffie and George Ledin, which is a translation of Prof. LU Shu-wang's original standard.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.TeaEngine">
            An TEA engine.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TeaEngine.#ctor">
            Create an instance of the TEA encryption algorithm
            and set some defaults
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TeaEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise
            
             @param forEncryption whether or not we are for encryption.
             @param params the parameters required to set up the cipher.
             @exception ArgumentException if the params argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TeaEngine.SetKey(System.Byte[])">
             Re-key the cipher.
            
             @param  key  the key to be used
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.ThreefishEngine">
            <summary>
            Implementation of the Threefish tweakable large block cipher in 256, 512 and 1024 bit block
            sizes.
            </summary>
            <remarks>
            This is the 1.3 version of Threefish defined in the Skein hash function submission to the NIST
            SHA-3 competition in October 2010.
            <p/>
            Threefish was designed by Niels Ferguson - Stefan Lucks - Bruce Schneier - Doug Whiting - Mihir
            Bellare - Tadayoshi Kohno - Jon Callas - Jesse Walker.
            <p/>
            This implementation inlines all round functions, unrolls 8 rounds, and uses 1.2k of static tables
            to speed up key schedule injection. <br/>
            2 x block size state is retained by each cipher instance.
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.BLOCKSIZE_256">
            <summary>
            256 bit block size - Threefish-256
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.BLOCKSIZE_512">
            <summary>
            512 bit block size - Threefish-512
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.BLOCKSIZE_1024">
            <summary>
            1024 bit block size - Threefish-1024
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.TWEAK_SIZE_BYTES">
            Size of the tweak in bytes (always 128 bit/16 bytes)
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.ROUNDS_256">
            Rounds in Threefish-256
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.ROUNDS_512">
            Rounds in Threefish-512
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.ROUNDS_1024">
            Rounds in Threefish-1024
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.MAX_ROUNDS">
            Max rounds of any of the variants
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.C_240">
            Key schedule parity constant
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.blocksizeBytes">
            Block size in bytes
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.blocksizeWords">
            Block size in 64 bit words
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.currentBlock">
            Buffer for byte oriented processBytes to call internal word API
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.t">
            Tweak bytes (2 byte t1,t2, calculated t3 and repeat of t1,t2 for modulo free lookup
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.kw">
            Key schedule words
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.cipher">
            The internal cipher implementation (varies by blocksize)
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.#ctor(System.Int32)">
            <summary>
            Constructs a new Threefish cipher, with a specified block size.
            </summary>
            <param name="blocksizeBits">the block size in bits, one of <see cref="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.BLOCKSIZE_256"/>, <see cref="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.BLOCKSIZE_512"/>,
                                 <see cref="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.BLOCKSIZE_1024"/> .</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>
            Initialise the engine.
            </summary>
            <param name="forEncryption">Initialise for encryption if true, for decryption if false.</param>
            <param name="parameters">an instance of <see cref="T:Org.BouncyCastle.Crypto.Parameters.TweakableBlockCipherParameters"/> or <see cref="T:Org.BouncyCastle.Crypto.Parameters.KeyParameter"/> (to
                          use a 0 tweak)</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Init(System.Boolean,System.UInt64[],System.UInt64[])">
            <summary>
            Initialise the engine, specifying the key and tweak directly.
            </summary>
            <param name="forEncryption">the cipher mode.</param>
            <param name="key">the words of the key, or <code>null</code> to use the current key.</param>
            <param name="tweak">the 2 word (128 bit) tweak, or <code>null</code> to use the current tweak.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.ProcessBlock(System.UInt64[],System.UInt64[])">
            <summary>
            Process a block of data represented as 64 bit words.
            </summary>
            <returns>the number of 8 byte words processed (which will be the same as the block size).</returns>
            <param name="inWords">a block sized buffer of words to process.</param>
            <param name="outWords">a block sized buffer of words to receive the output of the operation.</param>
            <exception cref="T:Org.BouncyCastle.Crypto.DataLengthException">if either the input or output is not block sized</exception>
            <exception cref="T:System.InvalidOperationException">if this engine is not initialised</exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.RotlXor(System.UInt64,System.Int32,System.UInt64)">
            Rotate left + xor part of the mix operation.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.XorRotr(System.UInt64,System.Int32,System.UInt64)">
            Rotate xor + rotate right part of the unmix operation.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.ThreefishCipher.t">
            The extended + repeated tweak words
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.ThreefishCipher.kw">
            The extended + repeated key words
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Threefish256Cipher.ROTATION_0_0">
            Mix rotation constants defined in Skein 1.3 specification
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Threefish256Cipher.ROTATION_0_1">
            Mix rotation constants defined in Skein 1.3 specification
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Threefish512Cipher.ROTATION_0_0">
            Mix rotation constants defined in Skein 1.3 specification
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Threefish512Cipher.ROTATION_0_1">
            Mix rotation constants defined in Skein 1.3 specification
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Threefish512Cipher.ROTATION_0_2">
            Mix rotation constants defined in Skein 1.3 specification
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Threefish512Cipher.ROTATION_0_3">
            Mix rotation constants defined in Skein 1.3 specification
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Threefish1024Cipher.ROTATION_0_0">
            Mix rotation constants defined in Skein 1.3 specification
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Threefish1024Cipher.ROTATION_0_1">
            Mix rotation constants defined in Skein 1.3 specification
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Threefish1024Cipher.ROTATION_0_2">
            Mix rotation constants defined in Skein 1.3 specification
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Threefish1024Cipher.ROTATION_0_3">
            Mix rotation constants defined in Skein 1.3 specification
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.TnepresEngine">
            Tnepres is a 128-bit 32-round block cipher with variable key lengths,
            including 128, 192 and 256 bit keys conjectured to be at least as
            secure as three-key triple-DES.
            <p>
            Tnepres is based on Serpent which was designed by Ross Anderson, Eli Biham and Lars Knudsen as a
            candidate algorithm for the NIST AES Quest. Unfortunately there was an endianness issue
            with test vectors in the AES submission and the resulting confusion lead to the Tnepres cipher
            as well, which is a byte swapped version of Serpent.
            </p>
            <p>
            For full details see <a href="http://www.cl.cam.ac.uk/~rja14/serpent.html">The Serpent home page</a>
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TnepresEngine.MakeWorkingKey(System.Byte[])">
             Expand a user-supplied key material into a session key.
            
             @param key  The user-key bytes (multiples of 4) to use.
             @exception ArgumentException
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.TwofishEngine">
             A class that provides Twofish encryption operations.
            
             This Java implementation is based on the Java reference
             implementation provided by Bruce Schneier and developed
             by Raif S. Naffah.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.TwofishEngine.P_00">
            Define the fixed p0/p1 permutations used in keyed S-box lookup.
            By changing the following constant definitions, the S-boxes will
            automatically Get changed in the Twofish engine.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.TwofishEngine.gSubKeys">
            gSubKeys[] and gSBox[] are eventually used in the
            encryption and decryption methods.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TwofishEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a Twofish cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TwofishEngine.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Encrypt the given input starting at the given offset and place
             the result in the provided buffer starting at the given offset.
             The input will be an exact multiple of our blocksize.
            
             encryptBlock uses the pre-calculated gSBox[] and subKey[]
             arrays.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TwofishEngine.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            Decrypt the given input starting at the given offset and place
            the result in the provided buffer starting at the given offset.
            The input will be an exact multiple of our blocksize.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TwofishEngine.RS_MDS_Encode(System.Int32,System.Int32)">
             Use (12, 8) Reed-Solomon code over GF(256) to produce
             a key S-box 32-bit entity from 2 key material 32-bit
             entities.
            
             @param    k0 first 32-bit entity
             @param    k1 second 32-bit entity
             @return     Remainder polynomial Generated using RS code
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TwofishEngine.RS_rem(System.Int32)">
                    * Reed-Solomon code parameters: (12,8) reversible code:
            		* <p>
                    * <pre>
                    * G(x) = x^4 + (a+1/a)x^3 + ax^2 + (a+1/a)x + 1
                    * </pre>
                    * where a = primitive root of field generator 0x14D
            		* </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.VmpcEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            initialise a VMPC cipher.
            
            @param forEncryption
               whether or not we are for encryption.
            @param params
               the parameters required to set up the cipher.
            @exception ArgumentException
               if the params argument is inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.XteaEngine">
            An XTEA engine.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.XteaEngine.#ctor">
            Create an instance of the TEA encryption algorithm
            and set some defaults
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.XteaEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise
            
             @param forEncryption whether or not we are for encryption.
             @param params the parameters required to set up the cipher.
             @exception ArgumentException if the params argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.XteaEngine.setKey(System.Byte[])">
             Re-key the cipher.
            
             @param  key  the key to be used
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.BaseKdfBytesGenerator">
            Basic KDF generator for derived keys and ivs as defined by IEEE P1363a/ISO 18033
            <br/>
            This implementation is based on ISO 18033/P1363a.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.BaseKdfBytesGenerator.#ctor(System.Int32,Org.BouncyCastle.Crypto.IDigest)">
             Construct a KDF Parameters generator.
            
             @param counterStart value of counter.
             @param digest the digest to be used as the source of derived keys.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Generators.BaseKdfBytesGenerator.Digest">
            return the underlying digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.BaseKdfBytesGenerator.GenerateBytes(System.Byte[],System.Int32,System.Int32)">
             fill len bytes of the output buffer with bytes generated from
             the derivation function.
            
             @throws ArgumentException if the size of the request will cause an overflow.
             @throws DataLengthException if the out buffer is too small.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.DesEdeKeyGenerator.EngineInit(Org.BouncyCastle.Crypto.KeyGenerationParameters)">
             initialise the key generator - if strength is set to zero
             the key Generated will be 192 bits in size, otherwise
             strength can be 128 or 192 (or 112 or 168 if you don't count
             parity bits), depending on whether you wish to do 2-key or 3-key
             triple DES.
            
             @param param the parameters to be used for key generation
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.DesKeyGenerator.EngineInit(Org.BouncyCastle.Crypto.KeyGenerationParameters)">
             initialise the key generator - if strength is set to zero
             the key generated will be 64 bits in size, otherwise
             strength can be 64 or 56 bits (if you don't count the parity bits).
            
             @param param the parameters to be used for key generation
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.DHKeyPairGenerator">
             a Diffie-Hellman key pair generator.
            
             This generates keys consistent for use in the MTI/A0 key agreement protocol
             as described in "Handbook of Applied Cryptography", Pages 516-519.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.DsaKeyPairGenerator">
             a DSA key pair generator.
            
             This Generates DSA keys in line with the method described
             in <i>FIPS 186-3 B.1 FFC Key Pair Generation</i>.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.ECKeyPairGenerator.GenerateKeyPair">
            Given the domain parameters this routine generates an EC key
            pair in accordance with X9.62 section 5.2.1 pages 26, 27.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.ElGamalKeyPairGenerator">
            a ElGamal key pair generator.
            <p>
            This Generates keys consistent for use with ElGamal as described in
            page 164 of "Handbook of Applied Cryptography".</p>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.Gost3410KeyPairGenerator">
            a GOST3410 key pair generator.
            This generates GOST3410 keys in line with the method described
            in GOST R 34.10-94.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.Kdf2BytesGenerator">
            KDF2 generator for derived keys and ivs as defined by IEEE P1363a/ISO 18033
            <br/>
            This implementation is based on IEEE P1363/ISO 18033.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Kdf2BytesGenerator.#ctor(Org.BouncyCastle.Crypto.IDigest)">
             Construct a KDF2 bytes generator. Generates key material
             according to IEEE P1363 or ISO 18033 depending on the initialisation.
            
             @param digest the digest to be used as the source of derived keys.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.OpenSslPbeParametersGenerator">
            <description>
            Generator for PBE derived keys and IVs as usd by OpenSSL. Originally this scheme was a simple extension of
            PKCS 5 V2.0 Scheme 1 using MD5 with an iteration count of 1. The default digest was changed to SHA-256 with
            OpenSSL 1.1.0. This implementation still defaults to MD5, but the digest can now be set.
            </description>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.OpenSslPbeParametersGenerator.#ctor">
            
             <description>
             Construct a OpenSSL Parameters generator - digest the original MD5.
             </description>
            
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.OpenSslPbeParametersGenerator.#ctor(Org.BouncyCastle.Crypto.IDigest)">
            
             <description>
             Construct a OpenSSL Parameters generator - digest as specified.
             </description>
             <param name="digest">the digest to use as the PRF.</param>
            
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.OpenSslPbeParametersGenerator.Init(System.Byte[],System.Byte[])">
            Initialise - note the iteration count for this algorithm is fixed at 1.
            
            @param password password to use.
            @param salt salt to use.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.OpenSslPbeParametersGenerator.GenerateDerivedKey(System.Int32)">
            the derived key function, the ith hash of the password and the salt.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.OpenSslPbeParametersGenerator.GenerateDerivedMacParameters(System.Int32)">
             Generate a key parameter for use with a MAC derived from the password,
             salt, and iteration count we are currently initialised with.
            
             @param keySize the size of the key we want (in bits)
             @return a KeyParameter object.
             @exception ArgumentException if the key length larger than the base hash size.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.Pkcs12ParametersGenerator">
            Generator for Pbe derived keys and ivs as defined by Pkcs 12 V1.0.
            <p>
            The document this implementation is based on can be found at
            <a href="http://www.rsasecurity.com/rsalabs/pkcs/pkcs-12/index.html">
            RSA's Pkcs12 Page</a>
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs12ParametersGenerator.#ctor(Org.BouncyCastle.Crypto.IDigest)">
             Construct a Pkcs 12 Parameters generator.
            
             @param digest the digest to be used as the source of derived keys.
             @exception ArgumentException if an unknown digest is passed in.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs12ParametersGenerator.Adjust(System.Byte[],System.Int32,System.Byte[])">
            add a + b + 1, returning the result in a. The a value is treated
            as a BigInteger of length (b.Length * 8) bits. The result is
            modulo 2^b.Length in case of overflow.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs12ParametersGenerator.GenerateDerivedKey(System.Int32,System.Int32)">
            generation of a derived key ala Pkcs12 V1.0.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs12ParametersGenerator.GenerateDerivedMacParameters(System.Int32)">
             Generate a key parameter for use with a MAC derived from the password,
             salt, and iteration count we are currently initialised with.
            
             @param keySize the size of the key we want (in bits)
             @return a KeyParameter object.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.Pkcs5S1ParametersGenerator">
            Generator for Pbe derived keys and ivs as defined by Pkcs 5 V2.0 Scheme 1.
            Note this generator is limited to the size of the hash produced by the
            digest used to drive it.
            <p>
            The document this implementation is based on can be found at
            <a href="http://www.rsasecurity.com/rsalabs/pkcs/pkcs-5/index.html">
            RSA's Pkcs5 Page</a>
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs5S1ParametersGenerator.#ctor(Org.BouncyCastle.Crypto.IDigest)">
             Construct a Pkcs 5 Scheme 1 Parameters generator.
            
             @param digest the digest to be used as the source of derived keys.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs5S1ParametersGenerator.GenerateDerivedKey">
            the derived key function, the ith hash of the mPassword and the mSalt.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs5S1ParametersGenerator.GenerateDerivedMacParameters(System.Int32)">
             Generate a key parameter for use with a MAC derived from the mPassword,
             mSalt, and iteration count we are currently initialised with.
            
             @param keySize the size of the key we want (in bits)
             @return a KeyParameter object.
             @exception ArgumentException if the key length larger than the base hash size.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.Pkcs5S2ParametersGenerator">
            Generator for Pbe derived keys and ivs as defined by Pkcs 5 V2.0 Scheme 2.
            This generator uses a SHA-1 HMac as the calculation function.
            <p>
            The document this implementation is based on can be found at
            <a href="http://www.rsasecurity.com/rsalabs/pkcs/pkcs-5/index.html">
            RSA's Pkcs5 Page</a></p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs5S2ParametersGenerator.#ctor">
            construct a Pkcs5 Scheme 2 Parameters generator.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs5S2ParametersGenerator.GenerateDerivedMacParameters(System.Int32)">
             Generate a key parameter for use with a MAC derived from the password,
             salt, and iteration count we are currently initialised with.
            
             @param keySize the size of the key we want (in bits)
             @return a KeyParameter object.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.RsaKeyPairGenerator">
            an RSA key pair generator.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.RsaKeyPairGenerator.ChooseRandomPrime(System.Int32,Org.BouncyCastle.Math.BigInteger)">
            <summary>Choose a random prime value for use with RSA</summary>
            <param name="bitlength">the bit-length of the returned prime</param>
            <param name="e">the RSA public exponent</param>
            <returns>a prime p, with (p-1) relatively prime to e</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IAsymmetricBlockCipher">
            <remarks>Base interface for a public/private key block cipher.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IAsymmetricBlockCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAsymmetricBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">Initialise for encryption if true, for decryption if false.</param>
            <param name="parameters">The key or other data required by the cipher.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAsymmetricBlockCipher.GetInputBlockSize">
            <returns>The maximum size, in bytes, an input block may be.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAsymmetricBlockCipher.GetOutputBlockSize">
            <returns>The maximum size, in bytes, an output block will be.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAsymmetricBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>Process a block.</summary>
            <param name="inBuf">The input buffer.</param>
            <param name="inOff">The offset into <paramref>inBuf</paramref> that the input block begins.</param>
            <param name="inLen">The length of the input block.</param>
            <exception cref="T:Org.BouncyCastle.Crypto.InvalidCipherTextException">Input decrypts improperly.</exception>
            <exception cref="T:Org.BouncyCastle.Crypto.DataLengthException">Input is too large for the cipher.</exception>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IAsymmetricCipherKeyPairGenerator">
            interface that a public/private key pair generator should conform to.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAsymmetricCipherKeyPairGenerator.Init(Org.BouncyCastle.Crypto.KeyGenerationParameters)">
             intialise the key pair generator.
            
             @param the parameters the key pair is to be initialised with.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAsymmetricCipherKeyPairGenerator.GenerateKeyPair">
             return an AsymmetricCipherKeyPair containing the Generated keys.
            
             @return an AsymmetricCipherKeyPair containing the Generated keys.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IBasicAgreement">
            The basic interface that basic Diffie-Hellman implementations
            conforms to.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBasicAgreement.Init(Org.BouncyCastle.Crypto.ICipherParameters)">
            initialise the agreement engine.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBasicAgreement.GetFieldSize">
            return the field size for the agreement algorithm in bytes.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBasicAgreement.CalculateAgreement(Org.BouncyCastle.Crypto.ICipherParameters)">
            given a public key from a given party calculate the next
            message in the agreement sequence.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IBlockCipher">
            <remarks>Base interface for a symmetric key block cipher.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IBlockCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">Initialise for encryption if true, for decryption if false.</param>
            <param name="parameters">The key or other data required by the cipher.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockCipher.GetBlockSize">
            <returns>The block size for this cipher, in bytes.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>Process a block.</summary>
            <param name="inBuf">The input buffer.</param>
            <param name="inOff">The offset into <paramref>inBuf</paramref> that the input block begins.</param>
            <param name="outBuf">The output buffer.</param>
            <param name="outOff">The offset into <paramref>outBuf</paramref> to write the output block.</param>
            <exception cref="T:Org.BouncyCastle.Crypto.DataLengthException">If input block is wrong size, or outBuf too small.</exception>
            <returns>The number of bytes processed and produced.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IBlockResult">
            <summary>
            Operators that reduce their input to a single block return an object
            of this type.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockResult.Collect">
            <summary>
            Return the final result of the operation.
            </summary>
            <returns>A block of bytes, representing the result of an operation.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockResult.Collect(System.Byte[],System.Int32)">
            <summary>
            Store the final result of the operation by copying it into the destination array.
            </summary>
            <returns>The number of bytes copied into destination.</returns>
            <param name="buf">The byte array to copy the result into.</param>
            <param name="off">The offset into destination to start copying the result at.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IBufferedCipher">
            <remarks>Block cipher engines are expected to conform to this interface.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IBufferedCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBufferedCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">If true the cipher is initialised for encryption,
            if false for decryption.</param>
            <param name="parameters">The key and other data required by the cipher.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBufferedCipher.Reset">
            <summary>
            Reset the cipher. After resetting the cipher is in the same state
            as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.ICipherParameters">
            all parameter classes implement this.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IDerivationFunction">
            base interface for general purpose byte derivation functions.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IDerivationFunction.Digest">
            return the message digest used as the basis for the function
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IDerivationParameters">
            Parameters for key/byte stream derivation classes
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IDigest">
            <remarks>Base interface for a message digest.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IDigest.AlgorithmName">
            <summary>The algorithm name.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDigest.GetDigestSize">
            <summary>Return the size, in bytes, of the digest produced by this message digest.</summary>
            <returns>the size, in bytes, of the digest produced by this message digest.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDigest.GetByteLength">
            <summary>Return the size, in bytes, of the internal buffer used by this digest.</summary>
            <returns>the size, in bytes, of the internal buffer used by this digest.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDigest.Update(System.Byte)">
            <summary>Update the message digest with a single byte.</summary>
            <param name="input">the input byte to be entered.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDigest.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>Update the message digest with a block of bytes.</summary>
            <param name="input">the byte array containing the data.</param>
            <param name="inOff">the offset into the byte array where the data starts.</param>
            <param name="inLen">the length of the data.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDigest.DoFinal(System.Byte[],System.Int32)">
            <summary>Close the digest, producing the final digest value.</summary>
            <remarks>This call leaves the digest reset.</remarks>
            <param name="output">the byte array the digest is to be copied into.</param>
            <param name="outOff">the offset into the byte array the digest is to start at.</param>
            <returns>the number of bytes written</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDigest.Reset">
            <summary>Reset the digest back to its initial state.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IDsa">
            <summary>Interface for classes implementing the Digital Signature Algorithm</summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IDsa.AlgorithmName">
            <summary>The algorithm name.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDsa.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the signer for signature generation or signature verification.</summary>
            <param name="forSigning">true if we are generating a signature, false otherwise.</param>
            <param name="parameters">key parameters for signature generation.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDsa.GenerateSignature(System.Byte[])">
            <summary>Sign the passed in message (usually the output of a hash function).</summary>
            <param name="message">the message to be signed.</param>
            <returns>two big integers representing the r and s values respectively.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IDsa.Order">
            <summary>The order of the group that the r, s values in signatures belong to.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDsa.VerifySignature(System.Byte[],Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            <summary>Verify the message message against the signature values r and s.</summary>
            <param name="message">the message that was supposed to have been signed.</param>
            <param name="r">the r signature value.</param>
            <param name="s">the s signature value.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IKeyUnwrapper">
            <summary>
            Base interface for a key unwrapper.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IKeyUnwrapper.AlgorithmDetails">
            <summary>
            The parameter set used to configure this key unwrapper.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IKeyUnwrapper.Unwrap(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Unwrap the passed in data.
            </summary>
            <param name="cipherText">The array containing the data to be unwrapped.</param>
            <param name="offset">The offset into cipherText at which the unwrapped data starts.</param>
            <param name="length">The length of the data to be unwrapped.</param>
            <returns>an IBlockResult containing the unwrapped key data.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IKeyWrapper">
            <summary>
            Base interface for a key wrapper.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IKeyWrapper.AlgorithmDetails">
            <summary>
            The parameter set used to configure this key wrapper.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IKeyWrapper.Wrap(System.Byte[])">
            <summary>
            Wrap the passed in key data.
            </summary>
            <param name="keyData">The key data to be wrapped.</param>
            <returns>an IBlockResult containing the wrapped key data.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IMac">
            <summary>The base interface for implementations of message authentication codes (MACs).</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMac.Init(Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the MAC.</summary>
            <param name="parameters">The key or other data required by the MAC.</param>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IMac.AlgorithmName">
            <summary>The algorithm name.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMac.GetMacSize">
            <summary>Return the size, in bytes, of the MAC produced by this implementation.</summary>
            <returns>the size, in bytes, of the MAC produced by this implementation.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMac.Update(System.Byte)">
            <summary>Update the MAC with a single byte.</summary>
            <param name="input">the input byte to be entered.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMac.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>Update the MAC with a block of bytes.</summary>
            <param name="input">the byte array containing the data.</param>
            <param name="inOff">the offset into the byte array where the data starts.</param>
            <param name="inLen">the length of the data.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMac.DoFinal(System.Byte[],System.Int32)">
            <summary>Perform final calculations, producing the result MAC.</summary>
            <remarks>This call leaves the MAC reset.</remarks>
            <param name="output">the byte array the MAC is to be copied into.</param>
            <param name="outOff">the offset into the byte array the MAC is to start at.</param>
            <returns>the number of bytes written</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMac.Reset">
            <summary>Reset the MAC back to its initial state.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.InvalidCipherTextException">
            <summary>This exception is thrown whenever we find something we don't expect in a message.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.ISignatureFactory">
            <summary>
            Base interface for operators that serve as stream-based signature calculators.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.ISignatureFactory.AlgorithmDetails">
            <summary>The algorithm details object for this calculator.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISignatureFactory.CreateCalculator">
            <summary>
            Create a stream calculator for this signature calculator. The stream
            calculator is used for the actual operation of entering the data to be signed
            and producing the signature block.
            </summary>
            <returns>A calculator producing an IBlockResult with a signature in it.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.ISigner.AlgorithmName">
            <summary>The algorithm name.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISigner.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the signer for signing or verification.</summary>
            <param name="forSigning">true if for signing, false otherwise.</param>
            <param name="parameters">necessary parameters.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISigner.Update(System.Byte)">
            <summary>Update the signer with a single byte.</summary>
            <param name="input">the input byte to be entered.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISigner.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>Update the signer with a block of bytes.</summary>
            <param name="input">the byte array containing the data.</param>
            <param name="inOff">the offset into the byte array where the data starts.</param>
            <param name="inLen">the length of the data.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISigner.GenerateSignature">
            <summary>Generate a signature for the message we've been loaded with using the key we were initialised with.
            </summary>
            <returns>A byte array containing the signature for the message.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISigner.VerifySignature(System.Byte[])">
            <summary>Return true if the internal state represents the signature described in the passed in array.
            </summary>
            <param name="signature">an array containing the candidate signature to verify.</param>
            <returns>true if the internal state represents the signature described in the passed in array.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISigner.Reset">
            <summary>Reset the signer back to its initial state.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.ISignerWithRecovery">
            Signer with message recovery.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISignerWithRecovery.HasFullMessage">
             Returns true if the signer has recovered the full message as
             part of signature verification.
            
             @return true if full message recovered.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISignerWithRecovery.GetRecoveredMessage">
             Returns a reference to what message was recovered (if any).
            
             @return full/partial message, null if nothing.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISignerWithRecovery.UpdateWithRecoveredMessage(System.Byte[])">
             Perform an update with the recovered message before adding any other data. This must
             be the first update method called, and calling it will result in the signer assuming
             that further calls to update will include message content past what is recoverable.
            
             @param signature the signature that we are in the process of verifying.
             @throws IllegalStateException
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IStreamCalculator`1">
            <summary>
            Base interface for cryptographic operations such as Hashes, MACs, and Signatures which reduce a stream of data
            to a single value.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IStreamCalculator`1.Stream">
            <summary>Return a "sink" stream which only exists to update the implementing object.</summary>
            <returns>A stream to write to in order to update the implementing object.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IStreamCalculator`1.GetResult">
            <summary>
            Return the result of processing the stream. This value is only available once the stream
            has been closed.
            </summary>
            <returns>The result of processing the stream.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IStreamCipher">
            <summary>The interface stream ciphers conform to.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IStreamCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IStreamCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">If true the cipher is initialised for encryption,
            if false for decryption.</param>
            <param name="parameters">The key and other data required by the cipher.</param>
            <exception cref="T:System.ArgumentException">
            If the parameters argument is inappropriate.
            </exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IStreamCipher.ReturnByte(System.Byte)">
            <summary>encrypt/decrypt a single byte returning the result.</summary>
            <param name="input">the byte to be processed.</param>
            <returns>the result of processing the input byte.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IStreamCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Process a block of bytes from <paramref name="input"/>, putting the result into <paramref name="output"/>.
            </summary>
            <param name="input">The input byte array.</param>
            <param name="inOff">
            The offset into <c>input</c> where the data to be processed starts.
            </param>
            <param name="length">The number of bytes to be processed.</param>
            <param name="output">The output buffer the processed bytes go into.</param>
            <param name="outOff">
            The offset into <c>output</c> the processed data starts at.
            </param>
            <exception cref="T:Org.BouncyCastle.Crypto.DataLengthException">If the input buffer is too small.</exception>
            <exception cref="T:Org.BouncyCastle.Crypto.OutputLengthException">If the output buffer is too small.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IStreamCipher.Reset">
            <summary>
            Reset the cipher to the same state as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IVerifier">
            <summary>
            Operators that reduce their input to the validation of a signature produce this type.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IVerifier.IsVerified(System.Byte[])">
            <summary>
            Return true if the passed in data matches what is expected by the verification result.
            </summary>
            <param name="data">The bytes representing the signature.</param>
            <returns>true if the signature verifies, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IVerifier.IsVerified(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Return true if the length bytes from off in the source array match the signature
            expected by the verification result.
            </summary>
            <param name="source">Byte array containing the signature.</param>
            <param name="off">The offset into the source array where the signature starts.</param>
            <param name="length">The number of bytes in source making up the signature.</param>
            <returns>true if the signature verifies, false otherwise.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IVerifierFactory">
            <summary>
            Base interface for operators that serve as stream-based signature verifiers.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IVerifierFactory.AlgorithmDetails">
            <summary>The algorithm details object for this verifier.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IVerifierFactory.CreateCalculator">
            <summary>
            Create a stream calculator for this verifier. The stream
            calculator is used for the actual operation of entering the data to be verified
            and producing a result which can be used to verify the original signature.
            </summary>
            <returns>A calculator producing an IVerifier which can verify the signature.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IVerifierFactoryProvider">
            <summary>
            Base interface for a provider to support the dynamic creation of signature verifiers.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IVerifierFactoryProvider.CreateVerifierFactory(System.Object)">
            <summary>
            Return a signature verfier for signature algorithm described in the passed in algorithm details object.
            </summary>
            <param name="algorithmDetails">The details of the signature algorithm verification is required for.</param>
            <returns>A new signature verifier.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IWrapper.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IXof">
            <remarks>
            With FIPS PUB 202 a new kind of message digest was announced which supported extendable output, or variable digest sizes.
            This interface provides the extra methods required to support variable output on a digest implementation.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IXof.OutputFinal(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Output the results of the final calculation for this XOF to outLen number of bytes.
            </summary>
            <param name="output">output array to write the output bytes to.</param>
            <param name="outOff">offset to start writing the bytes at.</param>
            <param name="outLen">the number of output bytes requested.</param>
            <returns>the number of bytes written</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IXof.Output(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Start outputting the results of the final calculation for this XOF. Unlike DoFinal, this method
            will continue producing output until the XOF is explicitly reset, or signals otherwise.
            </summary>
            <param name="output">output array to write the output bytes to.</param>
            <param name="outOff">offset to start writing the bytes at.</param>
            <param name="outLen">the number of output bytes requested.</param>
            <returns>the number of bytes written</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.KeyGenerationParameters">
            The base class for parameters to key generators.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.KeyGenerationParameters.#ctor(Org.BouncyCastle.Security.SecureRandom,System.Int32)">
             initialise the generator with a source of randomness
             and a strength (in bits).
            
             @param random the random byte source.
             @param strength the size, in bits, of the keys we want to produce.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.KeyGenerationParameters.Random">
             return the random source associated with this
             generator.
            
             @return the generators random source.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.KeyGenerationParameters.Strength">
             return the bit strength for keys produced by this generator,
            
             @return the strength of the keys this generator produces (in bits).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac">
            standard CBC Block Cipher MAC - if no padding is specified the default of
            pad of zeroes is used.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             create a standard MAC based on a CBC block cipher. This will produce an
             authentication code half the length of the block size of the cipher.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
             create a standard MAC based on a CBC block cipher. This will produce an
             authentication code half the length of the block size of the cipher.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
             @param padding the padding to be used to complete the last block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32)">
            create a standard MAC based on a block cipher with the size of the
            MAC been given in bits. This class uses CBC mode as the basis for the
            MAC generation.
            <p>
            Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
            or 16 bits if being used as a data authenticator (FIPS Publication 113),
            and in general should be less than the size of the block cipher as it reduces
            the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            </p>
            @param cipher the cipher to be used as the basis of the MAC generation.
            @param macSizeInBits the size of the MAC in bits, must be a multiple of 8.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32,Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
            create a standard MAC based on a block cipher with the size of the
            MAC been given in bits. This class uses CBC mode as the basis for the
            MAC generation.
            <p>
            Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
            or 16 bits if being used as a data authenticator (FIPS Publication 113),
            and in general should be less than the size of the block cipher as it reduces
            the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            </p>
            @param cipher the cipher to be used as the basis of the MAC generation.
            @param macSizeInBits the size of the MAC in bits, must be a multiple of 8.
            @param padding the padding to be used to complete the last block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.MacCfbBlockCipher">
            implements a Cipher-FeedBack (CFB) mode on top of a simple cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.MacCfbBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of the
             feedback mode.
             @param blockSize the block size in bits (note: a multiple of 8)
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.MacCfbBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
             An IV which is too short is handled in FIPS compliant fashion.
            
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Macs.MacCfbBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/CFB"
             and the block size in bits.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.MacCfbBlockCipher.GetBlockSize">
             return the block size we are operating at.
            
             @return the block size we are operating at (in bytes).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.MacCfbBlockCipher.Reset">
            reset the chaining vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CfbBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             create a standard MAC based on a CFB block cipher. This will produce an
             authentication code half the length of the block size of the cipher, with
             the CFB mode set to 8 bits.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CfbBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
             create a standard MAC based on a CFB block cipher. This will produce an
             authentication code half the length of the block size of the cipher, with
             the CFB mode set to 8 bits.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
             @param padding the padding to be used.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CfbBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32,System.Int32)">
            create a standard MAC based on a block cipher with the size of the
            MAC been given in bits. This class uses CFB mode as the basis for the
            MAC generation.
            <p>
            Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
            or 16 bits if being used as a data authenticator (FIPS Publication 113),
            and in general should be less than the size of the block cipher as it reduces
            the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            </p>
            @param cipher the cipher to be used as the basis of the MAC generation.
            @param cfbBitSize the size of an output block produced by the CFB mode.
            @param macSizeInBits the size of the MAC in bits, must be a multiple of 8.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CfbBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32,System.Int32,Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
            create a standard MAC based on a block cipher with the size of the
            MAC been given in bits. This class uses CFB mode as the basis for the
            MAC generation.
            <p>
            Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
            or 16 bits if being used as a data authenticator (FIPS Publication 113),
            and in general should be less than the size of the block cipher as it reduces
            the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            </p>
            @param cipher the cipher to be used as the basis of the MAC generation.
            @param cfbBitSize the size of an output block produced by the CFB mode.
            @param macSizeInBits the size of the MAC in bits, must be a multiple of 8.
            @param padding a padding to be used.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CfbBlockCipherMac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.CMac">
            CMAC - as specified at www.nuee.nagoya-u.ac.jp/labs/tiwata/omac/omac.html
            <p>
            CMAC is analogous to OMAC1 - see also en.wikipedia.org/wiki/CMAC
            </p><p>
            CMAC is a NIST recomendation - see 
            csrc.nist.gov/CryptoToolkit/modes/800-38_Series_Publications/SP800-38B.pdf
            </p><p>
            CMAC/OMAC1 is a blockcipher-based message authentication code designed and
            analyzed by Tetsu Iwata and Kaoru Kurosawa.
            </p><p>
            CMAC/OMAC1 is a simple variant of the CBC MAC (Cipher Block Chaining Message 
            Authentication Code). OMAC stands for One-Key CBC MAC.
            </p><p>
            It supports 128- or 64-bits block ciphers, with any key size, and returns
            a MAC with dimension less or equal to the block size of the underlying 
            cipher.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             create a standard MAC based on a CBC block cipher (64 or 128 bit block).
             This will produce an authentication code the length of the block size
             of the cipher.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32)">
             create a standard MAC based on a block cipher with the size of the
             MAC been given in bits.
             <p/>
             Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
             or 16 bits if being used as a data authenticator (FIPS Publication 113),
             and in general should be less than the size of the block cipher as it reduces
             the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            
             @param cipher        the cipher to be used as the basis of the MAC generation.
             @param macSizeInBits the size of the MAC in bits, must be a multiple of 8 and @lt;= 128.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CMac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.Gost28147Mac">
            implementation of GOST 28147-89 MAC
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.HMac">
             HMAC implementation based on RFC2104
            
             H(K XOR opad, H(K XOR ipad, text))
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.HMac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac">
             DES based CBC Block Cipher MAC according to ISO9797, algorithm 3 (ANSI X9.19 Retail MAC)
            
             This could as well be derived from CBCBlockCipherMac, but then the property mac in the base
             class must be changed to protected
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             create a Retail-MAC based on a CBC block cipher. This will produce an
             authentication code of the length of the block size of the cipher.
            
             @param cipher the cipher to be used as the basis of the MAC generation. This must
             be DESEngine.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
             create a Retail-MAC based on a CBC block cipher. This will produce an
             authentication code of the length of the block size of the cipher.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
             @param padding the padding to be used to complete the last block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32)">
            create a Retail-MAC based on a block cipher with the size of the
            MAC been given in bits. This class uses single DES CBC mode as the basis for the
            MAC generation.
            <p>
            Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
            or 16 bits if being used as a data authenticator (FIPS Publication 113),
            and in general should be less than the size of the block cipher as it reduces
            the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            </p>
            @param cipher the cipher to be used as the basis of the MAC generation.
            @param macSizeInBits the size of the MAC in bits, must be a multiple of 8.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32,Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
            create a standard MAC based on a block cipher with the size of the
            MAC been given in bits. This class uses single DES CBC mode as the basis for the
            MAC generation. The final block is decrypted and then encrypted using the
            middle and right part of the key.
            <p>
            Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
            or 16 bits if being used as a data authenticator (FIPS Publication 113),
            and in general should be less than the size of the block cipher as it reduces
            the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            </p>
            @param cipher the cipher to be used as the basis of the MAC generation.
            @param macSizeInBits the size of the MAC in bits, must be a multiple of 8.
            @param padding the padding to be used to complete the last block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.Poly1305">
            <summary>
            Poly1305 message authentication code, designed by D. J. Bernstein.
            </summary>
            <remarks>
            Poly1305 computes a 128-bit (16 bytes) authenticator, using a 128 bit nonce and a 256 bit key
            consisting of a 128 bit key applied to an underlying cipher, and a 128 bit key (with 106
            effective key bits) used in the authenticator.
            
            The polynomial calculation in this implementation is adapted from the public domain <a
            href="https://github.com/floodyberry/poly1305-donna">poly1305-donna-unrolled</a> C implementation
            by Andrew M (@floodyberry).
            </remarks>
            <seealso cref="!:Org.BouncyCastle.Crypto.Generators.Poly1305KeyGenerator"/>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.r0">
            Polynomial key 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.r1">
            Polynomial key 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.r2">
            Polynomial key 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.r3">
            Polynomial key 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.r4">
            Polynomial key 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.s1">
            Precomputed 5 * r[1..4] 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.s2">
            Precomputed 5 * r[1..4] 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.s3">
            Precomputed 5 * r[1..4] 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.s4">
            Precomputed 5 * r[1..4] 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.k0">
            Encrypted nonce 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.k1">
            Encrypted nonce 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.k2">
            Encrypted nonce 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.k3">
            Encrypted nonce 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.currentBlock">
            Current block of buffered input 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.currentBlockOffset">
            Current offset in input buffer 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.h0">
            Polynomial accumulator 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.h1">
            Polynomial accumulator 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.h2">
            Polynomial accumulator 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.h3">
            Polynomial accumulator 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.h4">
            Polynomial accumulator 
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.Poly1305.#ctor">
            Constructs a Poly1305 MAC, where the key passed to init() will be used directly.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.Poly1305.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
            Constructs a Poly1305 MAC, using a 128 bit block cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.Poly1305.Init(Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>
            Initialises the Poly1305 MAC.
            </summary>
            <param name="parameters">a {@link ParametersWithIV} containing a 128 bit nonce and a {@link KeyParameter} with
                     a 256 bit key complying to the {@link Poly1305KeyGenerator Poly1305 key format}.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.SipHash">
            <summary>
            Implementation of SipHash as specified in "SipHash: a fast short-input PRF", by Jean-Philippe
            Aumasson and Daniel J. Bernstein (https://131002.net/siphash/siphash.pdf).
            </summary>
            <remarks>
            "SipHash is a family of PRFs SipHash-c-d where the integer parameters c and d are the number of
            compression rounds and the number of finalization rounds. A compression round is identical to a
            finalization round and this round function is called SipRound. Given a 128-bit key k and a
            (possibly empty) byte string m, SipHash-c-d returns a 64-bit value..."
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.SipHash.#ctor">
            <summary>SipHash-2-4</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.SipHash.#ctor(System.Int32,System.Int32)">
            <summary>SipHash-c-d</summary>
            <param name="c">the number of compression rounds</param>
            <param name="d">the number of finalization rounds</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.MaxBytesExceededException">
            <summary>This exception is thrown whenever a cipher requires a change of key, IV or similar after x amount of
            bytes enciphered.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher">
            implements Cipher-Block-Chaining (CBC) mode on top of a simple cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of chaining.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.UnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/CBC".
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.GetBlockSize">
             return the block size of the underlying cipher.
            
             @return the block size of the underlying cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.Reset">
            reset the chaining vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.CcmBlockCipher">
            Implements the Counter with Cipher Block Chaining mode (CCM) detailed in
            NIST Special Publication 800-38C.
            <p>
            <b>Note</b>: this mode is a packet mode - it needs all the data up front.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CcmBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Basic constructor.
            
             @param cipher the block cipher to be used.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.CcmBlockCipher.UnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CcmBlockCipher.GetMac">
             Returns a byte array containing the mac calculated as part of the
             last encrypt or decrypt operation.
            
             @return the last mac calculated.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CcmBlockCipher.ProcessPacket(System.Byte[],System.Int32,System.Int32)">
             Process a packet of data for either CCM decryption or encryption.
            
             @param in data for processing.
             @param inOff offset at which data starts in the input array.
             @param inLen length of the data in the input array.
             @return a byte array containing the processed input..
             @throws IllegalStateException if the cipher is not appropriately set up.
             @throws InvalidCipherTextException if the input data is truncated or the mac check fails.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CcmBlockCipher.ProcessPacket(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             Process a packet of data for either CCM decryption or encryption.
            
             @param in data for processing.
             @param inOff offset at which data starts in the input array.
             @param inLen length of the data in the input array.
             @param output output array.
             @param outOff offset into output array to start putting processed bytes.
             @return the number of bytes added to output.
             @throws IllegalStateException if the cipher is not appropriately set up.
             @throws InvalidCipherTextException if the input data is truncated or the mac check fails.
             @throws DataLengthException if output buffer too short.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher">
            implements a Cipher-FeedBack (CFB) mode on top of a simple cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of the
             feedback mode.
             @param blockSize the block size in bits (note: a multiple of 8)
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.UnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
             An IV which is too short is handled in FIPS compliant fashion.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/CFB"
             and the block size in bits.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.GetBlockSize">
             return the block size we are operating at.
            
             @return the block size we are operating at (in bytes).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.Reset">
            reset the chaining vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.CtsBlockCipher">
            A Cipher Text Stealing (CTS) mode cipher. CTS allows block ciphers to
            be used to produce cipher text which is the same outLength as the plain text.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CtsBlockCipher.#ctor(Org.BouncyCastle.Crypto.Modes.IBlockCipherMode)">
             Create a buffered block cipher that uses Cipher Text Stealing
            
             @param cipher the underlying block cipher this buffering object wraps.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CtsBlockCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update of 'length' bytes.
            
             @param length the outLength of the input.
             @return the space required to accommodate a call to update
             with length bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CtsBlockCipher.GetOutputSize(System.Int32)">
             return the size of the output buffer required for an update plus a
             doFinal with an input of length bytes.
            
             @param length the outLength of the input.
             @return the space required to accommodate a call to update and doFinal
             with length bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CtsBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if necessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CtsBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param length the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CtsBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output.
             @exception InvalidOperationException if the underlying cipher is not
             initialised.
             @exception InvalidCipherTextException if cipher text decrypts wrongly (in
             case the exception will never Get thrown).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.EaxBlockCipher">
            A Two-Pass Authenticated-Encryption Scheme Optimized for Simplicity and 
            Efficiency - by M. Bellare, P. Rogaway, D. Wagner.
            
            http://www.cs.ucdavis.edu/~rogaway/papers/eax.pdf
            
            EAX is an AEAD scheme based on CTR and OMAC1/CMAC, that uses a single block 
            cipher to encrypt and authenticate data. It's on-line (the length of a 
            message isn't needed to begin processing it), has good performances, it's
            simple and provably secure (provided the underlying block cipher is secure).
            
            Of course, this implementations is NOT thread-safe.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.EaxBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Constructor that accepts an instance of a block cipher engine.
            
             @param cipher the engine to use
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.GcmBlockCipher">
            <summary>
            Implements the Galois/Counter mode (GCM) detailed in NIST Special Publication 800-38D.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.GcmBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <remarks>
            MAC sizes from 32 bits to 128 bits (must be a multiple of 8) are supported. The default is 128 bits.
            Sizes less than 96 are not recommended, but are supported for specialized applications.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher">
            implements the GOST 28147 OFB counter mode (GCTR).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of the
             counter mode (must have a 64 bit block size).
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.UnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
             An IV which is too short is handled in FIPS compliant fashion.
            
             @param encrypting if true the cipher is initialised for
              encryption, if false for decryption.
             @param parameters the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is inappropriate.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/GCTR"
             and the block size in bits
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.GetBlockSize">
             return the block size we are operating at (in bytes).
            
             @return the block size we are operating at (in bytes).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.Reset">
            reset the feedback vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher">
            <summary>An IAeadCipher based on an IBlockCipher.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.GetBlockSize">
            <returns>The block size for this cipher, in bytes.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.UnderlyingCipher">
            <summary>The block cipher underlying this algorithm.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.IAeadCipher">
            <summary>
            A cipher mode that includes authenticated encryption with a streaming mode and optional
            associated data.
            </summary>
            <remarks>
            Implementations of this interface may operate in a packet mode (where all input data is
            buffered and processed during the call to DoFinal, or in a streaming mode (where output
            data is incrementally produced with each call to ProcessByte or ProcessBytes. This is
            important to consider during decryption: in a streaming mode, unauthenticated plaintext
            data may be output prior to the call to DoFinal that results in an authentication failure.
            The higher level protocol utilising this cipher must ensure the plaintext data is handled
            appropriately until the end of data is reached and the entire ciphertext is authenticated.
            </remarks>
            <see cref="T:Org.BouncyCastle.Crypto.Parameters.AeadParameters"/>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.IAeadCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <remarks>Parameter can either be an AeadParameters or a ParametersWithIV object.</remarks>
            <param name="forEncryption">Initialise for encryption if true, for decryption if false.</param>
            <param name="parameters">The key or other data required by the cipher.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadCipher.ProcessAadByte(System.Byte)">
            <summary>Add a single byte to the associated data check.</summary>
            <remarks>If the implementation supports it, this will be an online operation and will not retain the associated data.</remarks>
            <param name="input">The byte to be processed.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadCipher.ProcessAadBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Add a sequence of bytes to the associated data check.</summary>
            <remarks>If the implementation supports it, this will be an online operation and will not retain the associated data.</remarks>
            <param name="inBytes">The input byte array.</param>
            <param name="inOff">The offset into the input array where the data to be processed starts.</param>
            <param name="len">The number of bytes to be processed.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             Encrypt/decrypt a single byte.
            
             @param input the byte to be processed.
             @param outBytes the output buffer the processed byte goes into.
             @param outOff the offset into the output byte array the processed data starts at.
             @return the number of bytes written to out.
             @exception DataLengthException if the output buffer is too small.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             Process a block of bytes from in putting the result into out.
            
             @param inBytes the input byte array.
             @param inOff the offset into the in array where the data to be processed starts.
             @param len the number of bytes to be processed.
             @param outBytes the output buffer the processed bytes go into.
             @param outOff the offset into the output byte array the processed data starts at.
             @return the number of bytes written to out.
             @exception DataLengthException if the output buffer is too small.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadCipher.DoFinal(System.Byte[],System.Int32)">
             Finish the operation either appending or verifying the MAC at the end of the data.
            
             @param outBytes space for any resulting output data.
             @param outOff offset into out to start copying the data at.
             @return number of bytes written into out.
             @throws InvalidOperationException if the cipher is in an inappropriate state.
             @throws InvalidCipherTextException if the MAC fails to match.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadCipher.GetMac">
             Return the value of the MAC associated with the last stream processed.
            
             @return MAC for plaintext data.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadCipher.GetUpdateOutputSize(System.Int32)">
             Return the size of the output buffer required for a ProcessBytes
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to ProcessBytes
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadCipher.GetOutputSize(System.Int32)">
             Return the size of the output buffer required for a ProcessBytes plus a
             DoFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to ProcessBytes and DoFinal
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadCipher.Reset">
            <summary>
            Reset the cipher to the same state as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.IBlockCipherMode.UnderlyingCipher">
            <summary>Return the <code cref="T:Org.BouncyCastle.Crypto.IBlockCipher"/> underlying this cipher mode.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.IBlockCipherMode.IsPartialBlockOkay">
            <summary>Indicates whether this cipher mode can handle partial blocks.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IBlockCipherMode.Reset">
            <summary>
            Reset the cipher mode to the same state as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.OcbBlockCipher">
             <summary>An implementation of <a href="https://tools.ietf.org/html/rfc7253">RFC 7253 on The OCB
             Authenticated-Encryption Algorithm</a>.</summary>
             <remarks>
             For those still concerned about the original patents around this, please see:
             <para>https://mailarchive.ietf.org/arch/msg/cfrg/qLTveWOdTJcLn4HP3ev-vrj05Vg/</para>
             Text reproduced below:
             <para>
             Phillip Rogaway&lt;rogaway@cs.ucdavis.edu&gt; Sat, 27 February 2021 02:46 UTC
            
             I can confirm that I have abandoned all OCB patents and placed into the public domain all OCB-related IP of
             mine. While I have been telling people this for quite some time, I don't think I ever made a proper announcement
             to the CFRG or on the OCB webpage. Consider that done.
             </para>
             </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.OfbBlockCipher">
            implements a Output-FeedBack (OFB) mode on top of a simple cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of the
             feedback mode.
             @param blockSize the block size in bits (note: a multiple of 8)
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.UnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
             An IV which is too short is handled in FIPS compliant fashion.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/OFB"
             and the block size in bits
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.GetBlockSize">
             return the block size we are operating at (in bytes).
            
             @return the block size we are operating at (in bytes).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.Reset">
            reset the feedback vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher">
                * Implements OpenPGP's rather strange version of Cipher-FeedBack (CFB) mode
                * on top of a simple cipher. This class assumes the IV has been prepended
                * to the data stream already, and just accomodates the reset after
                * (blockSize + 2) bytes have been read.
                * <p>
                * For further info see <a href="http://www.ietf.org/rfc/rfc2440.html">RFC 2440</a>.
            	* </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of the
             feedback mode.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.UnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/PGPCFB"
             and the block size in bits.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.GetBlockSize">
             return the block size we are operating at.
            
             @return the block size we are operating at (in bytes).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.Reset">
            reset the chaining vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
             An IV which is too short is handled in FIPS compliant fashion.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param parameters the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.EncryptByte(System.Byte,System.Int32)">
            Encrypt one byte of data according to CFB mode.
            @param data the byte to encrypt
            @param blockOff offset in the current block
            @returns the encrypted byte
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.SicBlockCipher">
            Implements the Segmented Integer Counter (SIC) mode on top of a simple
            block cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.SicBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Basic constructor.
            
             @param c the block cipher to be used.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.SicBlockCipher.UnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Operators.X509Utilities.GetDigestAlgName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            Return the digest algorithm using one of the standard JCA string
            representations rather than the algorithm identifier (if possible).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Operators.Asn1SignatureFactory">
            <summary>
            Calculator factory class for signature generation in ASN.1 based profiles that use an AlgorithmIdentifier to preserve
            signature algorithm details.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Operators.Asn1SignatureFactory.#ctor(System.String,Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Base constructor.
            </summary>
            <param name="algorithm">The name of the signature algorithm to use.</param>
            <param name="privateKey">The private key to be used in the signing operation.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Operators.Asn1SignatureFactory.#ctor(System.String,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Constructor which also specifies a source of randomness to be used if one is required.
            </summary>
            <param name="algorithm">The name of the signature algorithm to use.</param>
            <param name="privateKey">The private key to be used in the signing operation.</param>
            <param name="random">The source of randomness to be used in signature calculation.</param>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Operators.Asn1SignatureFactory.SignatureAlgNames">
            <summary>
            Allows enumeration of the signature names supported by the verifier provider.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Operators.Asn1VerifierFactory">
            <summary>
            Verifier class for signature verification in ASN.1 based profiles that use an AlgorithmIdentifier to preserve
            signature algorithm details.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Operators.Asn1VerifierFactory.#ctor(System.String,Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Base constructor.
            </summary>
            <param name="algorithm">The name of the signature algorithm to use.</param>
            <param name="publicKey">The public key to be used in the verification operation.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Operators.Asn1VerifierFactoryProvider">
            <summary>
            Provider class which supports dynamic creation of signature verifiers.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Operators.Asn1VerifierFactoryProvider.#ctor(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Base constructor - specify the public key to be used in verification.
            </summary>
            <param name="publicKey">The public key to be used in creating verifiers provided by this object.</param>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Operators.Asn1VerifierFactoryProvider.SignatureAlgNames">
            <summary>
            Allows enumeration of the signature names supported by the verifier provider.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding">
            <summary>Block cipher padders are expected to conform to this interface.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.Init(Org.BouncyCastle.Security.SecureRandom)">
            <summary>Initialise the padder.</summary>
            <param name="random">A source of randomness, if any required.</param>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.PaddingName">
            <summary>The name of the algorithm this padder implements.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.AddPadding(System.Byte[],System.Int32)">
            <summary>Add padding to the passed in block.</summary>
            <param name="input">the block to add padding to.</param>
            <param name="inOff">the offset into the block the padding is to start at.</param>
            <returns>the number of bytes of padding added.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.PadCount(System.Byte[])">
            <summary>Determine the length of padding present in the passed in block.</summary>
            <param name="input">the block to check padding for.</param>
            <returns>the number of bytes of padding present.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.ISO10126d2Padding">
            A padder that adds ISO10126-2 padding to a block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.ISO10126d2Padding.Init(Org.BouncyCastle.Security.SecureRandom)">
             Initialise the padder.
            
             @param random a SecureRandom if available.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Paddings.ISO10126d2Padding.PaddingName">
             Return the name of the algorithm the cipher implements.
            
             @return the name of the algorithm the cipher implements.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.ISO7816d4Padding">
            A padder that adds the padding according to the scheme referenced in
            ISO 7814-4 - scheme 2 from ISO 9797-1. The first byte is 0x80, rest is 0x00
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.ISO7816d4Padding.Init(Org.BouncyCastle.Security.SecureRandom)">
             Initialise the padder.
            
             @param random - a SecureRandom if available.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Paddings.ISO7816d4Padding.PaddingName">
             Return the name of the algorithm the padder implements.
            
             @return the name of the algorithm the padder implements.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher">
            A wrapper class that allows block ciphers to be used to process data in
            a piecemeal fashion with padding. The PaddedBufferedBlockCipher
            outputs a block only when the buffer is full and more data is being added,
            or on a doFinal (unless the current block in the buffer is a pad block).
            The default padding mechanism used is the one outlined in Pkcs5/Pkcs7.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.#ctor(Org.BouncyCastle.Crypto.Modes.IBlockCipherMode,Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
             Create a buffered block cipher with the desired padding.
            
             @param cipher the underlying block cipher this buffering object wraps.
             @param padding the padding type.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.#ctor(Org.BouncyCastle.Crypto.Modes.IBlockCipherMode)">
             Create a buffered block cipher Pkcs7 padding
            
             @param cipher the underlying block cipher this buffering object wraps.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the cipher.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.GetOutputSize(System.Int32)">
             return the minimum size of the output buffer required for an update
             plus a doFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update and doFinal
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if necessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param len the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer. If the buffer is currently
             full and padding needs to be added a call to doFinal will produce
             2 * GetBlockSize() bytes.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output or we are decrypting and the input is not block size aligned.
             @exception InvalidOperationException if the underlying cipher is not
             initialised.
             @exception InvalidCipherTextException if padding is expected and not found.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.Pkcs7Padding">
            A padder that adds Pkcs7/Pkcs5 padding to a block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.Pkcs7Padding.Init(Org.BouncyCastle.Security.SecureRandom)">
             Initialise the padder.
            
             @param random - a SecureRandom if available.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Paddings.Pkcs7Padding.PaddingName">
             Return the name of the algorithm the cipher implements.
            
             @return the name of the algorithm the cipher implements.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.TbcPadding">
            <summary> A padder that adds Trailing-Bit-Compliment padding to a block.
            <p>
            This padding pads the block out compliment of the last bit
            of the plain text.
            </p>
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Paddings.TbcPadding.PaddingName">
            <summary> Return the name of the algorithm the cipher implements.</summary>
            <returns> the name of the algorithm the cipher implements.
            </returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.TbcPadding.Init(Org.BouncyCastle.Security.SecureRandom)">
            <summary> Initialise the padder.</summary>
            <param name="random">- a SecureRandom if available.
            </param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.TbcPadding.AddPadding(System.Byte[],System.Int32)">
            <summary> add the pad bytes to the passed in block, returning the number of bytes added.</summary>
            <remarks>
            This assumes that the last block of plain text is always passed to it inside <paramref name="input"/>.
            i.e. if <paramref name="inOff"/> is zero, indicating the padding will fill the entire block,the value of
            <paramref name="input"/> should be the same as the last block of plain text.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.X923Padding">
            A padder that adds X9.23 padding to a block - if a SecureRandom is
            passed in random padding is assumed, otherwise padding with zeros is used.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.X923Padding.Init(Org.BouncyCastle.Security.SecureRandom)">
             Initialise the padder.
            
             @param random a SecureRandom if one is available.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Paddings.X923Padding.PaddingName">
             Return the name of the algorithm the cipher implements.
            
             @return the name of the algorithm the cipher implements.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.ZeroBytePadding">
            <summary> A padder that adds Null byte padding to a block.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Paddings.ZeroBytePadding.PaddingName">
             <summary> Return the name of the algorithm the cipher implements.
            
             </summary>
             <returns> the name of the algorithm the cipher implements.
             </returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.ZeroBytePadding.Init(Org.BouncyCastle.Security.SecureRandom)">
             <summary> Initialise the padder.
            
             </summary>
             <param name="random">- a SecureRandom if available.
             </param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.AeadParameters.#ctor(Org.BouncyCastle.Crypto.Parameters.KeyParameter,System.Int32,System.Byte[])">
             Base constructor.
            
             @param key key to be used by underlying cipher
             @param macSize macSize in bits
             @param nonce nonce to be used
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.AeadParameters.#ctor(Org.BouncyCastle.Crypto.Parameters.KeyParameter,System.Int32,System.Byte[],System.Byte[])">
             Base constructor.
            
             @param key key to be used by underlying cipher
             @param macSize macSize in bits
             @param nonce nonce to be used
             @param associatedText associated text, if any
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.Blake3Parameters">
            <summary>Blake3 Parameters.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.Blake3Parameters.Context(System.Byte[])">
            <summary>Create a key parameter.</summary>
            <param name="pContext">the context</param>
            <returns>the parameter</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.Blake3Parameters.Key(System.Byte[])">
            <summary>Create a key parameter.</summary>
            <param name="pKey">the key</param>
            <returns>the parameter</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.Blake3Parameters.GetKey">
            <summary>Obtain the key.</summary>
            <returns>the key</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.Blake3Parameters.ClearKey">
            <summary>Clear the key bytes.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.Blake3Parameters.GetContext">
            <summary>Obtain the salt.</summary>
            <returns>the salt</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.DesEdeParameters.IsWeakKey(System.Byte[],System.Int32,System.Int32)">
             return true if the passed in key is a DES-EDE weak key.
            
             @param key bytes making up the key
             @param offset offset into the byte array the key starts at
             @param length number of bytes making up the key
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.DesEdeParameters.IsWeakKey(System.Byte[],System.Int32)">
             return true if the passed in key is a DES-EDE weak key.
            
             @param key bytes making up the key
             @param offset offset into the byte array the key starts at
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.DesEdeParameters.IsRealEdeKey(System.Byte[],System.Int32)">
             return true if the passed in key is a real 2/3 part DES-EDE key.
            
             @param key bytes making up the key
             @param offset offset into the byte array the key starts at
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.DesEdeParameters.IsReal2Key(System.Byte[],System.Int32)">
             return true if the passed in key is a real 2 part DES-EDE key.
            
             @param key bytes making up the key
             @param offset offset into the byte array the key starts at
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.DesEdeParameters.IsReal3Key(System.Byte[],System.Int32)">
             return true if the passed in key is a real 3 part DES-EDE key.
            
             @param key bytes making up the key
             @param offset offset into the byte array the key starts at
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.DesParameters.IsWeakKey(System.Byte[],System.Int32)">
            DES has 16 weak keys.  This method will check
            if the given DES key material is weak or semi-weak.
            Key material that is too short is regarded as weak.
            <p>
            See <a href="http://www.counterpane.com/applied.html">"Applied
            Cryptography"</a> by Bruce Schneier for more information.
            </p>
            @return true if the given DES key material is weak or semi-weak,
                false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.DesParameters.SetOddParity(System.Byte[])">
             DES Keys use the LSB as the odd parity bit.  This can
             be used to check for corrupt keys.
            
             @param bytes the byte array to set the parity on.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.DHParameters.M">
            <summary>The minimum bitlength of the private value.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.DHParameters.L">
            <summary>The bitlength of the private value.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.ElGamalParameters.G">
            return the generator - g
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.ElGamalParameters.L">
            return private value limit - l
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.IesParameters">
            parameters for using an integrated cipher in stream mode.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.IesParameters.#ctor(System.Byte[],System.Byte[],System.Int32)">
            @param derivation the derivation parameter for the KDF function.
            @param encoding the encoding parameter for the KDF function.
            @param macKeySize the size of the MAC key (in bits).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.IesWithCipherParameters.#ctor(System.Byte[],System.Byte[],System.Int32,System.Int32)">
            @param derivation the derivation parameter for the KDF function.
            @param encoding the encoding parameter for the KDF function.
            @param macKeySize the size of the MAC key (in bits).
            @param cipherKeySize the size of the associated Cipher key (in bits).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.Iso18033KdfParameters">
            parameters for Key derivation functions for ISO-18033
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.KdfParameters">
            parameters for Key derivation functions for IEEE P1363a
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.SkeinParameters">
            <summary>
            Parameters for the Skein hash function - a series of byte[] strings identified by integer tags.
            </summary>
            <remarks>
            Parameterised Skein can be used for:
            <ul> 
            <li>MAC generation, by providing a <see cref="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetKey(System.Byte[])">key</see>.</li>
            <li>Randomised hashing, by providing a <see cref="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetNonce(System.Byte[])">nonce</see>.</li>
            <li>A hash function for digital signatures, associating a
            <see cref="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetPublicKey(System.Byte[])">public key</see> with the message digest.</li>
            <li>A key derivation function, by providing a
            <see cref="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetKeyIdentifier(System.Byte[])">key identifier</see>.</li>
            <li>Personalised hashing, by providing a
            <see cref="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetPersonalisation(System.DateTime,System.String,System.String)">recommended format</see> or
            <see cref="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetPersonalisation(System.Byte[])">arbitrary</see> personalisation string.</li>
            </ul>
            </remarks>
            <seealso cref="!:Org.BouncyCastle.Crypto.Digests.SkeinEngine"/>
            <seealso cref="!:Org.BouncyCastle.Crypto.Digests.SkeinDigest"/>
            <seealso cref="!:Org.BouncyCastle.Crypto.Macs.SkeinMac"/>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_KEY">
            <summary>
            The parameter type for a secret key, supporting MAC or KDF functions: 0
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_CONFIG">
            <summary>
            The parameter type for the Skein configuration block: 4
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_PERSONALISATION">
            <summary>
            The parameter type for a personalisation string: 8
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_PUBLIC_KEY">
            <summary>
            The parameter type for a public key: 12
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_KEY_IDENTIFIER">
            <summary>
            The parameter type for a key identifier string: 16
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_NONCE">
            <summary>
            The parameter type for a nonce: 20
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_MESSAGE">
            <summary>
            The parameter type for the message: 48
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_OUTPUT">
            <summary>
            The parameter type for the output transformation: 63
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.GetParameters">
            <summary>
            Obtains a map of type (int) to value (byte[]) for the parameters tracked in this object.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.GetKey">
            <summary>
            Obtains the value of the <see cref="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_KEY">key parameter</see>, or <code>null</code> if not
            set.
            </summary>
            <returns>The key.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.GetPersonalisation">
            <summary>
            Obtains the value of the <see cref="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_PERSONALISATION">personalisation parameter</see>, or
            <code>null</code> if not set.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.GetPublicKey">
            <summary>
            Obtains the value of the <see cref="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_PUBLIC_KEY">public key parameter</see>, or
            <code>null</code> if not set.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.GetKeyIdentifier">
            <summary>
            Obtains the value of the <see cref="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_KEY_IDENTIFIER">key identifier parameter</see>, or
            <code>null</code> if not set.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.GetNonce">
            <summary>
            Obtains the value of the <see cref="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_NONCE">nonce parameter</see>, or <code>null</code> if
            not set.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder">
            <summary>
            A builder for <see cref="T:Org.BouncyCastle.Crypto.Parameters.SkeinParameters"/>.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.Set(System.Int32,System.Byte[])">
            <summary>
            Sets a parameters to apply to the Skein hash function.
            </summary>
            <remarks>
            Parameter types must be in the range 0,5..62, and cannot use the value 48
            (reserved for message body).
            <p/>
            Parameters with type &lt; 48 are processed before
            the message content, parameters with type &gt; 48
            are processed after the message and prior to output.
            </remarks>
            <param name="type">the type of the parameter, in the range 5..62.</param>
            <param name="value">the byte sequence of the parameter.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetKey(System.Byte[])">
            <summary>
            Sets the <see cref="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_KEY"/> parameter.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetPersonalisation(System.Byte[])">
            <summary>
            Sets the <see cref="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_PERSONALISATION"/> parameter.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetPersonalisation(System.DateTime,System.String,System.String)">
            <summary>
            Implements the recommended personalisation format for Skein defined in Section 4.11 of
            the Skein 1.3 specification.
            </summary>
            <remarks>
            The format is <code>YYYYMMDD email@address distinguisher</code>, encoded to a byte
            sequence using UTF-8 encoding.
            </remarks>
            <param name="date">the date the personalised application of the Skein was defined.</param>
            <param name="emailAddress">the email address of the creation of the personalised application.</param>
            <param name="distinguisher">an arbitrary personalisation string distinguishing the application.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetPublicKey(System.Byte[])">
            <summary>
            Sets the <see cref="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_KEY_IDENTIFIER"/> parameter.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetKeyIdentifier(System.Byte[])">
            <summary>
            Sets the <see cref="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_KEY_IDENTIFIER"/> parameter.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetNonce(System.Byte[])">
            <summary>
            Sets the <see cref="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_NONCE"/> parameter.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.Build">
            <summary>
            Constructs a new <see cref="T:Org.BouncyCastle.Crypto.Parameters.SkeinParameters"/> instance with the parameters provided to this
            builder.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.TweakableBlockCipherParameters">
            <summary>
            Parameters for tweakable block ciphers.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.TweakableBlockCipherParameters.Key">
            <summary>
            Gets the key.
            </summary>
            <value>the key to use, or <code>null</code> to use the current key.</value>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.TweakableBlockCipherParameters.Tweak">
            <summary>
            Gets the tweak value.
            </summary>
            <value>The tweak to use, or <code>null</code> to use the current tweak.</value>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.PbeParametersGenerator">
            super class for all Password Based Encyrption (Pbe) parameter generator classes.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.#ctor">
            base constructor.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.Init(System.Byte[],System.Byte[],System.Int32)">
             initialise the Pbe generator.
            
             @param password the password converted into bytes (see below).
             @param salt the salt to be mixed with the password.
             @param iterationCount the number of iterations the "mixing" function
             is to be applied for.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.PbeParametersGenerator.IterationCount">
             return the iteration count.
            
             @return the iteration count.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.GenerateDerivedMacParameters(System.Int32)">
             Generate derived parameters for a key of length keySize, specifically
             for use with a MAC.
            
             @param keySize the length, in bits, of the key required.
             @return a parameters object representing a key.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.Pkcs5PasswordToBytes(System.Char[])">
             converts a password to a byte array according to the scheme in
             Pkcs5 (ascii, no padding)
            
             @param password a character array representing the password.
             @return a byte array representing the password.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.Pkcs5PasswordToUtf8Bytes(System.Char[])">
             converts a password to a byte array according to the scheme in
             PKCS5 (UTF-8, no padding)
            
             @param password a character array representing the password.
             @return a byte array representing the password.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.Pkcs12PasswordToBytes(System.Char[])">
             converts a password to a byte array according to the scheme in
             Pkcs12 (unicode, big endian, 2 zero pad bytes at the end).
            
             @param password a character array representing the password.
             @return a byte array representing the password.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Prng.CryptoApiRandomGenerator">
            <summary>
            Uses RandomNumberGenerator.Create() to get randomness generator
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Prng.DigestRandomGenerator">
            Random generation based on the digest with counter. Calling AddSeedMaterial will
            always increase the entropy of the hash.
            <p>
            Internal access to the digest is synchronized so a single one of these can be shared.
            </p>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Prng.IRandomGenerator">
            <remarks>Generic interface for objects generating random bytes.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.IRandomGenerator.AddSeedMaterial(System.Byte[])">
            <summary>Add more seed material to the generator.</summary>
            <param name="seed">A byte array to be mixed into the generator's state.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.IRandomGenerator.AddSeedMaterial(System.Int64)">
            <summary>Add more seed material to the generator.</summary>
            <param name="seed">A long value to be mixed into the generator's state.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.IRandomGenerator.NextBytes(System.Byte[])">
            <summary>Fill byte array with random values.</summary>
            <param name="bytes">Array to be filled.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.IRandomGenerator.NextBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Fill byte array with random values.</summary>
            <param name="bytes">Array to receive bytes.</param>
            <param name="start">Index to start filling at.</param>
            <param name="len">Length of segment to fill.</param>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Prng.VmpcRandomGenerator.P">
            <remarks>
            Permutation generated by code:
            <code>
            // First 1850 fractional digit of Pi number. 
            byte[] key = new BigInteger("14159265358979323846...5068006422512520511").ToByteArray();
            s = 0;
            P = new byte[256];
            for (int i = 0; i &lt; 256; i++) 
            {
                P[i] = (byte) i;
            }
            for (int m = 0; m &lt; 768; m++) 
            {
                s = P[(s + P[m &amp; 0xff] + key[m % key.length]) &amp; 0xff];
                byte temp = P[m &amp; 0xff];
                P[m &amp; 0xff] = P[s &amp; 0xff];
                P[s &amp; 0xff] = temp;
            } </code>
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Prng.VmpcRandomGenerator.s">
            <remarks>Value generated in the same way as <c>P</c>.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.DsaSigner">
            The Digital Signature Algorithm - as described in "Handbook of Applied
            Cryptography", pages 452 - 453.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.DsaSigner.#ctor">
            Default configuration, random K values.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.DsaSigner.#ctor(Org.BouncyCastle.Crypto.Signers.IDsaKCalculator)">
             Configuration with an alternate, possibly deterministic calculator of K.
            
             @param kCalculator a K value calculator.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.DsaSigner.GenerateSignature(System.Byte[])">
             Generate a signature for the given message using the key we were
             initialised with. For conventional DSA the message should be a SHA-1
             hash of the message of interest.
            
             @param message the message that will be verified later.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.DsaSigner.VerifySignature(System.Byte[],Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            return true if the value r and s represent a DSA signature for
            the passed in message for standard DSA the message should be a
            SHA-1 hash of the real message to be verified.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.ECDsaSigner">
            EC-DSA as described in X9.62
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.ECDsaSigner.#ctor">
            Default configuration, random K values.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.ECDsaSigner.#ctor(Org.BouncyCastle.Crypto.Signers.IDsaKCalculator)">
             Configuration with an alternate, possibly deterministic calculator of K.
            
             @param kCalculator a K value calculator.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.ECDsaSigner.GenerateSignature(System.Byte[])">
             Generate a signature for the given message using the key we were
             initialised with. For conventional DSA the message should be a SHA-1
             hash of the message of interest.
            
             @param message the message that will be verified later.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.ECDsaSigner.VerifySignature(System.Byte[],Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            return true if the value r and s represent a DSA signature for
            the passed in message (for standard DSA the message should be
            a SHA-1 hash of the real message to be verified).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.ECGost3410Signer">
            GOST R 34.10-2001 Signature Algorithm
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.ECGost3410Signer.GenerateSignature(System.Byte[])">
             generate a signature for the given message using the key we were
             initialised with. For conventional GOST3410 the message should be a GOST3411
             hash of the message of interest.
            
             @param message the message that will be verified later.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.ECGost3410Signer.VerifySignature(System.Byte[],Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            return true if the value r and s represent a GOST3410 signature for
            the passed in message (for standard GOST3410 the message should be
            a GOST3411 hash of the real message to be verified).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.ECNRSigner">
            EC-NR as described in IEEE 1363-2000
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.ECNRSigner.GenerateSignature(System.Byte[])">
             generate a signature for the given message using the key we were
             initialised with.  Generally, the order of the curve should be at
             least as long as the hash of the message of interest, and with
             ECNR it *must* be at least as long.
            
             @param digest  the digest to be signed.
             @exception DataLengthException if the digest is longer than the key allows
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.ECNRSigner.VerifySignature(System.Byte[],Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
             return true if the value r and s represent a signature for the
             message passed in. Generally, the order of the curve should be at
             least as long as the hash of the message of interest, and with
             ECNR, it *must* be at least as long.  But just in case the signer
             applied mod(n) to the longer digest, this implementation will
             apply mod(n) during verification.
            
             @param digest  the digest to be verified.
             @param r       the r value of the signature.
             @param s       the s value of the signature.
             @exception DataLengthException if the digest is longer than the key allows
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.Gost3410Signer">
            Gost R 34.10-94 Signature Algorithm
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Gost3410Signer.GenerateSignature(System.Byte[])">
             generate a signature for the given message using the key we were
             initialised with. For conventional Gost3410 the message should be a Gost3411
             hash of the message of interest.
            
             @param message the message that will be verified later.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Gost3410Signer.VerifySignature(System.Byte[],Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            return true if the value r and s represent a Gost3410 signature for
            the passed in message for standard Gost3410 the message should be a
            Gost3411 hash of the real message to be verified.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.IDsaEncoding">
            <summary>
            An interface for different encoding formats for DSA signatures.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.IDsaEncoding.Decode(Org.BouncyCastle.Math.BigInteger,System.Byte[])">
            <summary>Decode the (r, s) pair of a DSA signature.</summary>
            <param name="n">The order of the group that r, s belong to.</param>
            <param name="encoding">An encoding of the (r, s) pair of a DSA signature.</param>
            <returns>The (r, s) of a DSA signature, stored in an array of exactly two elements, r followed by s.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.IDsaEncoding.Encode(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            <summary>Encode the (r, s) pair of a DSA signature.</summary>
            <param name="n">The order of the group that r, s belong to.</param>
            <param name="r">The r value of a DSA signature.</param>
            <param name="s">The s value of a DSA signature.</param>
            <returns>An encoding of the DSA signature given by the provided (r, s) pair.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.IDsaKCalculator">
            Interface define calculators of K values for DSA/ECDSA.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Signers.IDsaKCalculator.IsDeterministic">
             Return true if this calculator is deterministic, false otherwise.
            
             @return true if deterministic, otherwise false.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.IDsaKCalculator.Init(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Security.SecureRandom)">
             Non-deterministic initialiser.
            
             @param n the order of the DSA group.
             @param random a source of randomness.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.IDsaKCalculator.Init(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,System.Byte[])">
             Deterministic initialiser.
            
             @param n the order of the DSA group.
             @param d the DSA private value.
             @param message the message being signed.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.IDsaKCalculator.NextK">
             Return the next valid value of K.
            
             @return a K value.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer">
            <summary> ISO9796-2 - mechanism using a hash function with recovery (scheme 1)</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.GetRecoveredMessage">
            <summary>
            Return a reference to the recoveredMessage message.
            </summary>
            <returns>The full/partial recoveredMessage message.</returns>
            <seealso cref="M:Org.BouncyCastle.Crypto.ISignerWithRecovery.GetRecoveredMessage"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,Org.BouncyCastle.Crypto.IDigest,System.Boolean)">
            <summary>
            Generate a signer with either implicit or explicit trailers for ISO9796-2.
            </summary>
            <param name="cipher">base cipher to use for signature creation/verification</param>
            <param name="digest">digest to use.</param>
            <param name="isImplicit">whether or not the trailer is implicit or gives the hash.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,Org.BouncyCastle.Crypto.IDigest)">
             <summary> Constructor for a signer with an explicit digest trailer.
            
             </summary>
             <param name="cipher">cipher to use.
             </param>
             <param name="digest">digest to sign with.
             </param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.IsSameAs(System.Byte[],System.Byte[])">
            <summary> compare two byte arrays - constant time.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.ClearBlock(System.Byte[])">
            <summary> clear possible sensitive data</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.GenerateSignature">
            <summary> Generate a signature for the loaded message using the key we were
            initialised with.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.VerifySignature(System.Byte[])">
            <summary> return true if the signature represents a ISO9796-2 signature
            for the passed in message.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.Reset">
            <summary> reset the internal state</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.HasFullMessage">
            <summary>
            Return true if the full message was recoveredMessage.
            </summary>
            <returns> true on full message recovery, false otherwise.</returns>
            <seealso cref="M:Org.BouncyCastle.Crypto.ISignerWithRecovery.HasFullMessage"/>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.PssSigner">
            <summary> RSA-PSS as described in Pkcs# 1 v 2.1.
            <p>
            Note: the usual value for the salt length is the number of
            bytes in the hash function.</p>
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,Org.BouncyCastle.Crypto.IDigest,System.Int32)">
            <summary>Basic constructor</summary>
            <param name="cipher">the asymmetric cipher to use.</param>
            <param name="digest">the digest to use.</param>
            <param name="saltLen">the length of the salt to use (in bytes).</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,Org.BouncyCastle.Crypto.IDigest,System.Byte[])">
            <summary>Basic constructor</summary>
            <param name="cipher">the asymmetric cipher to use.</param>
            <param name="digest">the digest to use.</param>
            <param name="salt">the fixed salt to be used.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.ClearBlock(System.Byte[])">
            <summary> clear possible sensitive data</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.ItoOSP(System.Int32,System.Byte[])">
            <summary> int to octet string.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.MaskGeneratorFunction1(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary> mask generator function, as described in Pkcs1v2.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.RsaDigestSigner.#cctor">
            <summary>
            Load oid table.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.RsaDigestSigner.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the signer for signing or verification.
            
             @param forSigning true if for signing, false otherwise
             @param param necessary parameters.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.SM2Signer">
            <summary>The SM2 Digital Signature algorithm.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.X931Signer">
            X9.31-1998 - signing using a hash.
            <p>
            The message digest hash, H, is encapsulated to form a byte string as follows
            </p>
            <pre>
            EB = 06 || PS || 0xBA || H || TRAILER
            </pre>
            where PS is a string of bytes all of value 0xBB of length such that |EB|=|n|, and TRAILER is the ISO/IEC 10118 part number for the digest. The byte string, EB, is converted to an integer value, the message representative, f.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.X931Signer.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,Org.BouncyCastle.Crypto.IDigest,System.Boolean)">
             Generate a signer with either implicit or explicit trailers for X9.31.
            
             @param cipher base cipher to use for signature creation/verification
             @param digest digest to use.
             @param implicit whether or not the trailer is implicit or gives the hash.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.X931Signer.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,Org.BouncyCastle.Crypto.IDigest)">
             Constructor for a signer with an explicit digest trailer.
            
             @param cipher cipher to use.
             @param digest digest to sign with.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.SimpleBlockResult">
            <summary>
            A simple block result object which just carries a byte array.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.SimpleBlockResult.#ctor(System.Byte[])">
            <summary>
            Base constructor - a wrapper for the passed in byte array.
            </summary>
            <param name="result">The byte array to be wrapped.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.SimpleBlockResult.Collect">
            <summary>
            Return the final result of the operation.
            </summary>
            <returns>A block of bytes, representing the result of an operation.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.SimpleBlockResult.Collect(System.Byte[],System.Int32)">
            <summary>
            Store the final result of the operation by copying it into the destination array.
            </summary>
            <returns>The number of bytes copied into destination.</returns>
            <param name="buf">The byte array to copy the result into.</param>
            <param name="off">The offset into destination to start copying the result at.</param>
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.AddMagnitudes(System.UInt32[],System.UInt32[])">
            return a = a + b - b preserved.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.CompareTo(System.Int32,System.UInt32[],System.Int32,System.UInt32[])">
            unsigned comparison on two arrays - note the arrays may
            start with leading zeros.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.Divide(System.UInt32[],System.UInt32[])">
            return z = x / y - done in place (z value preserved, x contains the
            remainder)
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.IsProbablePrime(System.Int32)">
            return whether or not a BigInteger is probably prime with a
            probability of 1 - (1/2)**certainty.
            <p>From Knuth Vol 2, pg 395.</p>
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.ExtEuclid(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger@)">
             Calculate the numbers u1, u2, and u3 such that:
            
             u1 * a + u2 * b = u3
            
             where u3 is the greatest common divider of a and b.
             a and b using the extended Euclid algorithm (refer p. 323
             of The Art of Computer Programming vol 2, 2nd ed).
             This also seems to have the side effect of calculating
             some form of multiplicative inverse.
            
             @param a    First number to calculate gcd for
             @param b    Second number to calculate gcd for
             @param u1Out      the return object for the u1 value
             @return     The greatest common divisor of a and b
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.Square(System.UInt32[],System.UInt32[])">
            return w with w = x * x - w is assumed to have enough space.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.Multiply(System.UInt32[],System.UInt32[],System.UInt32[])">
            return x with x = y * z - x is assumed to have enough space.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.GetMQuote">
            Calculate mQuote = -m^(-1) mod b with b = 2^32 (32 = word size)
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.MultiplyMonty(System.UInt32[],System.UInt32[],System.UInt32[],System.UInt32[],System.UInt32,System.Boolean)">
            Montgomery multiplication: a = x * y * R^(-1) mod m
            <br/>
            Based algorithm 14.36 of Handbook of Applied Cryptography.
            <br/>
            <li> m, x, y should have length n </li>
            <li> a should have length (n + 1) </li>
            <li> b = 2^32, R = b^n </li>
            <br/>
            The result is put in x
            <br/>
            NOTE: the indices of x, y, m, a different in HAC and in Java
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.Remainder(System.UInt32[],System.UInt32[])">
            return x = x % y - done in place (y value preserved)
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.ShiftLeft(System.UInt32[],System.Int32)">
            do a left shift - this returns a new array.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.ShiftRightInPlace(System.Int32,System.UInt32[],System.Int32)">
            do a right shift - this does it in place.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.ShiftRightOneInPlace(System.Int32,System.UInt32[])">
            do a right shift by one - this does it in place.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.Subtract(System.Int32,System.UInt32[],System.Int32,System.UInt32[])">
            returns x = x - y - we assume x is >= y
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal">
            Class representing a simple version of a big decimal. A
            <code>SimpleBigDecimal</code> is basically a
            {@link java.math.BigInteger BigInteger} with a few digits on the right of
            the decimal point. The number of (binary) digits on the right of the decimal
            point is called the <code>scale</code> of the <code>SimpleBigDecimal</code>.
            Unlike in {@link java.math.BigDecimal BigDecimal}, the scale is not adjusted
            automatically, but must be set manually. All <code>SimpleBigDecimal</code>s
            taking part in the same arithmetic operation must have equal scale. The
            result of a multiplication of two <code>SimpleBigDecimal</code>s returns a
            <code>SimpleBigDecimal</code> with double scale.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal.GetInstance(Org.BouncyCastle.Math.BigInteger,System.Int32)">
            Returns a <code>SimpleBigDecimal</code> representing the same numerical
            value as <code>value</code>.
            @param value The value of the <code>SimpleBigDecimal</code> to be
            created. 
            @param scale The scale of the <code>SimpleBigDecimal</code> to be
            created. 
            @return The such created <code>SimpleBigDecimal</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal.#ctor(Org.BouncyCastle.Math.BigInteger,System.Int32)">
            Constructor for <code>SimpleBigDecimal</code>. The value of the
            constructed <code>SimpleBigDecimal</code> Equals <code>bigInt / 
            2<sup>scale</sup></code>.
            @param bigInt The <code>bigInt</code> value parameter.
            @param scale The scale of the constructed <code>SimpleBigDecimal</code>.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Abc.Tnaf">
            Class holding methods for point multiplication based on the window
            &#964;-adic nonadjacent form (WTNAF). The algorithms are based on the
            paper "Improved Algorithms for Arithmetic on Anomalous Binary Curves"
            by Jerome A. Solinas. The paper first appeared in the Proceedings of
            Crypto 1997.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.Tnaf.Width">
            The window width of WTNAF. The standard value of 4 is slightly less
            than optimal for running time, but keeps space requirements for
            precomputation low. For typical curves, a value of 5 or 6 results in
            a better running time. When changing this value, the
            <code>&#945;<sub>u</sub></code>'s must be computed differently, see
            e.g. "Guide to Elliptic Curve Cryptography", Darrel Hankerson,
            Alfred Menezes, Scott Vanstone, Springer-Verlag New York Inc., 2004,
            p. 121-122
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.Tnaf.Alpha0">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=0</code> as an array
            of <code>ZTauElement</code>s.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.Tnaf.Alpha0Tnaf">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=0</code> as an array
            of TNAFs.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.Tnaf.Alpha1">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=1</code> as an array
            of <code>ZTauElement</code>s.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.Tnaf.Alpha1Tnaf">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=1</code> as an array
            of TNAFs.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.Norm(System.SByte,Org.BouncyCastle.Math.EC.Abc.ZTauElement)">
            Computes the norm of an element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @return The norm of <code>&#955;</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.Norm(System.SByte,Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal,Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal)">
            Computes the norm of an element <code>&#955;</code> of
            <code><b>R</b>[&#964;]</code>, where <code>&#955; = u + v&#964;</code>
            and <code>u</code> and <code>u</code> are real numbers (elements of
            <code><b>R</b></code>). 
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param u The real part of the element <code>&#955;</code> of
            <code><b>R</b>[&#964;]</code>.
            @param v The <code>&#964;</code>-adic part of the element
            <code>&#955;</code> of <code><b>R</b>[&#964;]</code>.
            @return The norm of <code>&#955;</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.Round(Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal,Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal,System.SByte)">
            Rounds an element <code>&#955;</code> of <code><b>R</b>[&#964;]</code>
            to an element of <code><b>Z</b>[&#964;]</code>, such that their difference
            has minimal norm. <code>&#955;</code> is given as
            <code>&#955; = &#955;<sub>0</sub> + &#955;<sub>1</sub>&#964;</code>.
            @param lambda0 The component <code>&#955;<sub>0</sub></code>.
            @param lambda1 The component <code>&#955;<sub>1</sub></code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve. Must
            equal 1 or -1.
            @return The rounded element of <code><b>Z</b>[&#964;]</code>.
            @throws ArgumentException if <code>lambda0</code> and
            <code>lambda1</code> do not have same scale.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.ApproximateDivisionByN(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,System.SByte,System.Int32,System.Int32)">
            Approximate division by <code>n</code>. For an integer
            <code>k</code>, the value <code>&#955; = s k / n</code> is
            computed to <code>c</code> bits of accuracy.
            @param k The parameter <code>k</code>.
            @param s The curve parameter <code>s<sub>0</sub></code> or
            <code>s<sub>1</sub></code>.
            @param vm The Lucas Sequence element <code>V<sub>m</sub></code>.
            @param a The parameter <code>a</code> of the elliptic curve.
            @param m The bit length of the finite field
            <code><b>F</b><sub>m</sub></code>.
            @param c The number of bits of accuracy, i.e. the scale of the returned
            <code>SimpleBigDecimal</code>.
            @return The value <code>&#955; = s k / n</code> computed to
            <code>c</code> bits of accuracy.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.TauAdicNaf(System.SByte,Org.BouncyCastle.Math.EC.Abc.ZTauElement)">
            Computes the <code>&#964;</code>-adic NAF (non-adjacent form) of an
            element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @return The <code>&#964;</code>-adic NAF of <code>&#955;</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.Tau(Org.BouncyCastle.Math.EC.AbstractF2mPoint)">
            Applies the operation <code>&#964;()</code> to an
            <code>AbstractF2mPoint</code>. 
            @param p The AbstractF2mPoint to which <code>&#964;()</code> is applied.
            @return <code>&#964;(p)</code>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.GetMu(Org.BouncyCastle.Math.EC.AbstractF2mCurve)">
            Returns the parameter <code>&#956;</code> of the elliptic curve.
            @param curve The elliptic curve from which to obtain <code>&#956;</code>.
            The curve must be a Koblitz curve, i.e. <code>a</code> Equals
            <code>0</code> or <code>1</code> and <code>b</code> Equals
            <code>1</code>. 
            @return <code>&#956;</code> of the elliptic curve.
            @throws ArgumentException if the given ECCurve is not a Koblitz
            curve.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.GetLucas(System.SByte,System.Int32,System.Boolean)">
            Calculates the Lucas Sequence elements <code>U<sub>k-1</sub></code> and
            <code>U<sub>k</sub></code> or <code>V<sub>k-1</sub></code> and
            <code>V<sub>k</sub></code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param k The index of the second element of the Lucas Sequence to be
            returned.
            @param doV If set to true, computes <code>V<sub>k-1</sub></code> and
            <code>V<sub>k</sub></code>, otherwise <code>U<sub>k-1</sub></code> and
            <code>U<sub>k</sub></code>.
            @return An array with 2 elements, containing <code>U<sub>k-1</sub></code>
            and <code>U<sub>k</sub></code> or <code>V<sub>k-1</sub></code>
            and <code>V<sub>k</sub></code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.GetTw(System.SByte,System.Int32)">
            Computes the auxiliary value <code>t<sub>w</sub></code>. If the width is
            4, then for <code>mu = 1</code>, <code>t<sub>w</sub> = 6</code> and for
            <code>mu = -1</code>, <code>t<sub>w</sub> = 10</code> 
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param w The window width of the WTNAF.
            @return the auxiliary value <code>t<sub>w</sub></code>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.GetSi(Org.BouncyCastle.Math.EC.AbstractF2mCurve)">
            Computes the auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code> used for partial modular reduction. 
            @param curve The elliptic curve for which to compute
            <code>s<sub>0</sub></code> and <code>s<sub>1</sub></code>.
            @throws ArgumentException if <code>curve</code> is not a
            Koblitz curve (Anomalous Binary Curve, ABC).
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.PartModReduction(Org.BouncyCastle.Math.EC.AbstractF2mCurve,Org.BouncyCastle.Math.BigInteger,System.SByte,System.SByte,System.SByte)">
            Partial modular reduction modulo
            <code>(&#964;<sup>m</sup> - 1)/(&#964; - 1)</code>.
            @param k The integer to be reduced.
            @param m The bitlength of the underlying finite field.
            @param a The parameter <code>a</code> of the elliptic curve.
            @param s The auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code>.
            @param mu The parameter &#956; of the elliptic curve.
            @param c The precision (number of bits of accuracy) of the partial
            modular reduction.
            @return <code>&#961; := k partmod (&#964;<sup>m</sup> - 1)/(&#964; - 1)</code>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.MultiplyRTnaf(Org.BouncyCastle.Math.EC.AbstractF2mPoint,Org.BouncyCastle.Math.BigInteger)">
            Multiplies a {@link org.bouncycastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by a <code>BigInteger</code> using the reduced <code>&#964;</code>-adic
            NAF (RTNAF) method.
            @param p The AbstractF2mPoint to Multiply.
            @param k The <code>BigInteger</code> by which to Multiply <code>p</code>.
            @return <code>k * p</code>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.MultiplyTnaf(Org.BouncyCastle.Math.EC.AbstractF2mPoint,Org.BouncyCastle.Math.EC.Abc.ZTauElement)">
            Multiplies a {@link org.bouncycastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>
            using the <code>&#964;</code>-adic NAF (TNAF) method.
            @param p The AbstractF2mPoint to Multiply.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @return <code>&#955; * p</code>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.MultiplyFromTnaf(Org.BouncyCastle.Math.EC.AbstractF2mPoint,Org.BouncyCastle.Math.EC.AbstractF2mPoint,System.SByte[])">
            Multiplies a {@link org.bouncycastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>
            using the <code>&#964;</code>-adic NAF (TNAF) method, given the TNAF
            of <code>&#955;</code>.
            @param p The AbstractF2mPoint to Multiply.
            @param u The the TNAF of <code>&#955;</code>..
            @return <code>&#955; * p</code>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.TauAdicWNaf(System.SByte,Org.BouncyCastle.Math.EC.Abc.ZTauElement,System.Int32,System.Int32,Org.BouncyCastle.Math.EC.Abc.ZTauElement[])">
            Computes the <code>[&#964;]</code>-adic window NAF of an element
            <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>.
            @param mu The parameter &#956; of the elliptic curve.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code> of which to compute the
            <code>[&#964;]</code>-adic NAF.
            @param width The window width of the resulting WNAF.
            @param pow2w 2<sup>width</sup>.
            @param tw The auxiliary value <code>t<sub>w</sub></code>.
            @param alpha The <code>&#945;<sub>u</sub></code>'s for the window width.
            @return The <code>[&#964;]</code>-adic window NAF of
            <code>&#955;</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.GetPreComp(Org.BouncyCastle.Math.EC.AbstractF2mPoint,System.SByte)">
            Does the precomputation for WTNAF multiplication.
            @param p The <code>ECPoint</code> for which to do the precomputation.
            @param a The parameter <code>a</code> of the elliptic curve.
            @return The precomputation array for <code>p</code>. 
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Abc.ZTauElement">
            Class representing an element of <code><b>Z</b>[&#964;]</code>. Let
            <code>&#955;</code> be an element of <code><b>Z</b>[&#964;]</code>. Then
            <code>&#955;</code> is given as <code>&#955; = u + v&#964;</code>. The
            components <code>u</code> and <code>v</code> may be used directly, there
            are no accessor methods.
            Immutable class.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.ZTauElement.u">
            The &quot;real&quot; part of <code>&#955;</code>.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.ZTauElement.v">
            The &quot;<code>&#964;</code>-adic&quot; part of <code>&#955;</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.ZTauElement.#ctor(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            Constructor for an element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @param u The &quot;real&quot; part of <code>&#955;</code>.
            @param v The &quot;<code>&#964;</code>-adic&quot; part of
            <code>&#955;</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.GM.SM2P256V1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP128R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R2FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP192K1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP192R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP224K1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP224R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP256K1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP256R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP384R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP521R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECAlgorithms.ReferenceMultiply(Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger)">
            Simple shift-and-add multiplication. Serves as reference implementation to verify (possibly
            faster) implementations, and for very small scalars. CAUTION: This implementation is NOT
            constant-time in any way. It is only intended to be used for diagnostics.
            
            @param p
                       The point to multiply.
            @param k
                       The multiplier.
            @return The result of the point multiplication <code>kP</code>.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.ECCurve">
            <remarks>Base class for an elliptic curve.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECCurve.Precompute(Org.BouncyCastle.Math.EC.ECPoint,System.String,Org.BouncyCastle.Math.EC.Multiplier.IPreCompCallback)">
            Compute a <code>PreCompInfo</code> for a point on this curve, under a given name. Used by
            <code>ECMultiplier</code>s to save the precomputation for this <code>ECPoint</code> for use
            by subsequent multiplication.
            
            @param point
                       The <code>ECPoint</code> to store precomputations for.
            @param name
                       A <code>String</code> used to index precomputations of different types.
            @param callback
                       Called to calculate the <code>PreCompInfo</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECCurve.NormalizeAll(Org.BouncyCastle.Math.EC.ECPoint[])">
            Normalization ensures that any projective coordinate is 1, and therefore that the x, y
            coordinates reflect those of the equivalent point in an affine coordinate system. Where more
            than one point is to be normalized, this method will generally be more efficient than
            normalizing each point separately.
            
            @param points
                       An array of points that will be updated in place with their normalized versions,
                       where necessary
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECCurve.NormalizeAll(Org.BouncyCastle.Math.EC.ECPoint[],System.Int32,System.Int32,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Normalization ensures that any projective coordinate is 1, and therefore that the x, y
            coordinates reflect those of the equivalent point in an affine coordinate system. Where more
            than one point is to be normalized, this method will generally be more efficient than
            normalizing each point separately. An (optional) z-scaling factor can be applied; effectively
            each z coordinate is scaled by this value prior to normalization (but only one
            actual multiplication is needed).
            
            @param points
                       An array of points that will be updated in place with their normalized versions,
                       where necessary
            @param off
                       The start of the range of points to normalize
            @param len
                       The length of the range of points to normalize
            @param iso
                       The (optional) z-scaling factor - can be null
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECCurve.CreateCacheSafeLookupTable(Org.BouncyCastle.Math.EC.ECPoint[],System.Int32,System.Int32)">
            Create a cache-safe lookup table for the specified sequence of points. All the points MUST
            belong to this <code>ECCurve</code> instance, and MUST already be normalized.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECCurve.GetMultiplier">
             Sets the default <code>ECMultiplier</code>, unless already set.
            
             We avoid locking for performance reasons, so there is no uniqueness guarantee.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECCurve.DecodePoint(System.Byte[])">
            Decode a point on this curve from its ASN.1 encoding. The different
            encodings are taken account of, including point compression for
            <code>F<sub>p</sub></code> (X9.62 s 4.2.1 pg 17).
            @return The decoded point.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.FpCurve">
            Elliptic curve over Fp
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.AbstractF2mCurve.SolveQuadraticEquation(Org.BouncyCastle.Math.EC.ECFieldElement)">
             Solves a quadratic equation <code>z<sup>2</sup> + z = beta</code>(X9.62
             D.1.6) The other solution is <code>z + 1</code>.
            
             @param beta
                        The value to solve the quadratic equation for.
             @return the solution for <code>z<sup>2</sup> + z = beta</code> or
                     <code>null</code> if no solution exists.
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.AbstractF2mCurve.IsKoblitz">
            Returns true if this is a Koblitz curve (ABC curve).
            @return true if this is a Koblitz curve (ABC curve), false otherwise
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.F2mCurve">
            Elliptic curves over F2m. The Weierstrass equation is given by
            <code>y<sup>2</sup> + xy = x<sup>3</sup> + ax<sup>2</sup> + b</code>.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mCurve.m">
            The exponent <code>m</code> of <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mCurve.k1">
            TPB: The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction polynomial
            <code>f(z)</code>.<br/>
            PPB: The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mCurve.k2">
            TPB: Always set to <code>0</code><br/>
            PPB: The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mCurve.k3">
            TPB: Always set to <code>0</code><br/>
            PPB: The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mCurve.m_infinity">
            The point at infinity on this curve.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mCurve.#ctor(System.Int32,System.Int32,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            Constructor for Trinomial Polynomial Basis (TPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction
            polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mCurve.#ctor(System.Int32,System.Int32,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            Constructor for Trinomial Polynomial Basis (TPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction
            polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param order The order of the main subgroup of the elliptic curve.
            @param cofactor The cofactor of the elliptic curve, i.e.
            <code>#E<sub>a</sub>(F<sub>2<sup>m</sup></sub>) = h * n</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mCurve.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            Constructor for Pentanomial Polynomial Basis (PPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mCurve.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            Constructor for Pentanomial Polynomial Basis (PPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param order The order of the main subgroup of the elliptic curve.
            @param cofactor The cofactor of the elliptic curve, i.e.
            <code>#E<sub>a</sub>(F<sub>2<sup>m</sup></sub>) = h * n</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mCurve.IsTrinomial">
             Return true if curve uses a Trinomial basis.
            
             @return true if curve Trinomial, false otherwise.
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.FpFieldElement.FieldName">
             return the field name for this field.
            
             @return the string "Fp".
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.FpFieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation
            returns the right value - if none exists it returns null.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.F2mFieldElement">
            Class representing the Elements of the finite field
            <code>F<sub>2<sup>m</sup></sub></code> in polynomial basis (PB)
            representation. Both trinomial (Tpb) and pentanomial (Ppb) polynomial
            basis representations are supported. Gaussian normal basis (GNB)
            representation is not supported.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.Gnb">
            Indicates gaussian normal basis representation (GNB). Number chosen
            according to X9.62. GNB is not implemented at present.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.Tpb">
            Indicates trinomial basis representation (Tpb). Number chosen
            according to X9.62.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.Ppb">
            Indicates pentanomial basis representation (Ppb). Number chosen
            according to X9.62.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.representation">
            Tpb or Ppb.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.m">
            The exponent <code>m</code> of <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.x">
            The <code>LongArray</code> holding the bits.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mFieldElement.CheckFieldElements(Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Checks, if the ECFieldElements <code>a</code> and <code>b</code>
            are elements of the same field <code>F<sub>2<sup>m</sup></sub></code>
            (having the same representation).
            @param a field element.
            @param b field element to be compared.
            @throws ArgumentException if <code>a</code> and <code>b</code>
            are not elements of the same field
            <code>F<sub>2<sup>m</sup></sub></code> (having the same
            representation).
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.F2mFieldElement.Representation">
            @return the representation of the field
            <code>F<sub>2<sup>m</sup></sub></code>, either of
            {@link F2mFieldElement.Tpb} (trinomial
            basis representation) or
            {@link F2mFieldElement.Ppb} (pentanomial
            basis representation).
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.F2mFieldElement.M">
            @return the degree <code>m</code> of the reduction polynomial
            <code>f(z)</code>.
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.F2mFieldElement.K1">
            @return Tpb: The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction polynomial
            <code>f(z)</code>.<br/>
            Ppb: The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.F2mFieldElement.K2">
            @return Tpb: Always returns <code>0</code><br/>
            Ppb: The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.F2mFieldElement.K3">
            @return Tpb: Always set to <code>0</code><br/>
            Ppb: The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.ECPoint">
            base class for points on elliptic curves.
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.ECPoint.AffineXCoord">
            Returns the affine x-coordinate after checking that this point is normalized.
            
            @return The affine x-coordinate of this point
            @throws IllegalStateException if the point is not normalized
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.ECPoint.AffineYCoord">
            Returns the affine y-coordinate after checking that this point is normalized
            
            @return The affine y-coordinate of this point
            @throws IllegalStateException if the point is not normalized
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.ECPoint.XCoord">
            Returns the x-coordinate.
            
            Caution: depending on the curve's coordinate system, this may not be the same value as in an
            affine coordinate system; use Normalize() to get a point where the coordinates have their
            affine values, or use AffineXCoord if you expect the point to already have been normalized.
            
            @return the x-coordinate of this point
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.ECPoint.YCoord">
            Returns the y-coordinate.
            
            Caution: depending on the curve's coordinate system, this may not be the same value as in an
            affine coordinate system; use Normalize() to get a point where the coordinates have their
            affine values, or use AffineYCoord if you expect the point to already have been normalized.
            
            @return the y-coordinate of this point
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECPoint.Normalize">
            Normalization ensures that any projective coordinate is 1, and therefore that the x, y
            coordinates reflect those of the equivalent point in an affine coordinate system.
            
            @return a new ECPoint instance representing the same point, but with normalized coordinates
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECPointBase.GetEncoded(System.Boolean)">
            return the field element encoded with point compression. (S 4.3.6)
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECPointBase.Multiply(Org.BouncyCastle.Math.BigInteger)">
            Multiplies this <code>ECPoint</code> by the given number.
            @param k The multiplicator.
            @return <code>k * this</code>.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.FpPoint">
            Elliptic curve points over Fp
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.F2mPoint">
            Elliptic curve points over F2m
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.ECMultiplier">
            Interface for classes encapsulating a point multiplication algorithm
            for <code>ECPoint</code>s.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.ECMultiplier.Multiply(Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger)">
            Multiplies the <code>ECPoint p</code> by <code>k</code>, i.e.
            <code>p</code> is added <code>k</code> times to itself.
            @param p The <code>ECPoint</code> to be multiplied.
            @param k The factor by which <code>p</code> is multiplied.
            @return <code>p</code> multiplied by <code>k</code>.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.FixedPointPreCompInfo">
            Class holding precomputation data for fixed-point multiplications.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Multiplier.FixedPointPreCompInfo.m_lookupTable">
            Lookup table for the precomputed <code>ECPoint</code>s used for a fixed point multiplication.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Multiplier.FixedPointPreCompInfo.m_width">
            The width used for the precomputation. If a larger width precomputation
            is already available this may be larger than was requested, so calling
            code should refer to the actual width.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.PreCompInfo">
            Interface for classes storing precomputation data for multiplication
            algorithms. Used as a Memento (see GOF patterns) for
            <code>WNafMultiplier</code>.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.WNafL2RMultiplier">
            Class implementing the WNAF (Window Non-Adjacent Form) multiplication
            algorithm.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WNafL2RMultiplier.MultiplyPositive(Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger)">
            Multiplies <code>this</code> by an integer <code>k</code> using the
            Window NAF method.
            @param k The integer by which <code>this</code> is multiplied.
            @return A new <code>ECPoint</code> which equals <code>this</code>
            multiplied by <code>k</code>.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo">
            Class holding precomputation data for the WNAF (Window Non-Adjacent Form)
            algorithm.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo.m_preComp">
            Array holding the precomputed <code>ECPoint</code>s used for a Window
            NAF multiplication.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo.m_preCompNeg">
            Array holding the negations of the precomputed <code>ECPoint</code>s used
            for a Window NAF multiplication.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo.m_twice">
            Holds an <code>ECPoint</code> representing Twice(this). Used for the
            Window NAF multiplication to create or extend the precomputed values.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WNafUtilities.GenerateWindowNaf(System.Int32,Org.BouncyCastle.Math.BigInteger)">
            Computes the Window NAF (non-adjacent Form) of an integer.
            @param width The width <code>w</code> of the Window NAF. The width is
            defined as the minimal number <code>w</code>, such that for any
            <code>w</code> consecutive digits in the resulting representation, at
            most one is non-zero.
            @param k The integer of which the Window NAF is computed.
            @return The Window NAF of the given width, such that the following holds:
            <code>k = &amp;sum;<sub>i=0</sub><sup>l-1</sup> k<sub>i</sub>2<sup>i</sup>
            </code>, where the <code>k<sub>i</sub></code> denote the elements of the
            returned <code>byte[]</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WNafUtilities.GetWindowSize(System.Int32)">
            Determine window width to use for a scalar multiplication of the given size.
            
            @param bits the bit-length of the scalar to multiply by
            @return the window size to use
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WNafUtilities.GetWindowSize(System.Int32,System.Int32)">
            Determine window width to use for a scalar multiplication of the given size.
            
            @param bits the bit-length of the scalar to multiply by
            @param maxWidth the maximum window width to return 
            @return the window size to use
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WNafUtilities.GetWindowSize(System.Int32,System.Int32[])">
            Determine window width to use for a scalar multiplication of the given size.
            
            @param bits the bit-length of the scalar to multiply by
            @param windowSizeCutoffs a monotonically increasing list of bit sizes at which to increment the window width
            @return the window size to use
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WNafUtilities.GetWindowSize(System.Int32,System.Int32[],System.Int32)">
            Determine window width to use for a scalar multiplication of the given size.
            
            @param bits the bit-length of the scalar to multiply by
            @param windowSizeCutoffs a monotonically increasing list of bit sizes at which to increment the window width
            @param maxWidth the maximum window width to return 
            @return the window size to use
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier">
            Class implementing the WTNAF (Window
            <code>&#964;</code>-adic Non-Adjacent Form) algorithm.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier.MultiplyPositive(Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger)">
            Multiplies a {@link org.bouncycastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by <code>k</code> using the reduced <code>&#964;</code>-adic NAF (RTNAF)
            method.
            @param p The AbstractF2mPoint to multiply.
            @param k The integer by which to multiply <code>k</code>.
            @return <code>p</code> multiplied by <code>k</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier.MultiplyWTnaf(Org.BouncyCastle.Math.EC.AbstractF2mPoint,Org.BouncyCastle.Math.EC.Abc.ZTauElement,System.SByte,System.SByte)">
            Multiplies a {@link org.bouncycastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code> using
            the <code>&#964;</code>-adic NAF (TNAF) method.
            @param p The AbstractF2mPoint to multiply.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code> of which to compute the
            <code>[&#964;]</code>-adic NAF.
            @return <code>p</code> multiplied by <code>&#955;</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier.MultiplyFromWTnaf(Org.BouncyCastle.Math.EC.AbstractF2mPoint,System.SByte[])">
            Multiplies a {@link org.bouncycastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>
            using the window <code>&#964;</code>-adic NAF (TNAF) method, given the
            WTNAF of <code>&#955;</code>.
            @param p The AbstractF2mPoint to multiply.
            @param u The the WTNAF of <code>&#955;</code>..
            @return <code>&#955; * p</code>
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.WTauNafPreCompInfo">
            Class holding precomputation data for the WTNAF (Window
            <code>&#964;</code>-adic Non-Adjacent Form) algorithm.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Multiplier.WTauNafPreCompInfo.m_preComp">
            Array holding the precomputed <code>AbstractF2mPoint</code>s used for the
            WTNAF multiplication in <code>
            {@link org.bouncycastle.math.ec.multiplier.WTauNafMultiplier.multiply()
            WTauNafMultiplier.multiply()}</code>.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Rfc8032.Ed25519">
            <summary>
            A low-level implementation of the Ed25519, Ed25519ctx, and Ed25519ph instantiations of the Edwards-Curve Digital
            Signature Algorithm specified in <a href="https://www.rfc-editor.org/rfc/rfc8032">RFC 8032</a>.
            </summary>
            <remarks>
            The implementation strategy is mostly drawn from <a href="https://ia.cr/2012/309">
            Mike Hamburg, "Fast and compact elliptic-curve cryptography"</a>, notably the "signed multi-comb" algorithm (for
            scalar multiplication by a fixed point), the "half Niels coordinates" (for precomputed points), and the
            "extensible coordinates" (for accumulators). Standard
            <a href="https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html">extended coordinates</a> are used during
            precomputations, needing only a single extra point addition formula.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Rfc8032.Ed448">
            <summary>
            A low-level implementation of the Ed448 and Ed448ph instantiations of the Edwards-Curve Digital Signature
            Algorithm specified in <a href="https://www.rfc-editor.org/rfc/rfc8032">RFC 8032</a>.
            </summary>
            <remarks>
            The implementation uses the "signed mult-comb" algorithm (for scalar multiplication by a fixed point) from
            <a href="https://ia.cr/2012/309">Mike Hamburg, "Fast and compact elliptic-curve cryptography"</a>. Standard
            <a href="https://hyperelliptic.org/EFD/g1p/auto-edwards-projective.html">projective coordinates</a> are used
            for most point arithmetic.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Math.Primes">
            <summary>Utility methods for generating primes and testing for primality.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Math.Primes.MROutput">
            <summary>Used to return the output from the
            <see cref="M:Org.BouncyCastle.Math.Primes.EnhancedMRProbablePrimeTest(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Security.SecureRandom,System.Int32)">
            Enhanced Miller-Rabin Probabilistic Primality Test</see></summary>
        </member>
        <member name="T:Org.BouncyCastle.Math.Primes.STOutput">
            <summary>Used to return the output from the <see cref="M:Org.BouncyCastle.Math.Primes.GenerateSTRandomPrime(Org.BouncyCastle.Crypto.IDigest,System.Int32,System.Byte[])">
            Shawe-Taylor Random_Prime Routine</see></summary>
        </member>
        <member name="M:Org.BouncyCastle.Math.Primes.GenerateSTRandomPrime(Org.BouncyCastle.Crypto.IDigest,System.Int32,System.Byte[])">
            <summary>FIPS 186-4 C.6 Shawe-Taylor Random_Prime Routine.</summary>
            <remarks>Construct a provable prime number using a hash function.</remarks>
            <param name="hash">The <see cref="T:Org.BouncyCastle.Crypto.IDigest"/> instance to use (as "Hash()"). Cannot be null.</param>
            <param name="length">The length (in bits) of the prime to be generated. Must be at least 2.</param>
            <param name="inputSeed">The seed to be used for the generation of the requested prime. Cannot be null or
            empty.</param>
            <returns>An <see cref="T:Org.BouncyCastle.Math.Primes.STOutput"/> instance containing the requested prime.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Math.Primes.EnhancedMRProbablePrimeTest(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Security.SecureRandom,System.Int32)">
            <summary>FIPS 186-4 C.3.2 Enhanced Miller-Rabin Probabilistic Primality Test.</summary>
            <remarks>
            Run several iterations of the Miller-Rabin algorithm with randomly-chosen bases. This is an alternative to
            <see cref="M:Org.BouncyCastle.Math.Primes.IsMRProbablePrime(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Security.SecureRandom,System.Int32)"/> that provides more information about a
            composite candidate, which may be useful when generating or validating RSA moduli.
            </remarks>
            <param name="candidate">The <see cref="T:Org.BouncyCastle.Math.BigInteger"/> instance to test for primality.</param>
            <param name="random">The source of randomness to use to choose bases.</param>
            <param name="iterations">The number of randomly-chosen bases to perform the test for.</param>
            <returns>An <see cref="T:Org.BouncyCastle.Math.Primes.MROutput"/> instance that can be further queried for details.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Math.Primes.HasAnySmallFactors(Org.BouncyCastle.Math.BigInteger)">
            <summary>A fast check for small divisors, up to some implementation-specific limit.</summary>
            <param name="candidate">The <see cref="T:Org.BouncyCastle.Math.BigInteger"/> instance to test for division by small factors.</param>
            <returns><c>true</c> if the candidate is found to have any small factors, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Math.Primes.IsMRProbablePrime(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Security.SecureRandom,System.Int32)">
            <summary>FIPS 186-4 C.3.1 Miller-Rabin Probabilistic Primality Test.</summary>
            <remarks>Run several iterations of the Miller-Rabin algorithm with randomly-chosen bases.</remarks>
            <param name="candidate">The <see cref="T:Org.BouncyCastle.Math.BigInteger"/> instance to test for primality.</param>
            <param name="random">The source of randomness to use to choose bases.</param>
            <param name="iterations">The number of randomly-chosen bases to perform the test for.</param>
            <returns>
            <c>false</c> if any witness to compositeness is found amongst the chosen bases (so
            <paramref name="candidate"/> is definitely NOT prime), or else <c>true</c> (indicating primality with some
            probability dependent on the number of iterations that were performed).
            </returns>
        </member>
        <member name="M:Org.BouncyCastle.Math.Primes.IsMRProbablePrimeToBase(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            <summary>FIPS 186-4 C.3.1 Miller-Rabin Probabilistic Primality Test (to a fixed base).</summary>
            <remarks>Run a single iteration of the Miller-Rabin algorithm against the specified base.</remarks>
            <param name="candidate">The <see cref="T:Org.BouncyCastle.Math.BigInteger"/> instance to test for primality.</param>
            <param name="baseValue">The base value to use for this iteration.</param>
            <returns><c>false</c> if <paramref name="baseValue"/> is a witness to compositeness (so
            <paramref name="candidate"/> is definitely NOT prime), or else <c>true</c>.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Pkcs.PkcsException">
            <summary>Base exception for PKCS related issues.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Pkcs.PkcsIOException">
            <summary>Base exception for parsing related issues in the PKCS namespace.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.PrivateKeyInfoFactory.CreatePrivateKeyInfo(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.Asn1.Asn1Set)">
             Create a PrivateKeyInfo representation of a private key with attributes.
            
             @param privateKey the key to be encoded into the info object.
             @param attributes the set of attributes to be included.
             @return the appropriate PrivateKeyInfo
             @throws java.io.IOException on an error encoding the key
        </member>
        <member name="T:Org.BouncyCastle.Security.AgreementUtilities">
            <remarks>
             Utility class for creating IBasicAgreement objects from their names/Oids
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Security.CipherUtilities">
            <remarks>
             Cipher Utility class contains methods that can not be specifically grouped into other classes.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Security.DigestUtilities">
            <remarks>
             Utility class for creating IDigest objects from their names/Oids
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Security.DigestUtilities.GetObjectIdentifier(System.String)">
            <summary>
            Returns a ObjectIdentifier for a given digest mechanism.
            </summary>
            <param name="mechanism">A string representation of the digest meanism.</param>
            <returns>A DerObjectIdentifier, null if the Oid is not available.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Security.MacUtilities">
            <remarks>
             Utility class for creating HMac object from their names/Oids
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Security.PbeUtilities">
             <summary>
            
             </summary>
        </member>
        <member name="M:Org.BouncyCastle.Security.PbeUtilities.GetObjectIdentifier(System.String)">
            <summary>
            Returns a ObjectIdentifier for a give encoding.
            </summary>
            <param name="mechanism">A string representation of the encoding.</param>
            <returns>A DerObjectIdentifier, null if the Oid is not available.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Security.SecureRandom.GetInstance(System.String)">
            <summary>
            Create and auto-seed an instance based on the given algorithm.
            </summary>
            <remarks>Equivalent to GetInstance(algorithm, true)</remarks>
            <param name="algorithm">e.g. "SHA256PRNG"</param>
        </member>
        <member name="M:Org.BouncyCastle.Security.SecureRandom.GetInstance(System.String,System.Boolean)">
            <summary>
            Create an instance based on the given algorithm, with optional auto-seeding
            </summary>
            <param name="algorithm">e.g. "SHA256PRNG"</param>
            <param name="autoSeed">If true, the instance will be auto-seeded.</param>
        </member>
        <member name="M:Org.BouncyCastle.Security.SecureRandom.#ctor(Org.BouncyCastle.Crypto.Prng.IRandomGenerator)">
            <summary>Use the specified instance of IRandomGenerator as random source.</summary>
            <remarks>
            This constructor performs no seeding of either the <c>IRandomGenerator</c> or the
            constructed <c>SecureRandom</c>. It is the responsibility of the client to provide
            proper seed material as necessary/appropriate for the given <c>IRandomGenerator</c>
            implementation.
            </remarks>
            <param name="generator">The source to generate all random bytes from.</param>
        </member>
        <member name="T:Org.BouncyCastle.Security.SignerUtilities">
            <summary>
             Signer Utility class contains methods that can not be specifically grouped into other classes.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Security.SignerUtilities.GetObjectIdentifier(System.String)">
            <summary>
            Returns an ObjectIdentifier for a given encoding.
            </summary>
            <param name="mechanism">A string representation of the encoding.</param>
            <returns>A DerObjectIdentifier, null if the OID is not available.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Security.WrapperUtilities">
            <remarks>
             Utility class for creating IWrapper objects from their names/Oids
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Arrays">
            <summary> General array utilities.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Arrays.AreEqual(System.Byte[],System.Byte[])">
            <summary>
            Are two arrays equal.
            </summary>
            <param name="a">Left side.</param>
            <param name="b">Right side.</param>
            <returns>True if equal.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Arrays.CopyOfRange(System.Byte[],System.Int32,System.Int32)">
             Make a copy of a range of bytes from the passed in data array. The range can
             extend beyond the end of the input array, in which case the return array will
             be padded with zeroes.
            
             @param data the array from which the data is to be copied.
             @param from the start index at which the copying should take place.
             @param to the final index of the range (exclusive).
            
             @return a new byte array containing the range given.
        </member>
        <member name="T:Org.BouncyCastle.Utilities.BigIntegers">
            BigInteger utilities.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.BigIntegers.AsUnsignedByteArray(Org.BouncyCastle.Math.BigInteger)">
             Return the passed in value as an unsigned byte array.
            
             @param value the value to be converted.
             @return a byte array without a leading zero byte if present in the signed encoding.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.BigIntegers.AsUnsignedByteArray(System.Int32,Org.BouncyCastle.Math.BigInteger)">
            Return the passed in value as an unsigned byte array of the specified length, padded with
            leading zeros as necessary.
            @param length the fixed length of the result.
            @param n the value to be converted.
            @return a byte array padded to a fixed length with leading zeros.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.BigIntegers.AsUnsignedByteArray(Org.BouncyCastle.Math.BigInteger,System.Byte[],System.Int32,System.Int32)">
             Write the passed in value as unsigned bytes to the specified buffer range, padded with
             leading zeros as necessary.
            
             @param n
                        the value to be converted.
             @param buf
                        the buffer to which the value is written.
             @param off
                        the start offset in array <code>buf</code> at which the data is written.
             @param len
                        the fixed length of data written (possibly padded with leading zeros).
        </member>
        <member name="M:Org.BouncyCastle.Utilities.BigIntegers.CreateRandomBigInteger(System.Int32,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Creates a Random BigInteger from the secure random of a given bit length.
            </summary>
            <param name="bitLength"></param>
            <param name="secureRandom"></param>
            <returns></returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.BigIntegers.CreateRandomInRange(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Security.SecureRandom)">
            Return a random BigInteger not less than 'min' and not greater than 'max'
            
            @param min the least value that may be generated
            @param max the greatest value that may be generated
            @param random the source of randomness
            @return a random BigInteger value in the range [min,max]
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Bzip2.BZip2Constants">
             Base class for both the compress and decompress classes.
             Holds common arrays, and static data.
            
             @author <a href="mailto:keiron@aftexsw.com">Keiron Liddle</a>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Bzip2.CBZip2InputStream">
             An input stream that decompresses from the BZip2 format (with the file
             header chars) to be read as any other stream.
            
             @author <a href="mailto:keiron@aftexsw.com">Keiron Liddle</a>
            
             <b>NB:</b> note this class has been modified to read the leading BZ from the
             start of the BZIP2 stream to make it compatible with other PGP programs.
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Bzip2.CBZip2OutputStream">
             An output stream that compresses into the BZip2 format (with the file
             header chars) into another stream.
            
             @author <a href="mailto:keiron@aftexsw.com">Keiron Liddle</a>
            
             TODO:    Update to BZip2 1.0.1
             <b>NB:</b> note this class has been modified to add a leading BZ to the
             start of the BZIP2 stream to make it compatible with other PGP programs.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Bzip2.CBZip2OutputStream.WriteByte(System.Byte)">
            
             modified by Oliver Merkel, 010128
            
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Bzip2.CRC">
             A simple class the hold and calculate the CRC for sanity checking
             of the data.
            
             @author <a href="mailto:keiron@aftexsw.com">Keiron Liddle</a>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Collections.ISelector`1">
            <summary>Interface for matching objects in an <see cref="T:Org.BouncyCastle.Utilities.Collections.IStore`1"/>.</summary>
            <typeparam name="T">The contravariant type of selectable objects.</typeparam>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Collections.ISelector`1.Match(`0)">
            <summary>Match the passed in object, returning true if it would be selected by this selector, false
            otherwise.</summary>
            <param name="candidate">The object to be matched.</param>
            <returns><code>true</code> if the objects is matched by this selector, false otherwise.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Collections.IStore`1">
            <summary>A generic interface describing a simple store of objects.</summary>
            <typeparam name="T">The covariant type of stored objects.</typeparam>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Collections.IStore`1.EnumerateMatches(Org.BouncyCastle.Utilities.Collections.ISelector{`0})">
            <summary>Enumerate the (possibly empty) collection of objects matched by the given selector.</summary>
            <param name="selector">The <see cref="T:Org.BouncyCastle.Utilities.Collections.ISelector`1"/> used to select matching objects.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of the matching objects.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Date.DateTimeUtilities.DateTimeToUnixMs(System.DateTime)">
            <summary>
            Return the number of milliseconds since the Unix epoch (1 Jan., 1970 UTC) for a given DateTime value.
            </summary>
            <remarks>The DateTime value will be converted to UTC (using <see cref="M:System.DateTime.ToUniversalTime"/> before
            conversion.</remarks>
            <param name="dateTime">A DateTime value not before the epoch.</param>
            <returns>Number of whole milliseconds after epoch.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">'dateTime' is before the epoch.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Date.DateTimeUtilities.UnixMsToDateTime(System.Int64)">
            <summary>
            Create a UTC DateTime value from the number of milliseconds since the Unix epoch (1 Jan., 1970 UTC).
            </summary>
            <param name="unixMs">Number of milliseconds since the epoch.</param>
            <returns>A UTC DateTime value</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">'unixMs' is before 'MinUnixMs' or after 'MaxUnixMs'.
            </exception>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Date.DateTimeUtilities.CurrentUnixMs">
            <summary>
            Return the current number of milliseconds since the Unix epoch (1 Jan., 1970 UTC).
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Encode(System.Byte[])">
             encode the input data producing a base 64 encoded byte array.
            
             @return a byte array containing the base 64 encoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Encode(System.Byte[],System.Int32,System.Int32)">
             encode the input data producing a base 64 encoded byte array.
            
             @return a byte array containing the base 64 encoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Encode(System.Byte[],System.IO.Stream)">
             Encode the byte data to base 64 writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Encode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             Encode the byte data to base 64 writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Decode(System.Byte[])">
             decode the base 64 encoded input data. It is assumed the input data is valid.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Decode(System.String)">
             decode the base 64 encoded string data - whitespace will be ignored.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Decode(System.String,System.IO.Stream)">
             decode the base 64 encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Encoders.Hex">
            <summary>
            Class to decode and encode Hex.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[])">
             encode the input data producing a Hex encoded byte array.
            
             @return a byte array containing the Hex encoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[],System.Int32,System.Int32)">
             encode the input data producing a Hex encoded byte array.
            
             @return a byte array containing the Hex encoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[],System.IO.Stream)">
             Hex encode the byte data writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             Hex encode the byte data writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Decode(System.Byte[])">
             decode the Hex encoded input data. It is assumed the input data is valid.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Decode(System.String)">
             decode the Hex encoded string data - whitespace will be ignored.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Decode(System.String,System.IO.Stream)">
             decode the Hex encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.DecodeStrict(System.String)">
             Decode the hexadecimal-encoded string strictly i.e. any non-hexadecimal characters will be
             considered an error.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.DecodeStrict(System.String,System.Int32,System.Int32)">
             Decode the hexadecimal-encoded string strictly i.e. any non-hexadecimal characters will be
             considered an error.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.HexEncoder.Encode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             encode the input data producing a Hex output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.HexEncoder.Decode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             decode the Hex encoded byte data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.HexEncoder.DecodeString(System.String,System.IO.Stream)">
             decode the Hex encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Encoders.IEncoder">
            Encode and decode byte arrays (typically from binary to 7-bit ASCII
            encodings).
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IMemoable.Copy">
            <summary>
            Produce a copy of this object with its configuration and in its current state.
            </summary>
            <remarks>
            The returned object may be used simply to store the state, or may be used as a similar object
            starting from the copied state.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IMemoable.Reset(Org.BouncyCastle.Utilities.IMemoable)">
            <summary>
            Restore a copied object state into this object.
            </summary>
            <remarks>
            Implementations of this method <em>should</em> try to avoid or minimise memory allocation to perform the reset.
            </remarks>
            <param name="other">an object originally {@link #copy() copied} from an object of the same type as this instance.</param>
            <exception cref="T:System.InvalidCastException">if the provided object is not of the correct type.</exception>
            <exception cref="T:Org.BouncyCastle.Utilities.MemoableResetException">if the <b>other</b> parameter is in some other way invalid.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Pem.PemObjectGenerator.Generate">
            <returns>
            A <see cref="T:Org.BouncyCastle.Utilities.IO.Pem.PemObject"/>
            </returns>
            <exception cref="T:Org.BouncyCastle.Utilities.IO.Pem.PemGenerationException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Streams.PipeAll(System.IO.Stream,System.IO.Stream)">
            <summary>Write the full contents of inStr to the destination stream outStr.</summary>
            <param name="inStr">Source stream.</param>
            <param name="outStr">Destination stream.</param>
            <exception cref="T:System.IO.IOException">In case of IO failure.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Streams.PipeAll(System.IO.Stream,System.IO.Stream,System.Int32)">
            <summary>Write the full contents of inStr to the destination stream outStr.</summary>
            <param name="inStr">Source stream.</param>
            <param name="outStr">Destination stream.</param>
            <param name="bufferSize">The size of temporary buffer to use.</param>
            <exception cref="T:System.IO.IOException">In case of IO failure.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Streams.PipeAllLimited(System.IO.Stream,System.Int64,System.IO.Stream)">
            <summary>
            Pipe all bytes from <c>inStr</c> to <c>outStr</c>, throwing <c>StreamFlowException</c> if greater
            than <c>limit</c> bytes in <c>inStr</c>.
            </summary>
            <param name="inStr">
            A <see cref="T:System.IO.Stream"/>
            </param>
            <param name="limit">
            A <see cref="T:System.Int64"/>
            </param>
            <param name="outStr">
            A <see cref="T:System.IO.Stream"/>
            </param>
            <returns>The number of bytes actually transferred, if not greater than <c>limit</c></returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Streams.WriteBufTo(System.IO.MemoryStream,System.Byte[],System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.MemoableResetException">
            Exception to be thrown on a failure to reset an object implementing Memoable.
            <p>
            The exception extends InvalidCastException to enable users to have a single handling case,
            only introducing specific handling of this one if required.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Net.IPAddress.IsValid(System.String)">
             Validate the given IPv4 or IPv6 address.
            
             @param address the IP address as a string.
            
             @return true if a valid address, false otherwise
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Net.IPAddress.IsValidWithNetMask(System.String)">
             Validate the given IPv4 or IPv6 address and netmask.
            
             @param address the IP address as a string.
            
             @return true if a valid address with netmask, false otherwise
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Net.IPAddress.IsValidIPv4(System.String)">
             Validate the given IPv4 address.
             
             @param address the IP address as a string.
            
             @return true if a valid IPv4 address, false otherwise
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Net.IPAddress.IsValidIPv6(System.String)">
             Validate the given IPv6 address.
            
             @param address the IP address as a string.
            
             @return true if a valid IPv4 address, false otherwise
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Strings">
            <summary> General string utilities.</summary>
        </member>
        <member name="T:Org.BouncyCastle.X509.AttributeCertificateHolder">
            <remarks>
            The Holder object.
            <pre>
            Holder ::= SEQUENCE {
            	baseCertificateID   [0] IssuerSerial OPTIONAL,
            		-- the issuer and serial number of
            		-- the holder's Public Key Certificate
            	entityName          [1] GeneralNames OPTIONAL,
            		-- the name of the claimant or role
            	objectDigestInfo    [2] ObjectDigestInfo OPTIONAL
            		-- used to directly authenticate the holder,
            		-- for example, an executable
            }
            </pre>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.X509.AttributeCertificateHolder.#ctor(System.Int32,System.String,System.String,System.Byte[])">
             Constructs a holder for v2 attribute certificates with a hash value for
             some type of object.
             <p>
             <code>digestedObjectType</code> can be one of the following:
             <ul>
             <li>0 - publicKey - A hash of the public key of the holder must be
             passed.</li>
             <li>1 - publicKeyCert - A hash of the public key certificate of the
             holder must be passed.</li>
             <li>2 - otherObjectDigest - A hash of some other object type must be
             passed. <code>otherObjectTypeID</code> must not be empty.</li>
             </ul>
             </p>
             <p>This cannot be used if a v1 attribute certificate is used.</p>
            
             @param digestedObjectType The digest object type.
             @param digestAlgorithm The algorithm identifier for the hash.
             @param otherObjectTypeID The object type ID if
                        <code>digestedObjectType</code> is
                        <code>otherObjectDigest</code>.
             @param objectDigest The hash value.
        </member>
        <member name="P:Org.BouncyCastle.X509.AttributeCertificateHolder.DigestedObjectType">
             Returns the digest object type if an object digest info is used.
             <p>
             <ul>
             <li>0 - publicKey - A hash of the public key of the holder must be
             passed.</li>
             <li>1 - publicKeyCert - A hash of the public key certificate of the
             holder must be passed.</li>
             <li>2 - otherObjectDigest - A hash of some other object type must be
             passed. <code>otherObjectTypeID</code> must not be empty.</li>
             </ul>
             </p>
            
             @return The digest object type or -1 if no object digest info is set.
        </member>
        <member name="P:Org.BouncyCastle.X509.AttributeCertificateHolder.DigestAlgorithm">
             Returns the other object type ID if an object digest info is used.
            
             @return The other object type ID or <code>null</code> if no object
                     digest info is set.
        </member>
        <member name="M:Org.BouncyCastle.X509.AttributeCertificateHolder.GetObjectDigest">
             Returns the hash if an object digest info is used.
            
             @return The hash or <code>null</code> if no object digest info is set.
        </member>
        <member name="P:Org.BouncyCastle.X509.AttributeCertificateHolder.OtherObjectTypeID">
             Returns the digest algorithm ID if an object digest info is used.
            
             @return The digest algorithm ID or <code>null</code> if no object
                     digest info is set.
        </member>
        <member name="M:Org.BouncyCastle.X509.AttributeCertificateHolder.GetEntityNames">
             Return any principal objects inside the attribute certificate holder entity names field.
            
             @return an array of IPrincipal objects (usually X509Name), null if no entity names field is set.
        </member>
        <member name="M:Org.BouncyCastle.X509.AttributeCertificateHolder.GetIssuer">
             Return the principals associated with the issuer attached to this holder
            
             @return an array of principals, null if no BaseCertificateID is set.
        </member>
        <member name="P:Org.BouncyCastle.X509.AttributeCertificateHolder.SerialNumber">
             Return the serial number associated with the issuer attached to this holder.
            
             @return the certificate serial number, null if no BaseCertificateID is set.
        </member>
        <member name="T:Org.BouncyCastle.X509.AttributeCertificateIssuer">
            Carrying class for an attribute certificate issuer.
        </member>
        <member name="M:Org.BouncyCastle.X509.AttributeCertificateIssuer.#ctor(Org.BouncyCastle.Asn1.X509.AttCertIssuer)">
             Set the issuer directly with the ASN.1 structure.
            
             @param issuer The issuer
        </member>
        <member name="M:Org.BouncyCastle.X509.AttributeCertificateIssuer.GetPrincipals">
            <summary>Return any principal objects inside the attribute certificate issuer object.</summary>
            <returns>An array of IPrincipal objects (usually X509Principal).</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.Extension.X509ExtensionUtilities.FromExtensionValue(Org.BouncyCastle.X509.IX509Extension,Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>
            Extract the value of the given extension, if it exists.
            </summary>
            <param name="extensions">The extensions object.</param>
            <param name="oid">The object identifier to obtain.</param>
            <returns>Asn1Object</returns>
            <exception cref="T:System.Exception">if the extension cannot be read.</exception>
        </member>
        <member name="M:Org.BouncyCastle.X509.IX509Extension.GetCriticalExtensionOids">
            <summary>
            Get all critical extension values, by oid
            </summary>
            <returns>IDictionary with string (OID) keys and Asn1OctetString values</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.IX509Extension.GetNonCriticalExtensionOids">
            <summary>
            Get all non-critical extension values, by oid
            </summary>
            <returns>IDictionary with string (OID) keys and Asn1OctetString values</returns>
        </member>
        <member name="T:Org.BouncyCastle.X509.PrincipalUtilities">
            <remarks>
            A utility class that will extract X509Principal objects from X.509 certificates.
            <p>
            Use this in preference to trying to recreate a principal from a string, not all
            DNs are what they should be, so it's best to leave them encoded where they
            can be.</p>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.X509.PrincipalUtilities.GetIssuerX509Principal(Org.BouncyCastle.X509.X509Certificate)">
            <summary>Return the issuer of the given cert as an X509Principal.</summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.PrincipalUtilities.GetSubjectX509Principal(Org.BouncyCastle.X509.X509Certificate)">
            <summary>Return the subject of the given cert as an X509Principal.</summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.PrincipalUtilities.GetIssuerX509Principal(Org.BouncyCastle.X509.X509Crl)">
            <summary>Return the issuer of the given CRL as an X509Principal.</summary>
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509CertStoreSelector.Policy">
            <summary>
            An <code>ISet</code> of <code>DerObjectIdentifier</code> objects.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.X509.SubjectPublicKeyInfoFactory">
            <summary>
            A factory to produce Public Key Info Objects.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.SubjectPublicKeyInfoFactory.CreateSubjectPublicKeyInfo(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Create a Subject Public Key Info object for a given public key.
            </summary>
            <param name="publicKey">One of ElGammalPublicKeyParameters, DSAPublicKeyParameter, DHPublicKeyParameters, RsaKeyParameters or ECPublicKeyParameters</param>
            <returns>A subject public key info object.</returns>
            <exception cref="T:System.Exception">Throw exception if object provided is not one of the above.</exception>
        </member>
        <member name="T:Org.BouncyCastle.X509.X509Attribute">
            Class for carrying the values in an X.509 Attribute.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Attribute.#ctor(Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param at an object representing an attribute.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Attribute.#ctor(System.String,Org.BouncyCastle.Asn1.Asn1Encodable)">
             Create an X.509 Attribute with the type given by the passed in oid and
             the value represented by an ASN.1 Set containing value.
            
             @param oid type of the attribute
             @param value value object to go into the atribute's value set.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Attribute.#ctor(System.String,Org.BouncyCastle.Asn1.Asn1EncodableVector)">
             Create an X.59 Attribute with the type given by the passed in oid and the
             value represented by an ASN.1 Set containing the objects in value.
            
             @param oid type of the attribute
             @param value vector of values to go in the attribute's value set.
        </member>
        <member name="T:Org.BouncyCastle.X509.X509Certificate">
            <summary>
            An Object representing an X509 Certificate.
            Has static methods for loading Certificates encoded in many forms that return X509Certificate Objects.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.IsValidNow">
            <summary>
            Return true if the current time is within the start and end times nominated on the certificate.
            </summary>
            <returns>true id certificate is valid for the current time.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.IsValid(System.DateTime)">
            <summary>
            Return true if the nominated time is within the start and end times nominated on the certificate.
            </summary>
            <param name="time">The time to test validity against.</param>
            <returns>True if certificate is valid for nominated time.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.CheckValidity">
            <summary>
            Checks if the current date is within certificate's validity period.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.CheckValidity(System.DateTime)">
            <summary>
            Checks if the given date is within certificate's validity period.
            </summary>
            <exception cref="T:Org.BouncyCastle.Security.Certificates.CertificateExpiredException">if the certificate is expired by given date</exception>
            <exception cref="T:Org.BouncyCastle.Security.Certificates.CertificateNotYetValidException">if the certificate is not yet valid on given date</exception>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.Version">
            <summary>
            Return the certificate's version.
            </summary>
            <returns>An integer whose value Equals the version of the cerficate.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.SerialNumber">
            <summary>
            Return a <see cref="T:Org.BouncyCastle.Math.BigInteger">BigInteger</see> containing the serial number.
            </summary>
            <returns>The Serial number.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.IssuerDN">
            <summary>
            Get the Issuer Distinguished Name. (Who signed the certificate.)
            </summary>
            <returns>And X509Object containing name and value pairs.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.SubjectDN">
            <summary>
            Get the subject of this certificate.
            </summary>
            <returns>An X509Name object containing name and value pairs.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.NotBefore">
            <summary>
            The time that this certificate is valid from.
            </summary>
            <returns>A DateTime object representing that time in the local time zone.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.NotAfter">
            <summary>
            The time that this certificate is valid up to.
            </summary>
            <returns>A DateTime object representing that time in the local time zone.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.GetTbsCertificate">
            <summary>
            Return the Der encoded TbsCertificate data.
            This is the certificate component less the signature.
            To Get the whole certificate call the GetEncoded() member.
            </summary>
            <returns>A byte array containing the Der encoded Certificate component.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.GetSignature">
            <summary>
            The signature.
            </summary>
            <returns>A byte array containg the signature of the certificate.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.SigAlgName">
            <summary>
            A meaningful version of the Signature Algorithm. (EG SHA1WITHRSA)
            </summary>
            <returns>A sting representing the signature algorithm.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.SigAlgOid">
            <summary>
            Get the Signature Algorithms Object ID.
            </summary>
            <returns>A string containg a '.' separated object id.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.GetSigAlgParams">
            <summary>
            Get the signature algorithms parameters. (EG DSA Parameters)
            </summary>
            <returns>A byte array containing the Der encoded version of the parameters or null if there are none.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.IssuerUniqueID">
            <summary>
            Get the issuers UID.
            </summary>
            <returns>A DerBitString.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.SubjectUniqueID">
            <summary>
            Get the subjects UID.
            </summary>
            <returns>A DerBitString.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.GetKeyUsage">
            <summary>
            Get a key usage guidlines.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.GetPublicKey">
            <summary>
            Get the public key of the subject of the certificate.
            </summary>
            <returns>The public key parameters.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.GetEncoded">
            <summary>
            Return the DER encoding of this certificate.
            </summary>
            <returns>A byte array containing the DER encoding of this certificate.</returns>
            <exception cref="T:Org.BouncyCastle.Security.Certificates.CertificateEncodingException">If there is an error encoding the certificate.</exception>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.Verify(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Verify the certificate's signature using the nominated public key.
            </summary>
            <param name="key">An appropriate public key parameter object, RsaPublicKeyParameters, DsaPublicKeyParameters or ECDsaPublicKeyParameters</param>
            <returns>True if the signature is valid.</returns>
            <exception cref="T:System.Exception">If key submitted is not of the above nominated types.</exception>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.Verify(Org.BouncyCastle.Crypto.IVerifierFactoryProvider)">
            <summary>
            Verify the certificate's signature using a verifier created using the passed in verifier provider.
            </summary>
            <param name="verifierProvider">An appropriate provider for verifying the certificate's signature.</param>
            <returns>True if the signature is valid.</returns>
            <exception cref="T:System.Exception">If verifier provider is not appropriate or the certificate algorithm is invalid.</exception>
        </member>
        <member name="T:Org.BouncyCastle.X509.X509Crl">
             The following extensions are listed in RFC 2459 as relevant to CRLs
            
             Authority Key Identifier
             Issuer Alternative Name
             CRL Number
             Delta CRL Indicator (critical)
             Issuing Distribution Point (critical)
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Crl.Verify(Org.BouncyCastle.Crypto.IVerifierFactoryProvider)">
            <summary>
            Verify the CRL's signature using a verifier created using the passed in verifier provider.
            </summary>
            <param name="verifierProvider">An appropriate provider for verifying the CRL's signature.</param>
            <returns>True if the signature is valid.</returns>
            <exception cref="T:System.Exception">If verifier provider is not appropriate or the CRL algorithm is invalid.</exception>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Crl.GetEncoded">
            <summary>
            Return the DER encoding of this CRL.
            </summary>
            <returns>A byte array containing the DER encoding of this CRL.</returns>
            <exception cref="T:Org.BouncyCastle.Security.Certificates.CrlException">If there is an error encoding the CRL.</exception>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Crl.ToString">
             Returns a string representation of this CRL.
            
             @return a string representation of this CRL.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Crl.IsRevoked(Org.BouncyCastle.X509.X509Certificate)">
             Checks whether the given certificate is on this CRL.
            
             @param cert the certificate to check for.
             @return true if the given certificate is on this CRL,
             false otherwise.
        </member>
        <member name="T:Org.BouncyCastle.X509.X509CrlEntry">
             The following extensions are listed in RFC 2459 as relevant to CRL Entries
            
             ReasonCode Hode Instruction Code Invalidity Date Certificate Issuer
             (critical)
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CrlEntry.#ctor(Org.BouncyCastle.Asn1.X509.CrlEntry,System.Boolean,Org.BouncyCastle.Asn1.X509.X509Name)">
             Constructor for CRLEntries of indirect CRLs. If <code>isIndirect</code>
             is <code>false</code> {@link #getCertificateIssuer()} will always
             return <code>null</code>, <code>previousCertificateIssuer</code> is
             ignored. If this <code>isIndirect</code> is specified and this CrlEntry
             has no certificate issuer CRL entry extension
             <code>previousCertificateIssuer</code> is returned by
             {@link #getCertificateIssuer()}.
            
             @param c
                        TbsCertificateList.CrlEntry object.
             @param isIndirect
                        <code>true</code> if the corresponding CRL is a indirect
                        CRL.
             @param previousCertificateIssuer
                        Certificate issuer of the previous CrlEntry.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509ExtensionBase.GetNonCriticalExtensionOids">
            <summary>
            Get non critical extensions.
            </summary>
            <returns>A set of non critical extension oids.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509ExtensionBase.GetCriticalExtensionOids">
            <summary>
            Get any critical extensions.
            </summary>
            <returns>A sorted list of critical entension.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509SignatureUtilities.GetDigestAlgName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            Return the digest algorithm using one of the standard JCA string
            representations rather than the algorithm identifier (if possible).
        </member>
        <member name="T:Org.BouncyCastle.X509.X509V2AttributeCertificate">
            <summary>An implementation of a version 2 X.509 Attribute Certificate.</summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2AttributeCertificate.Verify(Org.BouncyCastle.Crypto.IVerifierFactoryProvider)">
            <summary>
            Verify the certificate's signature using a verifier created using the passed in verifier provider.
            </summary>
            <param name="verifierProvider">An appropriate provider for verifying the certificate's signature.</param>
            <returns>True if the signature is valid.</returns>
            <exception cref="T:System.Exception">If verifier provider is not appropriate or the certificate algorithm is invalid.</exception>
        </member>
    </members>
</doc>
